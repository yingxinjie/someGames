{"./":{"url":"./","title":"Introduction","keywords":"","body":"Cocos Creator 3.0 用户手册 欢迎使用 Cocos Creator 3.0 用户手册！本手册包括详尽的使用说明、面向不同职能用户的工作流程和 step by step 的新手教程。能够帮您快速掌握使用 Cocos Creator 3.0 开发跨平台游戏的方法。 注意：请在右上角根据您使用的 Cocos Creator 版本选择相应的手册版本。 总导读 Cocos Creator 新手入门 场景制作 资源系统 脚本指南及事件系统 发布跨平台游戏 图形渲染 2D 渲染 UI 系统 动画系统 声音系统 物理系统 粒子系统 缓动系统 地形系统 资源管理 扩展编辑器 进阶主题 演示和范例项目 展示范例集合（GitHub | Gitee）：从基本组件的使用到渲染效果的展示，这个项目里包括了多个侧重功能不同的场景及多个游戏 Demo 供用户参考 一步两步（GitHub | Gitee）：也就是 快速上手 文档里分步讲解制作的游戏 物理测试范例（GitHub | Gitee）：包含了一些物理测试例和案例工程，如吞噬黑洞、简化小车、坠落小球等，介绍了一些基础的功能和使用方法，方便用户结合文档了解物理功能。 Simple-Games（GitHub | Gitee）：简单小游戏集合演示 Demo，用户可通过此案例学习完成一些简单并且常见的小游戏。 模块展示集合（GitHub | Gitee）：引擎各个功能的范例项目，基本涵盖了引擎的大部分功能模块，用户在使用功能时可参考此项目中的用法进行开发。 UI 展示 Demo（GitHub | Gitee）：各类 UI 组件组合使用的演示 Demo。 弹弹乐 3D（GitHub | Gitee）：用户可通过此项目制作弹弹球游戏。 快上车 3D（GitHub | Gitee）：基于物理的游戏制作 demo，用户可通过此项目制作快上车游戏。 注意：这些项目会不定期跟随版本进行更新。它们在 GitHub 上的默认分支是 master，对应的一般是最新的 Cocos Creator 及版本。如果仍在使用旧版本的 Cocos Creator，这些项目有可能会打不开，可尝试切换到和旧版本相同命名的分支。 视频教程 快上车视频教程 更多视频教程可前往 哔哩哔哩 — Cocos 官方。 "},"getting-started/":{"url":"getting-started/","title":"基础使用","keywords":"","body":"新手上路 欢迎使用 Cocos Creator，在学习使用之前，请先参考 安装和启动 安装好 Cocos Creator。 在安装完编辑器之后，可以通过以下内容来熟悉编辑器，包括如何创建项目、项目结构，以及编辑器界面介绍等： 使用 Dashboard 项目结构 编辑器界面 对编辑器有了一定的熟悉和了解之后，便可以通过简单的示例来熟悉 Cocos Creator 的开发流程： Hello world! 快速上手：制作第一个游戏 同时 Cocos Creator 还提供了很多的范例和教程，并支持其他第三方工具和资源等。开发者也可以直接反馈问题给 Cocos Creator 开发团队： 获取帮助和支持 注意事项 "},"getting-started/introduction/":{"url":"getting-started/introduction/","title":"关于 Cocos Creator","keywords":"","body":"关于 Cocos Creator Q：Cocos Creator 是游戏引擎吗？ A：它是一个完整的游戏开发解决方案，包含了轻量高效的跨平台游戏引擎，以及能让你更快速开发游戏所需要的各种图形界面工具。 Q：Cocos Creator 的编辑器是什么样的？ A：完全为引擎定制打造，包含从设计、开发、预览、调试到发布的整个工作流所需的全功能一体化编辑器。 Q：我不会写程序，也能使用 Cocos Creator 吗？ A：当然！Cocos Creator 编辑器提供面向设计和开发的两种工作流，提供简单顺畅的分工合作方式。 Q：我使用 Cocos Creator 能开发面向哪些平台的游戏？ A：Cocos Creator 目前支持发布游戏到 Web、iOS、Android、各类\"小游戏\"、PC 客户端等平台，真正实现一次开发，全平台运行。 产品定位 Cocos Creator 是以内容创作为核心，实现了脚本化、组件化和数据驱动的游戏开发工具。具备了易于上手的内容生产工作流，以及功能强大的开发者工具套件，可用于实现游戏逻辑和高性能游戏效果。 工作流程说明 在开发阶段，Cocos Creator 已经能够为用户带来巨大的效率和创造力提升，但我们所提供的工作流远不仅限于开发层面。对于成功的游戏来说，开发和调试、商业化 SDK 的集成、多平台发布、测试、上线这一整套工作流程不光缺一不可，而且要经过多次的迭代重复。 Cocos Creator 将整套手机页游解决方案整合在了编辑器工具里，无需在多个软件之间穿梭，只要打开 Cocos Creator 编辑器，各种一键式的自动化流程就能花最少的时间精力，解决上述所有问题。开发者就能够专注于开发阶段，提高产品竞争力和创造力！ 创建或导入资源 将图片、声音等资源拖拽到编辑器的 资源管理器 面板中，即可完成资源导入。 此外，你也可以在编辑器中直接创建场景、预制、动画、脚本、粒子等各类资源。 搭建场景 项目中有了一些基本资源后，我们就可以开始搭建场景了，场景是游戏内容最基本的组织方式，也是向玩家展示游戏的基本形态。 添加组件脚本，实现交互功能 我们可以为场景中的节点挂载各种内置组件和自定义脚本组件，来实现游戏逻辑的运行和交互。包括从最基本的动画播放、按钮响应，到驱动整个游戏逻辑的主循环脚本和玩家角色的控制。几乎所有游戏逻辑功能都是通过挂载脚本到场景中的节点来实现的。 一键预览和发布 搭建场景和开发功能的过程中，你可以随时点击预览来查看当前场景的运行效果。使用手机扫描二维码，可以立即在手机上预览游戏。当开发告一段落时，通过 构建发布 面板可以一键发布游戏到包括桌面、手机、Web、小游戏等多个平台。 功能特性 Cocos Creator 功能上的突出特色包括： 脚本中可以轻松声明可以在编辑器中随时调整的数据属性，对参数的调整可以由设计人员独立完成。 支持智能画布适配和免编程元素对齐的 UI 系统，可以完美适配任意分辨率的设备屏幕。 动画系统，支持动画轨迹预览和复杂曲线编辑功能。 使用动态语言支持的脚本开发，包括 JavaScript 和 TypeScript，使得动态调试和移动设备远程调试变得异常轻松。 底层由 Cocos2d-x 演化而来，在享受脚本化开发的便捷时，保持原生级别的轻量和高性能。 脚本组件化和开放式的插件系统为开发者在不同深度上提供了定制工作流的方法，编辑器可以大尺度调整来适应不同团队和项目的需求。 架构特色 Cocos Creator 包含游戏引擎、资源管理、场景编辑、游戏预览和发布等游戏开发所需的全套功能，并且将所有的功能和工具链都整合在了一个统一的应用程序里。 编辑器在提供强大完整工具链的同时，提供了开放式的插件架构，开发者能够用 HTML + TypeScript 等前端通用技术轻松扩展编辑器功能，定制个性化的工作流程。 以下，是 Cocos Creator 的技术架构图： 图一 图二 从图中我们可以看出，编辑器是由 Electron 驱动再结合引擎所搭建的开发环境，引擎则负责提供许多开发上易于使用的组件和适配各平台的统一接口。 引擎和编辑器的结合，带来的是数据驱动和组件化的功能开发方式，以及设计和程序两类人员的完美分工合作： 设计师在场景编辑器中搭建场景的视觉表现 程序员开发可以挂载到场景任意物体上的功能组件 设计师负责为需要展现特定行为的物体挂载组件，并通过调试改善各项参数 程序员开发游戏所需要的数据结构和资源 设计师通过图形化的界面配置好各项数据和资源 （就这样从简单到复杂，各种你能想像到的工作流程都可以实现） 以工作流为核心的开发理念，让不同职能的开发者能够快速找到最大化自己作用的工作切入点，并能够默契流畅的和团队其他成员配合。 使用说明 在数据驱动的工作流基础上，场景的创建和编辑成为了游戏开发的重心，设计工作和功能开发可以同步进行，无缝协作。不管是美术、策划还是程序员，都可以在生产过程的任意时刻点击预览按钮，在浏览器、移动设备模拟器或移动设备真机上测试游戏的最新状态。 程序员和设计人员现在可以实现各式各样的分工合作，不管是先搭建场景，再添加功能，还是先生产功能模块再由设计人员进行组合调试，Cocos Creator 都能满足开发团队的需要。脚本中定义的属性能够以最适合的视觉体验呈现在编辑器中，为内容生产者提供便利。 场景之外的内容资源可以由外部导入，比如图片、声音、图集、骨骼动画等等，除此之外我们还在不断完善编辑器生产资源的能力，包括目前已经完成的动画编辑器，美术人员可以使用这个工具制作出非常细腻富有表现力的动画资源，并可以随时在场景中看到动画的预览。 支持 2D 和 3D 游戏开发，其功能可满足各种游戏类型的特定需求。深入优化了编辑器体验和引擎性能，并内置了对中间件的支持，如 Spine、DragonBones、TiledMap、Box2D 和 Texture Packer。 最后，开发完成的游戏可以通过图形工具一键发布到各个平台，从设计研发到测试发布，Cocos Creator 全部帮您搞定。 "},"getting-started/install/":{"url":"getting-started/install/","title":"安装和启动","keywords":"","body":"安装和启动 Cocos Creator 从 v2.3.2 开始接入了全新的 Dashboard 系统，能够同时对多版本引擎和项目进行统一升级和管理！Cocos Dashboard 将做为 Creator 各引擎统一的下载器和启动入口，方便大家升级和管理多个版本的 Creator。此外还集成了统一的项目管理及创建面板，方便大家同时使用不同版本的引擎开发项目 下载 Dashboard 您可以通过访问 Cocos Creator 产品首页 上的下载链接获得 Dashboard 的安装包。 下载完成后双击安装包。 Windows 安装说明 Windows 版的安装程序是一个 .exe 可执行文件，通常命名会是 CocosDashboard-vX.X.X-win32-20XXXXXX.exe，其中 vX.X.X 是 Cocos Dashboard 的版本号，如 v1.0.11，后面的一串数字是版本日期编号。 注意： 如果当前 PC 上已安装的版本号和安装包的版本号相同时，无法自动覆盖安装相同版本号的安装包，需要先卸载之前的版本才能继续安装。 应用的安装路径默认选择 C:\\CocosDashboard，可以在安装过程中进行更改。 如果出现 “不能安装需要的文件，因为 CAB 文件没有正确的数字签名。可能表明 CAB 文件损坏” 的弹窗警告，请尝试使用管理员权限进行安装。 对于部分很老并且长期处于内网或者很久没有升级操作系统补丁的 Windows 系统，运行时可能会出现一些 dll 缺失引起的相关报错，可尝试安装该系统补丁解决：https://support.microsoft.com/zh-cn/help/2999226/update-for-universal-c-runtime-in-windows 如果安装过程中出现 “拒绝访问” 的弹窗，请确保本机安装的操作系统是微软官方的正式版本，而不是经过定制或精简的第三方版本。 Mac 安装说明 Mac 版 Cocos Dashboard 的安装程序是 dmg 镜像文件，双击 dmg 文件，然后将 CocosDashboard.app 拖拽到您的 应用程序 文件夹快捷方式，或任意其他位置。然后双击拖拽出来的 CocosDashboard.app 就可以开始使用了。 注意： 如果下载后无法打开，提示 dmg 或者 app 文件已损坏、来自身份不明的开发者或者包含恶意软件等。请在 Finder（访达）中右键点击 dmg 或 app 文件，选择 打开，接着在弹出对话框中再次点击 打开 即可。然后请进入 系统偏好设置 -> 安全性与隐私，点击 仍要打开，这样以后就可以正常启动了。 在安装过程中如果出现“已损坏，无法打开”的提示，需要检查是否有类似 Xcode 的软件占用了 Dashboard 安装目录下的相关文件。如果有的话，请先退出，然后卸载 Dashboard 并重新安装。 操作系统要求 Cocos Dashboard 所支持的系统环境是： Mac OS X 所支持的最低版本是 OS X 10.9。 Windows 所支持的最低版本是 Windows 7 64位。 运行 Cocos Dashboard 在 Windows 系统，双击解压后 CocosDashboard 文件夹中的 CocosDashboard.exe 文件即可启动 Cocos Dashboard。 在 Mac 系统，双击拖动出来的 CocosDashboard.app 应用图标即可启动 Cocos Dashboard。 您可以按照习惯为入口文件设置快速启动、Dock 或快捷方式，方便您随时运行使用。 检查显卡驱动 对于部分 Windows 操作系统和显卡型号，可能会遇到 This browser does not support WebGL... 的报错信息。这是由于编辑器依赖 GPU 渲染，而显卡驱动不支持导致的。如果出现这种情况，通常只要确保已成功安装显卡对应型号的官方驱动即可解决。 使用 Cocos 开发者帐号登录 Cocos Dashboard 启动后，会进入 Cocos 开发者帐号的登录界面。登录之后就可以享受我们为开发者提供的各种在线服务、产品更新通知和各种开发者福利。 如果之前没有 Cocos 开发者帐号，您可以使用登录界面中的 注册 按钮前往 Cocos 开发者中心 进行注册。或者直接进入下面的链接注册： https://auth.cocos.com/#/sign_up/register 注册完成后就可以回到 Cocos Dashboard 登录界面完成登录了！验证身份后，我们就会进入 Dashboard 界面。除了手动登出或登录信息过期，其他情况下都会用本地 session 保存的信息自动登录。 "},"getting-started/dashboard/":{"url":"getting-started/dashboard/","title":"使用 Dashboard","keywords":"","body":"使用 Dashboard 启动 Cocos Dashboard 并使用 Cocos 开发者帐号登录以后，就会打开 Dashboard 界面，在这里你可以下载引擎、新建项目、打开已有项目或者获得帮助信息。 界面总览 上图所示的就是 Cocos Dashboard 界面，可以点击右上角的设置图标按钮来指定通过 Dashboard 下载的 Creator 编辑器的存放位置，以及 Dashboard 界面显示的语言等。 Cocos Dashboard 界面主要包括以下几种选项卡： 项目: 列出最近打开项目，第一次运行 Cocos Dashboard 时，这个列表是空的。可以在这个选项卡中新建项目。 编辑器: 列出已下载的所有 Creator 编辑器版本，也可以点击右下角的 下载 按钮继续下载编辑器。 动态: 用于发布 Cocos Creator 的一些官方信息或者活动等，包括 公告、新闻 和 更新日志 三部分内容。 教程: 帮助信息，一个包括各种新手指引信息和文档的静态页面。 下面我们来依次看一下这些分页面。 项目 可以通过 项目 选项卡快速访问近期打开过的项目，点击具体的项目条目时，即可打开该项目。 1 — 包括 使用其他编辑器打开项目、打开项目所在文件夹、从列表中移除、选择项目的图标、设置项目的描述 和 重命名项目 等功能。 选择项目的图标：项目图标目前支持 BMP、PNG、GIF、JPG 四种格式（Dashboard 1.0.12 新增）。 重命名项目：重命名项目将重命名项目文件夹（Dashboard 1.0.12 新增）。 设置项目的描述：项目备注记录在项目目录下 package.json 文件的 description 字段中（Dashboard 1.0.19 新增）。 2 — 可选择其他编辑器打开项目。 3 — 可根据时间正序/反序排列项目（Dashboard 1.0.12 新增）。 4 — 可通过项目名称直接搜索项目（Dashboard 1.0.12 新增）。 导入 按钮 — 用于导入其他项目。从 v1.0.13 开始，支持直接将项目从操作系统的文件管理器拖拽到列表中。 新建 按钮 — 用于新建项目，点击该按钮后会进入 新建项目 页面，详情可参考下方介绍。 新建项目 在新建项目页面，点击上方的 类型 和 编辑器版本 可选择 Creator 的引擎和编辑器版本。 Creator 提供了一些项目模板，包括了各种不同类型的游戏基本架构，以及学习用的范例资源和脚本，来帮助开发者更快进入到创造性的工作当中。随着 Cocos Creator 功能越来越完整，我们也会持续添加更多的项目模板。 点击选择其中一个项目模板，在页面下方可以看到 项目名称 和 项目存放位置。 项目名称：项目名称只能包含 a-z、A-Z、0-9 以及 _ 和 -。 项目存放位置：点击项目路径输入框后面的图标即可选择项目的存放路径。 一切都设置好后，点击 创建并打开 按钮来完成项目的创建。Dashboard 界面会被关闭，然后新创建的项目会在 Cocos Creator 编辑器主窗口中打开。 编辑器 该页面会列出已下载安装的所有 Creator 编辑器版本。 需要注意的是，第一次运行 Cocos Dashboard 时，这个列表是空的，可以点击右下角的两个按钮导入本地已有的 Creator 编辑器或者直接下载安装。 添加本地版本：用于添加本地已有的 Creator 编辑器到 编辑器 版本列表。从 v1.0.13 开始，支持直接将本地已有的 Creator 编辑器从操作系统的文件管理器拖拽到 编辑器 版本列表中。 下载编辑器：点击该按钮会跳转到编辑器下载页面，该页面会列出所有已安装和未安装的编辑器版本，可选择所需的编辑器版本进行下载。 动态 该页面用于发布 Cocos Creator 的一些官方通知或者活动等，包括 公告、新闻 和 更新日志 三个模块。 教程 可以通过 教程 页面访问 Cocos Creator 用户手册、API 手册和其他帮助文档，以及教程和范例项目等。 开发者也可以通过点击左下角各网站的图标访问 Cocos 官方获取更多教程等信息，目前包括微信公众号、微博、Twitter、哔哩哔哩、YouTube 和 GitHub。 "},"getting-started/helloworld/":{"url":"getting-started/helloworld/","title":"Hello World!","keywords":"","body":"Hello World 项目 了解 Cocos Dashboard 以后，我们接下来看看如何创建和打开一个 Hello World 项目。 新建项目 在 Cocos Dashboard 的 项目 选项卡中，点击右下角的 新建 按钮，进入 新建项目 页面。选择 empty 项目模板，设置好项目名称和项目路径 然后点击右下方的 创建并打开 按钮，就会自动以空项目模板创建项目并打开： 资源管理器：显示了项目资源文件夹（assets）中的所有资源。 场景编辑器：用于展示和编辑场景中可视内容的工作区域。 层级管理器：用树状列表的形式展示场景中的所有节点和它们的层级关系，所有在 场景编辑器 中看到的内容都可以在 层级管理器 中找到对应的节点条目 属性检查器：用于查看并编辑当前选中节点及其组件属性的工作区域 资源预览：在 资源管理器 中选中资源，即可在 资源预览 面板中显示资源的缩略图。若选中资源所在的文件夹，即可显示文件夹下所有资源的缩略图，方便查看。 动画编辑器：用于制作一些不太复杂的、需要与逻辑进行联动的动画，例如 UI 动画。 控制台：用于显示报错、警告或其他 Cocos Creator 编辑器和引擎生成的日志信息。 关于编辑器各个面板，具体的内容请参考 编辑器面板。 新建场景 在左下方的 资源管理器 面板中点击鼠标右键，选择 创建 -> Scene。 或者也可以直接点击左上角的 + 按钮，然后选择 Scene，即可在 资源管理器 的 asset 目录下新建一个场景： 创建物体 在左上方的 层级管理器 面板中点击鼠标右键, 选择 创建 -> 3D 对象 -> Cube 立方体。或者也可以直接点击左上角的 + 按钮，然后选择 3D 对象 -> Cube 立方体。 即可创建一个立方体并且显示在 场景编辑器 中： 添加脚本 新建脚本 在 资源管理器 面板中点击鼠标右键，选择 创建 -> TypeScript，然后命名为 “HelloWorld”，即可在 资源管理器 的 asset 目录下新建一个脚本。 添加代码 双击新建的脚本，脚本会自动在脚本编辑器中打开，前提是需要在编辑器菜单栏的 Cocos Creator -> 偏好设置 -> 外部程序 -> 默认脚本编辑器 中指定好使用的脚本编辑器。 然后在脚本中添加 start() 函数，start() 函数会在组件第一次激活时调用，并输出 “Hello world”。 import { _decorator, Component, Node } from 'cc'; const { ccclass, property } = _decorator; @ccclass('HelloWorld') export class HelloWorld extends Component { /* class member could be defined like this */ // dummy = ''; /* use `property` decorator if your want the member to be serializable */ // @property // serializableDummy = 0; start () { // Your initialization goes here. console.info('Hello world'); } // update (deltaTime: number) { // // Your update function goes here. // } } 绑定脚本 在 层级管理器 中选中创建的 Cube 节点，然后在 属性检查器 面板最下方点击 添加组件 -> 自定义脚本 -> HelloWorld，即可将脚本挂载到 Cube 节点上。或者也可以直接将脚本拖拽到 属性检查器 面板。 注意：场景设置完成后，切记要保存场景。 预览场景 简单的场景搭建完成后，就可以点击编辑器上方的 预览 按钮来预览游戏了。目前支持使用 浏览器/模拟器/预览窗口 进行预览。 以使用 浏览器 预览为例，Cocos Creator 会使用您的默认浏览器运行当前游戏场景，效果如下图所示： 可以看到在浏览器的开发者工具中的日志信息中输出了 “Hello World”。 修改场景中的 Camera 在预览中我们可以看到立方体似乎有点太小了，这时便可以通过调整场景中的 Camera 来调整场景运行时显示的区域，Camera 代表的是游戏中的玩家视角。 首先在 层级管理器 中选中 Main Camera 节点，场景编辑器 中便会显示变换工具 Gizmo，以及玩家视角的小窗口。 然后在 场景编辑器 中拖动 Gizmo，或者修改 属性检查器 中的 Position 属性，使玩家视角窗口中的立方体显示得更为明显。 然后再次在浏览器中预览，可以看到场景中的立方体就很明显了 "},"getting-started/project-structure/":{"url":"getting-started/project-structure/","title":"项目结构","keywords":"","body":"项目结构 通过 Dashboard，我们可以创建一个 Hello World 项目作为开始，创建之后的项目有特定的文件夹结构，我们将在这一节熟悉 Cocos Creator 项目的文件夹结构。 项目文件夹结构 初次创建并打开一个 Cocos Creator 项目后，开发者项目文件夹的结构如下： assets：资源目录 build：构建目录（在构建某平台后会生成该目录） library：导入的资源目录 local：日志文件目录 profiles：编辑器配置 temp：临时文件目录 package.json：项目配置 资源文件夹（assets） assets 用来放置游戏中所有的本地资源、脚本和第三方库文件。只有在 assets 目录下的内容才能显示在 资源管理器 中。assets 中的每个文件在导入项目后都会生成一个相同名字的 .meta 文件，用于存储对应的资源配置和索引信息。.meta 文件需要一并提交到版本控制系统，详见 资源管理注意事项 --- meta 文件。 一些第三方工具生成的工程或设计源文件，如 TexturePacker 的 .tps 文件，或 Photoshop 的 .psd 文件，可以选择放在 assets 外面管理。 构建目标（build） 在使用编辑器主菜单中的 项目 -> 构建发布 使用默认发布路径发布项目后，编辑器会在项目路径下创建 build 目录，并存放所有目标平台的构建工程。 资源库（library） library 是将 assets 中的资源导入后生成的，在这里文件的结构和资源的格式将被处理成最终游戏发布时需要的形式。 当 library 丢失或损坏的时候，只要删除整个 library 文件夹再打开项目，就会重新生成资源库。 本地设置（local） local 文件夹中包含该项目的本机上的配置信息，包括编辑器面板布局、窗口大小、位置等信息。开发者不需要关心这里的内容。 编辑器配置（profiles） profiles 文件夹中包含编辑器的配置信息，包括各目标平台的构建配置信息、场景配置信息等。 扩展插件文件夹（extensions） extensions 文件夹用于放置此项目的自定义扩展插件。如果需要手动安装扩展插件，可以手动创建该文件夹。如需卸载扩展插件，在 extensions 中删除对应的文件夹即可。 项目设置（settings） settings 里保存特定项目相关的设置，如 项目设置 面板中相关的配置信息等。如果需要在不同开发者之间同步项目设置，请将 settings 目录加入到版本控制。 临时文件夹（temp） temp 是临时文件夹，用于缓存一些 Cocos Creator 在本地的临时文件。这个文件夹可以在关闭 Cocos Creator 后手动删除，开发者不需要关心这里面的内容。 package.json package.json 文件和 assets 文件夹一起，作为验证 Cocos Creator 项目合法性的标志，只有包括了这两个内容的文件夹才能作为 Cocos Creator 项目打开。开发者不需要关心里面的内容。 版本控制 Cocos Creator 在新建项目时，会自动生成 .gitignore 文件，用于排除不应该提交到 git 仓库的文件。如果开发者使用其它版本控制系统，或者需要提交项目到其它地方，应该注意只需要提交 assets、extensions、settings、package.json，或其它手动添加的关联文件。 "},"editor/":{"url":"editor/","title":"编辑器界面","keywords":"","body":"编辑器界面介绍 这一章将会介绍编辑器界面，熟悉组成编辑器的各个面板、菜单和功能按钮。Cocos Creator 编辑器由多个面板组成，面板可以自由移动、组合，以适应不同项目和开发者的需要。我们在这里将会以默认编辑器布局为例，快速浏览各个面板的名称和作用： （A）层级管理器：以树状列表的形式展示场景中的所有节点和它们的层级关系，所有在 场景编辑器 中看到的内容都可以在 层级管理器 中找到对应的节点条目，在编辑场景时这两个面板的内容会同步显示，一般我们也会同时使用这两个面板来搭建场景。 （B）资源管理器：显示了项目资源文件夹（assets）中的所有资源。这里会以树状结构显示文件夹并自动同步在操作系统中对项目资源文件夹内容的修改。您可以将文件从项目外面直接拖拽进来，或使用菜单导入资源。 （C）场景编辑器：用于展示和编辑场景中可视内容的工作区域。通过在场景编辑器中搭建场景，即可获得所见即所得的场景预览。 （D）动画编辑器：用于编辑并存储动画数据。 （E）属性检查器：用于查看并编辑当前选中节点和组件属性的工作区域，这个面板会以最适合的形式展示和编辑来自脚本定义的属性数据。 （F）项目预览：在场景搭建完成之后，在 Web 或原生平台预览游戏的运行效果。 其他重要的编辑器基础界面包括： 控制台 控制台 会显示报错、警告或其他编辑器和引擎生成的日志信息。详情请阅读 控制台 一节。 偏好设置 偏好设置 里提供各种编辑器个性化的全局设置，包括原生开发环境、游戏预览、其他插件的全局设置等。详情请阅读 偏好设置 一节。 项目设置 项目设置 里提供各种项目特定的个性化设置，包括分组管理、功能裁剪、项目预览、自定义引擎等。详情请阅读 项目设置 一节。 服务 Cocos Service 是集成在 Cocos Creator 内的 服务 面板。我们甄选优质技术方案商，提供高性价比服务接入，致力于给用户一键式的接入体验，以及提供相应的技术支撑。同时依托广大 Cocos 开发者群体，我们也将为开发者争取到更加优惠的价格。 具体内容请参考 Cocos Service 简介。 "},"editor/scene/":{"url":"editor/scene/","title":"场景编辑器","keywords":"","body":"场景编辑器 场景编辑器 是内容创作的核心工作区域，用于选择和摆放场景图像、角色、特效、UI 等各类游戏元素。在这个工作区域内可以选中并通过 变换工具 修改节点的位置、旋转和缩放等属性，并可以获得所见即所得的场景效果预览。 视图介绍 场景编辑器 包括 3D 和 2D 两种视图，3D 视图用于 3D 场景编辑，2D 视图则主要用于 UI 节点等 2D 元素的编辑，可通过编辑器左上方工具栏中的 3D/2D 按钮切换场景视图。 3D 视图 在 3D 视图下，可以通过以下操作来移动和定位 场景编辑器 的视图： 鼠标左键 + Alt：以视图中心点为中心旋转。 鼠标中键：平移视图。 鼠标滚轮：以视图中心点为中心缩放视图。 鼠标右键 + WASD：摄像机漫游。 F 快捷键：摄像机聚焦到当前选中节点。 2D 视图 在 2D 视图下，可以通过以下操作来移动和定位 场景编辑器 的视图： 鼠标中键：平移视图。 鼠标滚轮：以当前鼠标悬停位置为中心缩放视图。 鼠标右键：平移视图。 F 快捷键：摄像机聚焦到当前选中节点。 场景设置 场景编辑器 右上角的选项可用于设置场景网格、场景相机参数等，详情请参考下文介绍。 网格设置 场景中的网格是我们摆放场景元素时位置的重要参考信息，可通过 场景编辑器 右上方的按钮设置： 选项 功能说明 3D 图标 场景是否启用 3D 图标，后面的输入框用于设置图标 Gizmo 的大小，取值范围为 0 ~ 8。若勾选该项则表示启用 3D 图标，场景编辑器 中的图标 Gizmo 便会是一个 3D 面片，有近大远小的效果。若不勾选该项，则图标 Gizmo 会显示为一个固定大小的图片。 显示网格 是否显示 场景编辑器 中的网格，后面的颜色设置框用于设置网格的颜色。 场景相机设置 点击 场景编辑器 右上角的 按钮即可设置场景相机（非用户创建的相机）的属性： 选项 功能说明 Fov 设置场景相机的视角大小 Far 设置场景相机的远裁剪面距离 Near 设置场景相机的近裁剪面距离 Color 设置场景背景色 Wheel Speed 设置当滚动鼠标滚轮时，场景相机前后移动的速度 Wander Speed 设置场景相机漫游时的移动速度 渲染输出目标分辨率设置（v3.0.1 新增） 场景编辑器 右上角可根据需要选择场景相机的渲染输出目标分辨率，会影响场景相机的可视范围，方便跟最终预览时选择的分辨率有相似的显示效果： 可在顶部菜单栏的 偏好设置 的 设备管理器 中添加/修改/删除分辨率。 关于相机可视范围的说明可参考 Camera 组件。 场景 Gizmo 场景 Gizmo 在场景视图的右上角，它显示了当前场景相机的观察方向，可以通过点击它来快速切换不同的观察角度。 点击 6 个方向轴，可以快速切换到上，下，左，右，前，后六个角度来观察场景。 点击中心的立方体，可以在正交视图和透视视图间切换。 选择节点 在场景视图中点击鼠标左键选择物体所在节点，选择节点是使用变换工具设置节点位置、旋转、缩放等操作的前提。 Gizmo 操作简介 场景编辑器 的核心功能就是以所见即所得的方式编辑和布置场景中的可见元素，我们主要通过 Gizmo 工具来辅助完成场景的可视化编辑。 变换工具 Gizmo 摄像机 Gizmo 碰撞器 Gizmo 粒子系统 Gizmo "},"editor/hierarchy/":{"url":"editor/hierarchy/","title":"层级管理器","keywords":"","body":"层级管理器 层级管理器 面板上主要包括 工具栏 和 节点列表 两部分内容，用于展现当前场景中可编辑的节点之间的关系。场景中仍有一些不可见的私有节点，不会在此显示。 你可以单选、多选、创建、复制、移动、删除和重命名节点，任意节点都可创建出子节点，子节点的坐标相对于父级节点，跟随父级节点移动。 选中节点，节点呈现蓝底黄字的高亮状态，节点的详细属性会在 属性检查器 中显示。点击面板空白区域，可以 取消选中。 工具栏 中的功能包括：新建节点按钮（+）、搜索类型按钮、搜索框、全部折叠/展开按钮 和 刷新列表按钮。 节点列表 主要体现节点的层级关系，根节点是 场景节点（Scene），编辑 Prefab 文件时，自身的节点作为根节点。可以在这里用右键菜单或者拖拽操作对节点进行增删修改。 面板支持键盘快捷方式： 复制：Ctrl/Cmd + C 粘贴：Ctrl/Cmd + V 克隆：Ctrl/Cmd + D，Ctrl + 拖动节点 删除：Delete 上下选择：上下箭头 节点的折叠：左箭头 节点的展开：右箭头 多选：Ctrl or Cmd + 点击 多选：Shift + 点击 重命名：Enter/F2 取消输入：Esc 新建节点 点击面板左上角的 新建节点（+） 按钮或者直接在面板中点击右键，即可创建节点。 创建节点的时候，会先出现一个 输入框 要求填入节点的名称，节点的名称允许为空，若为空则会以默认节点名称命名。 如果没有在树形列表中选中节点，则新建的节点会默认创建到当前根节点下（Scene） 如果有多个选中节点，则新建的节点会创建到第一个选中节点下。 UI 节点 对于 UI 节点，为了让其正常显示，它的任意上级节点至少得有一个含有 UITransform 组件。所以创建 UI 节点时，如果不符合规则，则会自动创建一个 Canvas 节点作为 UI 节点的根节点，具体内容可参考 UI 结构说明。 Prefab 节点 对于 Prefab 节点，可以直接将 资源管理器 中的一个 Prefab 资源拖动到 层级管理器 中生成一个 Prefab 节点。当然也可以将 层级管理器 中的一个 Prefab 节点拖动到 资源管理器 中生成一个 Prefab 资源。 搜索节点 搜索类型包括：搜索名称或 UUID、搜索 UUID、搜索 Path、搜索组件名称 和 搜索资源 UUID。 其中 搜索组件名称 会搜索出节点列表中包含指定组件的所有节点，可在 属性检查器 查看到组件名称，如 MeshRenderer。 搜索框 会根据输入内容即时更新搜索结果。在搜索结果中选中节点，清空搜索内容后，仍会在资源列表中定位到该选中节点。 更改节点的显示顺序 通过拖拽节点上下移动，可以更改节点在列表中的排序。移动节点分为 被移动的节点 和 目标放置节点： 将 被移动的节点 拖动到 目标放置节点 的上方，两者是 平级 的。 如下图，选中 Cube 节点，并将其拖动到 Sphere 节点的上方，Sphere 节点会呈现黄字的高亮状态，并且在其上方有一条蓝色的线，表示 Cube 节点将会被插入的位置。 将 被移动的节点 拖动到 目标放置节点 上，被移动的节点 会作为 目标放置节点 的子节点排在最末尾。 如下图，选中 Cube 节点，并将其拖动到 Sphere 节点上，Sphere 节点会呈现浅蓝底黄字的高亮状态，表示 Cube 节点将会成为 Sphere 的子节点。 将 被移动的节点 拖动到 目标放置节点 的下方，两者是 平级 的。 如下图，选中 Sphere 节点，并将其拖动到 Cube 节点的下方，Cube 节点会呈现黄字的高亮状态，并且在其下方有一条蓝色的线，表示 Sphere 节点将会被插入的位置。 重命名节点 选中某个节点，然后点击右键，选择 重命名 即可修改节点名称，或者也可以直接使用快捷键 Enter 或者 F2。点击面板其他地方或者按快捷键 Esc 可以取消此次重命名。 不同节点可以有相同的名称。 其他操作 右键点击节点弹出的菜单里还包括下列操作： 复制/粘贴：将节点复制到剪贴板上，然后可以粘贴到另外的位置，或打开另一个场景来粘贴刚才拷贝的节点。 生成副本：生成和选中节点完全相同的节点副本，生成节点和选中节点在同一层级中。 全选：选中同一层级中的所有节点。 复制并打印 UUID/PATH：在复杂场景中，我们有时候需要获取节点的 UUID 或者完整的层级路径，以便在脚本运行时访问该节点。点击该选项，就可以在 控制台 中看到当前选中节点的 UUID 以及节点的层级路径。 锁定节点：鼠标移到节点上，左侧会有一个锁定按钮，节点锁定后便无法在 场景编辑器 中选中该节点。 "},"editor/assets/":{"url":"editor/assets/","title":"资源管理器","keywords":"","body":"资源管理器 资源管理器 面板是用于访问和管理项目资源的重要工作区域。在开始制作游戏时，导入资源 通常是必须的步骤。在新建项目时可以使用 HelloWorld 模板项目，就可以看到 资源管理器 中已经包含了一些基本资源类型。 面板介绍 资源管理器 面板主要可以分为 工具栏 和 资源列表 两部分内容： 工具栏 中的功能包括 新建资源、排序方式、搜索过滤、搜索框、全部折叠/展开 和 刷新列表。详情可参考下文介绍。 资源列表 将项目资源文件夹中的内容以树状结构展示出来，默认包括 assets 和 internal 两个基本资源库（简称 DB）： assets 类似操作系统中的文件管理器，只有放在项目文件夹的 assets 目录下的资源才会显示在这里。关于项目文件夹结构说明请参考 项目结构。 internal 中的是默认的内置资源（只读），内置资源可以复制，但不能进行增删改操作。可以作为资源模板拖拽到 assets 中，即新建了一个项目资源。 面板目前支持操作资源的快捷方式包括： 复制：Ctrl/Cmd + C 粘贴：Ctrl/Cmd + V 克隆：Ctrl/Cmd + D、Ctrl + 拖动资源 删除：Delete 上下选择：上箭头，下箭头 上一层级：左箭头 下一层级：右箭头 多选：Ctrl/Cmd + 点击 连续多选：Shift + 点击 全选：Ctrl/Cmd + A 重命名：Enter/F2 取消输入：Esc 创建资源 创建资源有两种方式： 点击 资源管理器 左上方的 + 按钮。 在 资源管理器 面板中点击鼠标右键，然后选择 创建。 注意：创建资源时会先出现一个 输入框 要求填入新资源的名称，名称不能为空。 创建资源时，可以在树形资源列表中选中要放置资源的文件夹，则新建的资源会创建到当前选中的文件夹目录下。若没有选中任何文件夹，则新建资源会默认创建到当前根目录下（assets）。 选择资源 在资源列表中可以使用以下的资源选择操作： 单击以选中单个资源。选中的资源会呈现 蓝底黄字 的高亮状态 双击以打开某个资源，比如 scene、script、image。双击文件夹则折叠/展开文件夹 按住 Ctrl/Cmd，然后选择资源，可以同时选中多个资源 按住 Shift，然后选择资源，可以连续选中多个资源 对于选中的资源，可以执行移动、删除等操作。 移动资源 选中资源后（可多选），按住鼠标拖拽可以将资源移动到其他位置。将要移动的资源拖拽到目标文件夹上时，会看到鼠标悬停的文件夹呈现黄字的高亮状态，并且在其周围有一个蓝色的方框。这时松开鼠标，就会将资源移动到高亮显示的文件夹目录下。 资源的移动还包括以下操作： 将 资源管理器 中的资源拖拽到 场景编辑器 或 层级管理器 面板可生成节点，目前支持拖拽 cc.Prefab、cc.Mesh、cc.SpriteFrame 资源。 从 系统的文件管理器 拖拽文件到 资源管理器 列表中，即可导入资源。 从 层级管理器 面板拖拽节点到 资源管理器 面板的某个文件夹中，可将节点保存为一个 cc.Prefab 资源，详见 预制资源（Prefab）。 排序资源 工具栏中的 排序方式包括 按名称排序 和 按类型排序。当前的排序方式会被记录，下次打开编辑器时会保持当前的排序方式。 折叠资源 折叠分为单一折叠或含子集的全部折叠： 工具栏 中的 全部折叠/展开 按钮作用于全局 单击一个父级资源（例如文件夹）的三角图标，可以展开或折叠它的子集。使用快捷键 Alt 并点击三角图标，可全部展开或折叠所有的子资源 资源当前的折叠状态会被记录，下次打开编辑器时会保持当前的折叠状态。 搜索资源 搜索功能是一种组合功能，可限定搜索类型并指定搜索字段，这两种都可以达到类型过滤的效果，根据选择的类型/字段，面板中会显示所有相应的资源。 限定搜索类型：可多选。类型为资源类型 assetType，不是后缀名称或 importer 名称。 指定搜索字段：搜索名称不区分大小写，包括以下几种搜索方式： 搜索名称或 UUID 搜索 UUID 搜索 URL 查找 UUID 的使用，例如： 若只想在某个父级资源（例如文件夹）中搜索，则右键点击并选择 在文件夹中查找，即可缩小搜索范围。 在搜索结果列表中选中资源，双击资源等同于在正常模式下的操作。清空搜索内容后，会重新定位到选中的资源。 大图预览 在 资源管理器 中选中资源，即可在 资源预览 面板中显示资源的缩略图。若选中资源所在的文件夹，即可显示文件夹下所有资源的缩略图，方便查看。 资源的右击菜单 选中具体的资源/文件夹后，点击鼠标右键，可以在弹出的菜单中对资源执行一系列操作： 创建：和 资源管理器 面板的 创建 按钮功能相同，会将资源添加到当前选中的文件夹下，如果当前选中的是资源文件，会将新增资源添加到和当前选中资源所在文件夹中。 复制/剪切/粘贴：将选中的资源（可多选）复制/剪切，然后粘贴到该文件夹下或者另外的文件夹下。 生成副本：生成和选中资源（可多选）完全相同的资源副本，生成的资源和选中的资源在同一层级中。 重命名：修改资源名称，详情请查看下文介绍。 删除：删除资源（资源可多选），也可以使用快捷键 Delete。资源删除后会保留在 系统的回收站 中，必要时可将其还原。 全选：选中同一层级中的所有资源。 在文件夹中查找：使用搜索功能时，只搜索该文件夹中的资源。 查找 UUID 的使用：通过资源的 UUID 来查找该资源被哪些资源所引用。 在浏览器中预览此场景：仅对场景资源有效。 在资源管理器（Windows）或 Finder（Mac）中显示：在操作系统的文件管理器窗口中打开该资源所在的文件夹。 重新导入资源：更新资源到项目的 ./library 文件夹，支持多选批量导入。 在 library 中显示：打开该资源在项目文件夹的 Library 中的位置，详情请阅读 项目结构。 UUID/URL/PATH：复制资源的 UUID/URL/PATH，并且在 控制台 面板中输出。 另外对于特定资源类型，双击资源可以进入该资源的编辑状态，如场景资源和脚本资源。 重命名资源 选中需要重命名的资源，然后点击右键，选择 重命名 即可修改资源名称，或者也可以直接使用快捷键 Enter 或者 F2。点击面板其他地方或者按快捷键 Esc 便可以取消此次重命名。 此外 TypeScript 脚本资源的初始名称会处理为它的 className，而 className 是不能重复的。 导出资源包 选中需要导出的资源并点击右键，然后选择 导出资源包，在弹出的 导出资源 面板中会自动列出当前选中的资源与其依赖的相关资源。如果不需要导出相关依赖资源，可以在 导出资源 面板左下角取消勾选 包含依赖资源。 确定要导出的资源后，点击 导出 按钮，会弹出文件存储对话框，用户需要指定一个文件夹位置和文件名，点击 存储，就会生成 文件名.zip 的压缩包文件，包含导出的全部资源。 注意：插件会自动把资源打成一个 zip 包，该 zip 包只适用于 导入资源包 插件使用。 导入资源包 选中并右键点击要导入资源的文件夹，或者右键点击 资源管理器 面板的 空白处，然后选择 导入资源包，在弹出的文件浏览对话框中选择由 导出资源包 导出的 zip 包。zip 包中的资源便会自动解析到弹出的 导入资源包 面板。 导入过程中也会让用户再次确认导入资源，这时候可以通过取消某些资源的勾选来去掉不需要导入的资源。 注意： 导入的 zip 包，仅支持由 Cocos Creator 3.0.0 及以上版本使用 导出资源包 导出的 zip 包。 不支持导入相同类名的脚本。 扩展资源管理器面板 目前支持的扩展包括 右击菜单 和 拖入识别，详情请参考 扩展资源管理器面板。 "},"editor/inspector/":{"url":"editor/inspector/","title":"属性检查器","keywords":"","body":"属性检查器 属性检查器 是我们查看并编辑当前选中节点、节点组件和资源的工作区域。在 场景编辑器 或者 层级管理器 选中节点，或者在 资源管理器 选中资源，就可以在 属性检查器 中显示并编辑属性。 面板总览 属性检查器 面板大致可以分为 工具栏 和 属性设置 两个部分。 工具栏 左上角的 两个箭头 是编辑历史记录，点击可前进/后退选中过的节点/资源。 右上角的 锁图标 按钮可锁定面板，固定当前编辑的对象，不让面板随新的选中项而变动。 属性设置 在 属性设置 区域可以设置节点属性、组件属性、资源属性等。 节点名称和激活开关 节点名称，和 层级管理器 中的节点显示名称一致。 节点激活复选框表示节点的激活状态。不勾选时，节点处于非激活状态，节点会被暂停渲染，包括节点的子节点都会被隐藏（置灰）。 节点属性 点击节点名称下方的 Node 可以将节点的属性折叠或展开。Node 右侧有帮助文档和节点设置按钮： 帮助文档按钮可以跳转到节点相关的官方文档 节点设置按钮可以重置节点属性、复制/粘贴节点的值，以及分别重置节点的 Position/Rotation/Scale 属性。 节点的变换属性包括 位置（Position）、旋转（Rotation） 和 缩放（Scale），修改节点的属性通常可以立刻在 场景编辑器 中看到节点的外观或位置变化。详情可参考 坐标系和变换 如果需要批量修改节点属性，可在 层级管理器 中按 Shift 键选中多个节点，然后在 属性检查器 中批量设置。节点属性的批量设置与资源类似，具体可参考文末的资源多选批量设置部分。 组件属性设置 组件开启复选框表示组件的开启状态。不勾选时，组件处于关闭状态，不会参与渲染。 在节点属性下方，会列出节点上挂载的所有组件和组件的属性。和节点属性一样，点击组件的名称就会切换该组件属性的折叠/展开状态。在节点上挂载了很多组件的情况下，可以通过折叠不常修改的组件属性来获得更大的工作区域。 组件名称的右侧有 帮助文档 和 组件设置 的按钮： 帮助文档按钮可以跳转到该组件相关的官方文档介绍页面 组件设置按钮可以对组件执行重置、删除、向上移动、向下移动、复制组件、粘贴组件的值、粘贴成为新组件等功能。 各个组件的属性及设置都是不同的，详情请参考相应的组件说明文档。 添加组件 点击 添加组件 按钮会出现组件列表，包含系统提供的组件和自定义脚本组件。添加组件的列表有一个搜索框，支持使用键盘的上下箭头切换，以及 Enter 确定选中，前提是需要开启 偏好设置 -> 实验室 中的 使用弹窗方式添加组件 功能。 开发者在 资源管理器 中的脚本，可直接拖拽到 属性检查器 面板生成一个脚本组件，或者通过 添加组件 -> 自定义脚本 添加。脚本组件的属性是由脚本声明的。不同类型的属性在 属性检查器 中有不同的控件外观和编辑方式。我们将在 声明属性 一节中详细介绍属性的定义方法。 属性类型 属性 是组件脚本中声明的公开的并可被序列化存储在场景和动画数据中的变量。通过 属性检查器 可以快捷地修改属性设置，达到不需要修改脚本就可以调整游戏数据和玩法的目的。 通常可以根据变量使用内存位置不同将属性分为 值类型 和 引用类型 两大类。 值类型属性 值类型 包括数字、字符串、布尔、枚举等简单的占用很少内存的变量类型： 数值（Number）：可以直接使用键盘输入，也可以按输入框旁边的上下箭头逐步增减属性值。 向量（Vec2）：向量的控件是两个数值输入组合在一起，并且输入框上会以 x、y 标识每个数值对应的子属性名。 字符串（String）：直接在文本框里用键盘输入字符串，字符串输入控件分为单行和多行两种，多行文本框可以按回车换行。 布尔（Boolean）：以复选框的形式来编辑，选中状态表示属性值为 true，非选中状态表示 false。 枚举（Enum）：以下拉菜单的形式编辑，点击枚举菜单，然后从弹出的菜单列表里选择一项，即可完成枚举值的修改。 颜色（Color）：点击颜色属性预览框，会弹 颜色取色器 窗口，在这个窗口里可以用鼠标直接点选需要的颜色，或在下面的 RGBA 颜色输入框中直接输入指定的颜色。点击 颜色取色器 窗口以外的任何位置会关闭窗口并以最后选定的颜色作为属性值。例如颜色取色器组件： 引用类型属性 引用类型 包括 object 对象，比如节点、组件或资源。可通过 拖拽节点或资源到属性栏中 或 弹出资源面板 的方式选择并赋值。 批量操作 当需要批量设置 同类型 资源属性时，可在 资源管理器 中按 Shift 键并选中多个资源，属性检查器 中便会显示选中的资源数量以及可编辑的资源属性。设置完成后点击右上方的 应用 按钮即可。 批量修改节点属性也是一样的。但如果 属性检查器 中的属性显示以下几种状态，表示该属性在选中的多个资源中的属性值不一致，可根据需要选择是否继续批量修改该属性： 勾选框显示 灰色 输入框显示 - 选择框显示 空白 注意： 目前 Material 资源不支持批量设置操作。 不同类型 的资源可同时选中，但是不支持批量设置属性，属性检查器 中只会显示当前同时选中了几个资源。 编辑 Prefab 节点属性 Prefab 节点在 属性检查器 顶部工具栏中的功能包括：取消关联、定位资源、从资源还原、更新到资源。具体内容请参考 预制资源（Prefab）。 注意：编辑资源时请注意一定要记得点击右上角的 绿色打勾 按钮保存。 "},"editor/console/":{"url":"editor/console/","title":"控制台","keywords":"","body":"控制台 控制台 输出编辑器或引擎信息，信息类型包括 log 日志、warn 警告 和 error 报错。不同类型的信息会以不同颜色显示。 console.log()：输出日志，灰色文字，通常用来显示正在进行的操作。 console.warn()：输出警告，黄色文字，用于提示开发者最好进行处理的异常情况，但不处理也不会影响运行。 console.error()：输出错误，红色文字，表示出现了严重错误，必须解决才能进行下一步操作或者运行游戏。 面板操作 顶部工具栏功能依次是： 清空当前控制台内的所有日志 输入文本模糊搜索 是否将输入文本转为正则进行搜索 选择要显示的日志类型 打开备份在磁盘里的日志文件，每次编辑器启动时会重置该文件数据。 参数设置 控制台的一些参数可在 偏好设置 -> 控制台 中配置，包括是否显示日期，调整文字大小。 自定义输出信息 为了方便定位文件、节点或资源，或者提供跳转到帮助文档的链接等，Cocos Creator 支持在编辑器主菜单的 开发者 -> 开发人员工具 中自定义输出到 控制台 的日志，目前支持输出以下内容： 根据 URL 跳转链接 根据 URL 显示图片 根据 URL 或 UUID 定位到 Asset 资源 根据 UUID 定位到 Node 节点 根据磁盘文件路径 path 定位到脚本文件 输出对应语言的文案 数据格式 根据输出内容的不同，输入的数据格式包括以下两种： {type[text](url)} {type(text | url | uuid | path)} 数据格式说明如下： 整体匹配 {} 中的字符； [text]：跳转链接的显示文本，选填； type：输出的信息类型，包括以下几种。填写时不区分大小写；若不填写则直接输出输入的内容，不带有数据格式。 link：外部跳转链接 image：显示图片 asset：定位到资源 node：定位到节点 i18n：多语言翻译 示例 打开编辑器主菜单中的 开发者 -> 开发人员工具，然后输入： console.log('Open {link[the help doc url](https://docs.cocos.com/creator/manual/en/editor/console/)}'); console.log('Locate {link[ the file in library](D:/cocos-creator/a/library/36/36b55a90-1547-4695-8105-abd89f8a0e5f.js)}'); console.log('Locate Node UUID {node(f6zHdGKiZDhqbDizUsp8mK)}'); console.warn('Locate Asset UUID {asset(17185449-5194-4d6c-83dc-1e785375acdb)}'); console.error('Locate Asset URL {asset(db://assets/animation.anim)}'); console.log('The URL is {asset[{asset(db://assets/animation.anim)}](db://assets/animation.anim)}'); console.log('Show image {image(https://forum.cocos.org/images/logo.png)}'); console.log('Translate: {i18n(console.description)}'); 可以在 控制台 中看到输出的日志： "},"editor/preferences/":{"url":"editor/preferences/","title":"偏好设置","keywords":"","body":"偏好设置 偏好设置 面板中提供了编辑器的个性化设置，点击编辑器主菜单栏中的 Cocos Creator -> 偏好设置 即可打开。 偏好设置 由几个不同的分页组成，包括 通用设置、外部程序、设备管理器、引擎管理器、资源数据库、控制台、属性检查器、预览、构建发布 和 实验室。修改设置之后 偏好设置 面板会自动保存修改。 通用设置 通用设置 分页主要是针对编辑器相关的一些基础信息进行配置，包括： 编辑器语言：可以选择中文或英文，修改语言设置后编辑器会自动切换语言，若有点地方没有切换，可刷新一下编辑器。 选择本机预览 IP 地址：用户可以在本机有多个 IP 地址的情况下，手动选择其中之一作为预览时的默认地址和二维码地址。这里会列出所有本机的 IP，编辑器默认自动挑选一个 IP。 预览服务器端口号：修改编辑器预览游戏时使用的端口号，修改完成后需要重启编辑器才能生效。 数值默认步长：用于设置 属性检查器 中通过步进按钮调整数值属性时的步长幅度。默认步长为 0.001。属性检查器 中的步进按钮包括以下两种： 当鼠标移动到数值属性输入框的右边时，会出现一组上下箭头，可以按照一定的步进幅度连续增加或减小数值。 当鼠标悬浮在数值属性的名称附近时，光标会变成 这样的形状，然后左右拖动鼠标，也可以按照一定的步进幅度连续增加或减小数值。 配色主题：设置编辑器的显示颜色，目前包括 creator 和 dark 两种。 外部程序 外部程序 分页用于设置构建发布到原生平台时所需的开发环境，以及配置一些第三方程序。当鼠标移动到具体的配置项时，左侧会显示一个灰色的圆形问号图标，点击该图标可设置将配置项应用于当前项目中或者应用于全局所有项目中。当设置为应用于当前项目时，灰色的图标会变成黄色。 WeChat 开发者工具：配置微信小游戏开发者工具，详情请参考 发布到微信小游戏。 Android NDK：设置 Android NDK 路径，详情请参考 安装配置原生开发环境。 Android SDK：设置 Android SDK 路径，详情请参考 安装配置原生开发环境。 默认脚本编辑器：可以选用任意外部文本编辑工具（例如 VS Code）的可执行文件，作为在 资源管理器 中双击脚本文件时的打开方式。可以点击输入框后面的 搜索图标 按钮选择偏好的文本编辑器的可执行文件。文件夹图标则用于打开已设置完成的文本编辑器的所在路径。 默认浏览器：用于选择编辑器预览时使用的浏览器，可点击输入框后面的 搜索图标 按钮指定一个浏览器的路径。 设备管理器 设备管理器 分页用于管理使用模拟器或者浏览器预览时的设备分辨率，支持在面板右侧手动添加/修改/删除自定义的设备分辨率。编辑器默认的设备分辨率不支持修改/删除。 引擎管理器 引擎管理器 分页用于自定义引擎时配置引擎路径。 使用内置 TypeScript 引擎：是否使用 Cocos Creator 安装路径下自带的 engine 路径作为 TypeScript 引擎路径。这个引擎用于编辑器里场景的渲染、内置组件的声明（也就是使用代码编辑器，如 VSCode 时的智能提示），以及场景在 Web 环境下的预览。 自定义 TypeScript 引擎路径：除了使用自带的 engine，也可以前往 engine 仓库（GitHub | Gitee）克隆或 fork 一份引擎到本地的任意位置进行定制，然后取消勾选 使用内置 TypeScript 引擎，并将 自定义 TypeScript 引擎路径 指定为定制好的引擎路径，就可以在编辑器中使用这份定制后的引擎了。 使用内置原生引擎：是否使用 Cocos Creator 安装路径下自带的 cocos2d-x 路径作为原生引擎路径。这个引擎用于构建发布时所有原生平台（iOS、 Android、Mac、Windows）的工程构建和编译。 自定义原生引擎路径：取消上一项 使用内置原生引擎 的选择后，就可以手动指定原生引擎路径了。注意这里使用的原生引擎必须从 engine-native（GitHub | Gitee）或该仓库的 fork 下载。 关于自定义引擎，具体内容可参考 引擎定制工作流程 资源数据库 资源数据库 分页用于设置 资源管理器 面板中的资源数据库的相关信息，包括 日志等级 和 忽略文件。 日志等级：用于设置 资源管理器 中的资源数据库输出到 控制台 的信息类型。目前包括 仅输出错误、仅输出错误和警告、输出错误、警告以及日志 和 输出所有信息 四种。 忽略文件（正则）：使用正则表达式，填入具体资源文件的路径，则该资源将会被忽略。 控制台 控制台 分页用于设置 控制台 面板输出的日志，包括 显示日期 和 文字大小。 显示日期：是否在 控制台 面板输出的日志前面显示日期。 文字大小：用于设置 控制台 面板输出的日志文字大小。 属性检查器 属性检查器 分页中的 离开编辑自动保存 功能用于设置 属性检查器 面板是否在属性编辑完成后自动保存修改。 预览 预览 分页主要用于在使用编辑器正上方的 预览 按钮时，可以设置的各种选项，但只对当前项目有效。 保存场景自动刷新预览：若勾选该项，则在编辑器中保存场景时，会自动刷新已经打开的预览页面，目前暂时不支持使用模拟器预览。 模拟器自动清除缓存：若勾选该项，则使用模拟器预览时会自动清除缓存。 模拟器是否开启调试面板：若勾选该项，则使用模拟器预览项目时将自动打开调试窗口。 模拟器是否等待调试面板开启：该项会在勾选了 模拟器是否开启调试面板 后生效，作用是暂停模拟器启动过程直至调试器连接完成，用于调试加载过程。 初始预览场景：指定预览时打开项目中的哪个场景，会列出项目中所有的场景。如果设置为 当前打开场景，则会运行当前正在 场景编辑器 中编辑的场景，此外也可以设置成一个固定的场景（比如项目总是需要从登录场景开始游戏）。 构建发布 构建发布 分页用于设置执行 构建发布 时相关的信息，包括 日志等级 和 缓存资源的序列化 JSON。 日志等级：用于设置在构建发布到某个平台时，输出到 控制台 的信息类型。目前包括 仅输出错误、仅输出错误和警告、输出错误、警告以及日志 和 输出所有信息 四种。 缓存资源的序列化 JSON：为了加快构建速度，减少重复反序列化未修改资源，在资源构建过程中将会缓存资源的序列化 JSON，这部分 JSON 会放置在项目的 temp/asset-db/assets/uuid/build 目录下，根据 debug 和 release 模式分为 debug.json 和 release.json 存放。 当存在缓存资源时构建将会直接取用，这部分缓存资源会在每次资源导入后重新更新，基本不需要关心。该选项默认勾选，但如果遇到了某些特殊需求，希望构建时不存储这部分序列化构建缓存资源，取消勾选该项即可。 实验室 实验室 分页中会不定期提供一些新的技术方案或实验性质的功能，可以通过开关选项来选择是否使用，大部分情况下默认开启。目前包括 开启地形功能、使用弹窗方式添加组件 和 开启烘焙功能 三种 开启地形功能：用于开启地形功能，详情可参考 地形系统。 注意：从 v3.0.1 开始，该选项移除，已默认开启。 使用弹窗方式添加组件：具体内容请参考下文介绍。 开启烘焙功能：用于开启烘焙功能，详情可参考 光照贴图。 使用弹窗方式添加组件 之前有很多用户反馈添加组件无法进行组件搜索，在遇到一些自定义脚本组件繁多的项目中，找到自己编写的脚本组件十分困难。 但是搜索相对于鼠标直接上移直接显示菜单而言会多一步操作，由于一些内部基础建设的关系，我们暂时无法提供鼠标直接上移并且可以搜索的功能。目前先提供使用搜索弹窗添加组件的功能，当然你可以关闭该选项回到最初的使用方式。 为了方便使用，我们还添加一些辅助设计： 打开弹窗时焦点将会在搜索框内，你可以直接搜索相关关键词而无需鼠标点击展开； 在搜索找到相关组件时，你可以直接使用键盘的 ↑ 和 ↓ 快捷键来快速地切换组件选项，按下 Enter 快捷键即可添加该组件。 注意事项 在未来的版本中，实验室 中的这些功能可能被合并，但也有可能出现破坏兼容性的修改，甚至可能会被取消。如果想在开发环境中使用这些功能，请务必严格测试，并保持关注新版本的更新公告。 我们欢迎用户开启试用这些功能，并且在 论坛 提供宝贵的反馈意见，让这些功能更适合自己的使用场景，为项目提供更强大的助力。 扩展偏好设置面板 Creator 支持在 偏好设置 右侧添加自定义功能页，详情请参考 扩展偏好设置。 "},"editor/project/":{"url":"editor/project/","title":"项目设置","keywords":"","body":"项目设置 项目设置 面板通过点击编辑器主菜单栏中的 项目 -> 项目设置 即可打开，主要用于设置特定项目的相关配置项。这些设置会保存在项目的 settings/packages 文件夹中。如果需要在不同开发者之间同步项目设置，请将 settings 目录加入到版本控制。 项目设置 由几个不同的分页组成，包括 Macro Config、功能裁剪、项目数据、Layers、物理、脚本 和 纹理压缩。修改设置之后 项目设置 面板会自动保存修改。 Macro Config（引擎宏配置） 引擎宏设置 提供了修改宏配置的快捷方式，配置的宏将会在预览、构建时生效，同时也会跟随自定义引擎的配置更新当前宏配置的默认值。 ENABLE_TILEDMAP_CULLING：是否开启 TiledMap 的自动裁减功能，默认开启。需要注意的是 TiledMap 如果设置了 skew 和 rotation 的话，建议手动关闭该项，否则会导致渲染出错。 TOUCH_TIMEOUT：用于甄别一个触点对象是否已经失效并且可以被移除的延时时长。开发者可通过修改这个值来获得想要的效果，默认值是 5000 毫秒。详情请参考 API 文档 TOUCH_TIMEOUT。 ENABLE_TRANSPARENT_CANVAS：用于设置 Canvas 背景是否支持 Alpha 通道，默认不开启支持。 若希望 Canvas 背景是透明的，并显示背后的其他 DOM 元素，便可开启该项。 若关闭该项，则会有更高的性能表现。 ENABLE_WEBGL_ANTIALIAS：用于设置在创建 WebGL Context 时是否开启抗锯齿选项，默认开启。 CLEANUP_IMAGE_CACHE：是否在将贴图上传至 GPU 之后删除原始图片缓存，删除之后图片将无法进行 动态合图。该项默认不开启。 ENABLE_MULTI_TOUCH：是否开启多点触摸，默认开启。 MAX_LABEL_CANVAS_POOL_SIZE：设置 Label 使用的 Canvas 对象池的最大数量，请根据项目同场景的 Label 数量进行调整。 更多关于引擎宏模块的具体信息与代码可以参考 Engine Macro（GitHub | Gitee）。 功能裁剪 功能裁剪 分页主要是针对发布游戏时引擎中使用的模块进行裁剪，达到减小发布版引擎包体的效果。列表中未选中的模块在打包、预览时将会被裁剪掉。建议打包后进行完整的测试，避免场景和脚本中使用到了被裁剪掉的模块。 项目数据 项目数据 分页主要用于设置默认 Canvas、渲染管线等，只对当前项目生效。 默认 Canvas 设置 默认 Canvas 设置包括 设计分辨率 和 适配屏幕宽度/高度，用于规定在新建场景或 Canvas 组件时，Canvas 中默认的设计分辨率数值，以及 Fit Height 和 Fit Width。详情请参考 多分辨率适配方案。 渲染管线 渲染管线用于控制场景的渲染流程，目前仅支持 builtin-forward（前向渲染管线），详情请参考 内置渲染管线。 Layers Layers 能让相机渲染部分场景，让灯光照亮部分场景。 可自定义 0 到 19 个 Layers，清空输入框则删除原先的设置。 后 12 个 Layers 是引擎内置的，不可修改。 目前使用到 Layer 的位置包括： Node 节点在 属性检查器 中的 Layer 属性。 Camera 节点在 属性检查器 中的 Visibility 属性，节点的 Layer 属性匹配相机的 Visibility 属性。只有当节点设置的 Layer 属性包含在相机的 Visibility 中时，节点才可以被相机看见。更多说明可以参考 Camera 组件。 物理 用于配置物理的各项参数，详情请参考 物理配置。 脚本 符合规范的类字段：当开启时，将使用 Define 语义实现类字段，否则，将使用 Set 语义实现类字段。 允许声明类字段：当开启时，在 TypeScript 脚本中将允许使用 declare 关键字来声明类字段。当字段以 declare 声明且未指定显式的初始化式时，将依照规范初始化为 undefined。 启用宽松模式：启用宽松模式进行脚本编译。 压缩纹理 在 Cocos Creator 3.0，压缩纹理修改为在 项目设置 中配置预设，然后在 属性检查器 中选择图片资源的预设方式。旧版本的项目在升级到 v3.0 后，编辑器会自动扫描项目中所有的压缩纹理配置情况，整理出几个预设，由于是自动扫描的，所以预设名称可能不匹配项目，可以自行在此处修改。 该分页主要用于添加压缩纹理预设配置，可添加多个，每个压缩纹理配置允许针对不同的平台制定配置细则。添加完成后，在 层级管理器 中选中图片资源，就可以在 属性检查器 中快速添加压缩纹理预设。同时也可以在该分页中直接修改预设来达到批量更新压缩纹理配置的使用需求。 目前配置压缩纹理支持以下平台： Web：包括 Web-Mobile 和 Web-Desktop 两个平台 iOS Mini Game: 包括目前 Creator 支持的所有小游戏平台，比如微信小游戏、华为快游戏等 Android 各平台对纹理压缩的支持情况，详情请参考 压缩纹理。 添加/删除纹理压缩预设 在上方的输入框中输入压缩纹理预设名称，点击 Enter 键或者右侧的加号按钮即可添加一个预设。另外两个按钮是用于导入/导出压缩纹理预设，详情请参考下文介绍。 添加完压缩纹理后，如需删除可以直接将鼠标移到预设名称上，点击右侧的删除按钮即可。 注意：面板中内置的 default 和 transparent 这两个预设不可修改/删除。 添加/删除纹理压缩格式 选择平台，然后点击 Add Format 按钮，选择需要的纹理格式，再配置好对应的质量等级即可，目前同类型的图片格式只能添加一次。 如需删除，将鼠标移至纹理格式上方，点击右侧的红色删除按钮即可。 修改压缩纹理预设名称 压缩纹理预设的名称仅仅是作为显示使用，在添加压缩纹理预设时，就会随机生成 UUID 作为该预设的 ID，因而直接修改预设名称并不会影响图片资源处对预设的引用。 导出/导入压缩纹理预设 压缩纹理配置页面允许导入/导出压缩纹理预设，以便更好地跨项目复用配置，也可以自行在外部编辑好压缩纹理预设再导入到编辑器。 大部分情况下直接导入导出即可，如果需要自行编写压缩纹理配置，请参考下方接口定义与范例： 接口定义： type IConfigGroups = Record; type ITextureCompressPlatform = 'miniGame' | 'web' | 'ios' | 'android' | 'pc'; type ITextureCompressType = | 'jpg' | 'png' | 'webp' | 'pvrtc_4bits_rgb' | 'pvrtc_4bits_rgba' | 'pvrtc_4bits_rgb_a' | 'pvrtc_2bits_rgb' | 'pvrtc_2bits_rgba' | 'pvrtc_2bits_rgb_a' | 'etc1_rgb' | 'etc1_rgb_a' | 'etc2_rgb' | 'etc2_rgba' | 'astc_4x4' | 'astc_5x5' | 'astc_6x6' | 'astc_8x8' | 'astc_10x5' | 'astc_10x10' | 'astc_12x12'; type IConfigGroupsInfo = Record interface ICompressPresetItem { name: string; options: IConfigGroups; } 示例参考： { \"default\": { \"name\": \"default\", \"options\": { \"miniGame\": { \"etc1_rgb\": \"fast\", \"pvrtc_4bits_rgb\": \"fast\" }, \"android\": { \"astc_8x8\": \"-medium\", \"etc1_rgb\": \"fast\" }, \"ios\": { \"astc_8x8\": \"-medium\", \"pvrtc_4bits_rgb\": \"fast\" }, \"web\": { \"astc_8x8\": \"-medium\", \"etc1_rgb\": \"fast\", \"pvrtc_4bits_rgb\": \"fast\" }, } }, \"transparent\": { \"name\": \"transparent\", \"options\": { \"miniGame\": { \"etc1_rgb_a\": \"fast\", \"pvrtc_4bits_rgb_a\": \"fast\" }, \"android\": { \"astc_8x8\": \"-medium\", \"etc1_rgb_a\": \"fast\" }, \"ios\": { \"astc_8x8\": \"-medium\", \"pvrtc_4bits_rgb_a\": \"fast\" }, \"web\": { \"astc_8x8\": \"-medium\", \"etc1_rgb_a\": \"fast\", \"pvrtc_4bits_rgb_a\": \"fast\" }, } } } 扩展项目设置面板 Creator 支持在 项目设置 右侧添加自定义功能页，详情请参考 扩展项目设置。 "},"editor/mainMenu/":{"url":"editor/mainMenu/","title":"主菜单","keywords":"","body":"主菜单 Cocos Creator 顶部的主菜单栏中包括 Cocos Creator、文件、编辑、节点、项目、面板、扩展、开发者 和 帮助 9 个菜单项，集成了 Cocos Creator 大部分的功能点。 关于 Cocos Creator 该项主要包括软件信息、设置、窗口控制等功能： 选项 说明 关于 Cocos Creator 显示 Cocos Creator 相关版本号以及版权信息 布局 设置编辑器界面布局，暂时只支持默认布局 偏好设置 打开 偏好设置 面板，对编辑器进行个性化设置 快捷键 打开快捷键设置面板，查看编辑器各面板或功能模块默认使用的快捷键，支持自定义 关闭窗口（Ctrl/Cmd + W） 关闭当前窗口 退出 关闭当前编辑器，并自动打开 Dashboard 文件 该项主要用于项目或场景的新建、打开、保存等操作，以及导入 Cocos Creator 2.x 项目。 选项 说明 新建项目 打开 Dashboard 的 项目 分页，以新建一个项目。若使用的 Dashboard 版本是 v1.0.19，则会打开 Dashboard 的 新建项目 分页 打开项目 打开 Dashboard 的 项目 分页 新建场景（Ctrl/Cmd + N） 关闭当前场景并创建一个新场景，新创建的场景需要手动保存才会添加到项目目录下 保存场景（Ctrl/Cmd + S） 保存当前正在编辑的场景，如果是使用 文件 -> 新建场景 创建的场景，在第一次保存时会弹出对话框，需要选择场景文件保存的位置并填写文件名，然后点击 保存 即可。场景文件以 .scene 作为扩展名 另存为（Ctrl/Cmd +Shift+ S） 生成当前场景文件的副本，并保存在项目中 导入 Cocos Creator 2.x 项目 v2.x 资源导入工具，支持旧项目资源完美导入，以及代码的辅助迁移。详情请参考 v3.0 升级指南 编辑 该项主要包括撤销、重做、复制和粘贴等常用编辑功能。 选项 说明 默认快捷键 撤销 撤销上一次对场景的修改 Ctrl/Cmd + Z 重做 恢复上一步骤的撤销动作 Ctrl/Cmd + Shift + Z 剪切 剪切当前选中的节点或字符到剪贴板 Ctrl/Cmd + X 复制 复制当前选中的节点或字符到剪贴板 Ctrl/Cmd + C 粘贴 将剪贴板中的内容粘贴到相应的位置 Ctrl/Cmd + V 全选 焦点在层级管理器内为选中同一层级中的所有节点，焦点在资源管理器则选中同一层级中的所有资源 Ctrl/Cmd + A 注意：节点的 复制、剪切 和 粘贴 请使用快捷键进行操作。 节点 该项包含调整视角、取消关联预制节点和创建节点等功能。 选项 说明 视角对齐（Ctrl/Cmd + Shift + F） 将当前选中节点移动到 场景编辑器 的视角中心 将视角和节点对齐 将 场景编辑器 中的视角设置为以当前选中节点为中心 取消关联当前的 Prefab 资源 用于将选中的预制节点转化成普通节点，详情请参考 Prefab 递归地取消关联当前的 Prefab 资源 用于将场景中包含嵌套的预制节点递归地转化为普通节点，详情请参考 Prefab 空节点 在场景中创建一个空节点，如果执行命令前场景中已经选中了节点，新建的节点会成为选中节点的子节点 3D 对象 Creator 提供了一些比较基础的静态模型控件以便使用，目前包括 立方体、圆柱体、球体、胶囊、圆锥体、圆环体、平面 和 四方形。若需要创建其他类型的模型，可参考 MeshRenderer 组件 2D 对象 在场景中创建 Creator 预设好的包含基础渲染组件的 2D 节点，目前包括 Graphics（绘图）、Label（文本）、Mask（遮罩）、ParticleSystem2D（粒子）、Sprite（精灵）、SpriteSplash（单色）和 TiledMap（地图），详细情况可参考 2D 渲染组件介绍 UI 组件 在场景中创建 Creator 预设好的包含基础 UI 组件的节点，目前包括 Button（按钮）、Widget（对齐挂件）、Layout（布局）、ScrollView（滚动视图）、EditBox（输入框）等节点在内的常用 UI 控件。更多 UI 组件介绍，可以查看 UI 基础组件 光线 在场景中创建 Creator 预设好的包含基础光源组件的节点，目前包括 平行光、球面光 和 聚光，详情请参考 光照 特效 在场景中创建 Creator 预设好的包含 粒子系统 组件的节点。更多特效组件可在 属性检查器 面板点击 添加组件 -> 特效 进行添加。 摄像机 在场景中创建 Creator 预设好的包含 Camera 组件的节点。具体的使用方式，详情请参考 Camera 组件 地形 在场景中创建 Creator 预设好的包含地形组件的节点。具体的使用方式，详情请参考 地形系统 项目 该项主要用于执行预览运行构建项目、项目配置和自定义构建等。 选项 说明 项目设置 打开 项目设置 面板，设置特定项目的相关配置项 光照贴图 打开 光照贴图 面板，配置生成光照贴图的烘焙参数 运行预览（Ctrl/Cmd + P） 点击该项即可在选择的浏览器/模拟器/预览窗口中预览项目效果，详情请参考 预览调试 刷新预览（Ctrl/Cmd + Shift + P） 刷新已经打开的预览窗口 生成预览模板 该项用于自定义想要的预览效果，详情请参考 自定义预览模板 构建发布（Ctrl/Cmd + Shift + B） 打开 构建发布 面板，将游戏打包发布到目标平台上 构建项目构建模板 该项用于定制项目的构建模板，详情请参考 自定义构建模板 新建构建扩展包 该项用于扩展构建流程，详情请参考文档 扩展构建流程 面板 该项主要用于打开编辑器中的各式面板。 选项 说明 默认快捷键 控制台 打开 控制台，用于查看输出的日志信息 Ctrl/Cmd + 0 场景编辑器 打开 场景编辑器 面板。用于选择和摆放场景图像、角色、特效、UI 等各类游戏元素 Ctrl/Cmd + 1 资源管理器 打开 资源管理器/资源预览 面板，用于访问/管理/查看项目资源，详情请参考 资源管理器 资源管理器为 Ctrl/Cmd + 2 属性检查器 打开 属性检查器 面板，用于查看并编辑当前选中节点、节点组件和资源的工作区域 Ctrl/Cmd + 3 层级管理器 打开 层级管理器 面板，该面板以树状列表的形式展示了场景中所有节点之间的层级关系 Ctrl/Cmd + 4 预览 打开 摄像机预览 面板，该面板展示的画面与在场景中选中对应 Camera 节点时，场景编辑器 右下角展示的画面一致。当调整场景时，摄像机预览面板中的画面也会实时同步 Ctrl/Cmd + 5 动画 可以打开 动画编辑器 面板或者 Joint Texture Layout（骨骼贴图布局） 面板，用于对帧动画或者骨骼动画进行编辑、查看等功能 动画编辑器为 Ctrl/Cmd + 6 节点预制库 打开节点预制库面板。该面板是一个非常简单直接的可视化控件仓库，开发者可以将这里列出的控件拖拽到 场景编辑器 或 层级管理器 中，快速完成预设控件的创建 Ctrl/Cmd + 7 服务 打开 服务 面板，该面板提供了一些优质的官方以及第三方服务，方便开发者获得更多引擎之外的扩展能力，让游戏开发工作变得更加简单 Ctrl/Cmd + 8 Cocos 小秘书 打开 Cocos 小秘书 面板，该面板与 Cocos Creator 编辑器紧密结合，⽆缝嵌⼊开发环境，⽆论开发者遇到任何问题，随时可以向官方技术人员发起交流。目前仅支持 Creator 中文版 扩展 该项主要包括扩展管理器、商城和创建扩展等，详情请参考 编辑器扩展 一章。 选项 说明 扩展管理器 打开 扩展管理器 面板，其中包括了编辑器内置扩展、项目目录及全局目录下安装的扩展，详情请参考 编辑器扩展 商城 点击该项即可进入 Cocos Creator 内置的 扩展商城，可供用户浏览、下载和自动安装官方或者第三方扩展和资源。同时用户也可以将自己开发的扩展插件、美术素材、音乐音效等资源提交到扩展商店以便分享或者售卖。详情请参考 提交资源到商店 创建扩展 该项用于在项目/全局目录下生成一个 扩展包，以便对编辑器进行功能扩展 开发者 该项主要包含脚本、引擎和调试工具等开发相关的菜单功能。 选项 说明 编译引擎（Ctrl/Cmd + F7） 编译自定义引擎，详情请参考 引擎定制工作流程 编译原生模拟器引擎 编译自定义原生引擎模拟器，详情请参考 定制原生模拟器引擎 消息调试工具 打开消息调试工具，用于调试编辑器内部运行时的 IPC 交互 Tester 编辑器内置扩展的测试工具，目前暂未开放全部功能 开关图形工具 开/关图形工具面板，用于调试场景渲染 消息列表 打开 消息管理器 面板，用于显示编辑器每个功能定义的公开消息及其说明 Export.d.ts 导出编辑器相关的 API 重新加载（Ctrl/Cmd + R） 重新加载编辑器界面 UI 组件 打开 UI 组件面板，该面板列举了编辑器内提供的预设 UI 组件的使用方式，详情请参考 UI 组件 VS Code Workflow VS Code 代码编辑器的工作环境相关功能，目前支持 添加 Chrome debug 配置 和 添加编译任务，详情请参考 配置代码编辑环境。 开关开发人员工具（Ctrl/Cmd + Shift + I） 开/关开发者工具窗口，用于编辑器界面扩展的开发。同时也可以自定义输出到 控制台 的日志，详情请参考 自定义输出消息 打开资源调试工具 打开资源调试面板，用于查看修改 asset-db 进程期间的日志消息 打开场景调试工具 打开场景调试面板，用于查看修改场景时的日志消息 打开构建调试工具 打开构建调试工具，用于查看在构建过程中产生的全部日志信息包括调用栈 帮助 选项 说明 使用手册 在默认浏览器打开 用户手册文档 API 文档 在默认浏览器打开 API 参考文档 论坛 在默认浏览器打开 Cocos Creator 论坛 更新日志 在默认浏览器打开 Cocos Creator 各版本的 更新日志 引擎仓库 在默认浏览器打开 TypeScript 引擎仓库 "},"editor/toolbar/":{"url":"editor/toolbar/","title":"工具栏","keywords":"","body":"工具栏 工具栏 位于编辑器主窗口的正上方，包含了七组控制按钮或信息，用来为特定面板提供编辑功能或方便我们实施开发工作流。 使用变换工具布置节点 场景编辑器 的核心功能就是以所见即所得的方式编辑和布置场景中的可见元素，主要通过主窗口工具栏左上角的一系列 变换工具 将场景中的节点按我们希望的方式布置。 变换工具 主要包括 移动、旋转、缩放、矩形变换 四种，将鼠标悬浮在任一变换工具上方时会显示相关的提示信息。 移动变换工具 移动变换工具 是打开编辑器时默认处于激活状态的变换工具，之后这个工具也可以通过点击位于主窗口左上角工具栏第一个按钮来激活，或者在编辑场景时按下快捷键 W，即可切换使用 移动变换工具。 选中任意节点，便能在 场景编辑器 中看到节点中心出现了由红绿蓝三个箭头和红绿蓝三个方块组成的移动控制手柄。 控制手柄 是指在特定编辑状态下，场景编辑器 中显示的可用鼠标进行交互操作的控制器。这些控制器只用来辅助编辑，不会在游戏运行时显示。 移动变换工具激活时： 按住红色/绿色/蓝色箭头拖拽鼠标，将分别在 X、Y、Z 轴方向上移动节点； 按住红色/绿色/蓝色方块拖拽鼠标，将分别在 Y-Z 平面、X-Z 平面、X-Y 平面上移动节点。 旋转变换工具 点击主窗口左上角工具栏第二个按钮，或在编辑场景时按下 E 快捷键，即可切换使用 旋转变换工具。 旋转变换工具的手柄由三个相互正交的红绿蓝圆环组成（2D 视图下由一个箭头和一个圆环组成）。按住红色/绿色/蓝色圆环任意一点拖拽鼠标时，节点将分别绕着 X、Y、Z 轴旋转。 当鼠标悬浮在任意圆环上时，圆环显示为黄色，点击即可选中圆环，同时还会显示一个黄色的箭头，表示当前节点是以哪个轴为中心进行旋转。拖拽圆环上任意一点即可旋转节点，放开鼠标之前，可以在控制手柄上看到旋转的角度大小。 缩放变换工具 点击主窗口左上角工具栏第三个按钮，或在编辑场景时按下 R 快捷键，即可切换使用 缩放变换工具。 缩放变换工具由三个头部是红绿蓝正方体的坐标轴以及中心一个灰色正方体组成。当鼠标悬浮在任一正方体上时，显示为黄色，点击即可选中并拖动： 按住红色/绿色/蓝色正方体拖拽鼠标，将分别在 X、Y、Z 轴方向上缩放节点； 按住灰色正方体拖拽鼠标，将同时在 X、Y、Z 轴方向上缩放节点。 矩形变换工具 点击主窗口左上角工具栏第四个按钮，或在编辑场景时按下 T 快捷键，即可切换使用 矩形变换工具。需要注意的是，矩形变换工具只适用于 UI 节点。 矩形变换工具由四个顶点控制点、四个边控制点、一个中心控制点组成。 矩形变换工具激活时： 拖拽控制手柄的任一顶点控制点，可以在保持对角顶点位置不变的情况下，同时修改 UI 节点的 Position 属性和 UITransform 组件中的 ContentSize 属性。 拖拽控制手柄的任一边控制点，可以在保持对边位置不变的情况下，修改 UI 节点的 Position（X 或 Y 属性）和 UITransform 组件中的 ContentSize 属性（width 或 height 属性）。 拖拽控制手柄的中心控制点，可以在 UI 节点的尺寸大小不变的情况下，同时修改 UI 节点的 Position 属性和 UITransform 组件中的 AnchorPoint（锚点）属性。 在 UI 元素的排版中，经常会需要使用 矩形变换工具 直接精确控制节点四条边的位置和长度。而对于必须保持原始图片宽高比的图像元素，通常不会使用矩形变换工具来调整尺寸。 Gizmo 基准点设置 变换工具基准点用于设置变换工具的位置以及控制手柄的方向。 变换工具位置： Pivot：变换工具将显示在 2D 对象 锚点（AnchorPoint）所在位置或 3D 对象的 世界坐标系 中 Center：变换工具将显示在节点的中心点位置。若同时选择多个节点，则显示在所有节点的中心位置 变换工具的控制手柄方向： Local：变换工具的控制手柄以节点的旋转方向为准，如下图： Global：变换工具中控制手柄的方向以世界坐标系为准，不受节点旋转的影响，如下图： 切换编辑模式 点击下图中的 3D/2D 按钮，即可将 场景编辑器 切换为 2D 编辑模式或 3D 编辑模式。详情请参考 场景编辑器 - 视图介绍。 运行预览游戏 该项用于预览项目的运行效果，详情请参考 项目预览调试。 手机端预览地址 这里显示运行 Cocos Creator 的桌面电脑的局域网地址，连接同一局域网的移动设备可以访问这个地址来预览和调试游戏。将鼠标悬浮在局域网地址上，会浮现一个二维码，通过扫描二维码的方式也可以访问这个地址来预览和调试游戏。 打开项目/编辑器目录 项目：打开项目所在的文件夹 编辑器：打开程序的安装路径 Cocos 小秘书 点击工具栏最右侧的 按钮，即可打开 Cocos 小秘书面板，用户遇到任何问题，随时可以通过小秘书与官方技术人员发起交流探讨。详情可查看 Cocos 小秘书。 注意：Cocos 小秘书目前仅支持中文版本，后续优化请关注版本公告。 "},"editor/editor-layout/":{"url":"editor/editor-layout/","title":"编辑器布局","keywords":"","body":"编辑器布局 编辑器布局是指 Cocos Creator 里各个面板的位置、大小和层叠情况。 选择主菜单里的 Cocos Creator -> 布局 菜单，目前只支持 默认布局。在默认布局的基础上，也可以继续对各个面板的位置和大小进行调节。对布局的修改会自动保存在全局目录下： Windows：%USERPROFILE%\\.CocosCreator\\editor\\window.json macOS：$HOME/.CocosCreator/editor/window.json 调整面板大小 将鼠标悬浮到两个面板之间的边界线上，看到鼠标指针变成 后，按下鼠标，可以看到边界线变成了黄色，就可以拖动鼠标来修改相邻两个面板的大小。 注意：部分面板设置了最小尺寸，当拖拽到最小尺寸限度后就无法再继续缩小面板了。 移动面板 点击面板的标签栏并拖拽，可以将面板整个移动到编辑器窗口中的任意位置。下图中红框表示可拖拽的标签栏区域，箭头表示拖拽方向： 移动面板的过程中，蓝色半透明的方框表示松开鼠标后，移动的面板将会被放置的位置。 层叠面板 除了移动面板位置，拖拽面板标签栏的时候还可以移动鼠标到另一个面板的标签栏区域： 在目标面板的标签栏出现红色竖线时松开鼠标，就能够将两个面板层叠在一起，同时只能显示一个面板： 层叠面板在屏幕分辨率不足，或排布使用率较低的面板时非常实用。层叠中的面板可以随时拖拽出来，恢复永远在最上的显示。 面板也支持弹出独立面板或者关闭面板操作，点击面板右上方的按钮即可。但需要注意的是 场景编辑器 面板不支持弹出/关闭。 "},"editor/preview/":{"url":"editor/preview/","title":"预览调试","keywords":"","body":"项目预览调试 在使用主要编辑器面板进行资源导入、场景搭建、组件配置、属性调整之后，我们可以通过预览和构建来看到游戏在 Web 或原生平台运行的效果了。 在编辑器中选择预览平台 在游戏开发过程中我们可以随时点击编辑器窗口正上方的 预览 按钮，来看到游戏运行的实际情况。 最左边的下拉菜单中可以选择预览的平台，目前支持使用 浏览器、预览窗口 和 模拟器 预览。 ：预览按钮，点击可运行预览 在 预览 按钮右侧可以选择预览的场景，下拉框中会列出项目中所有的场景，默认使用 当前场景。 ：刷新按钮，点击该按钮可刷新所有已打开的预览页面。如果想要在执行保存场景操作后自动刷新预览页面，在编辑器主菜单中选择 Cocos Creator -> 偏好设置 -> 预览，然后勾选 保存场景自动刷新预览 即可。 注意：必须双击打开场景才能预览游戏内容，在没有打开任何场景，或者新建了一个空场景的情况下预览是看不到任何内容的。 浏览器 选择使用 浏览器 预览后，点击旁边的 预览 按钮，会在默认桌面浏览器中直接运行游戏的网页版本。推荐使用谷歌浏览器（Chrome）作为开发过程中预览调试用的浏览器，因为谷歌浏览器（Chrome）的开发者工具是最为全面强大的。 浏览器预览界面的最上边有一系列控制按钮可以对预览效果进行控制： 最左边选择预览窗口的比例大小，来模拟在不同移动设备上的显示效果，可以在 Cocos Creator -> 偏好设置 -> 设备管理器 中手动添加设备分辨率。 Rotate：决定显示横屏还是竖屏 Debug Mode：可以选择脚本中哪些级别的日志会输出到浏览器控制台中 Show FPS：按钮可以选择是否在左下角显示每秒帧数和 Drawcall 数量等调试信息 FPS：限制最高每秒帧数 Pause：暂停游戏 Cocos Creator 3.0 支持自定义网页预览功能，详情请参考 网页预览定制工作流程。 浏览器兼容性 Cocos Creator 开发过程中测试的桌面浏览器包括：Chrome、Firefox（火狐） 和 QQ 浏览器，其他浏览器只要内核版本够高也可以正常使用，对部分浏览器来说请勿开启 IE 兼容模式。 移动设备上测试的浏览器包括：Safari（iOS）、Chrome（Android）、QQ 浏览器（Android） 和 UC 浏览器（Android）。 使用浏览器开发者工具进行调试 以谷歌浏览器为例，点击编辑器主菜单中的 开发者 -> 开发人员工具 便可打开开发者工具界面。在开发者工具中，我们可以查看运行日志、打断点进行调试、在调用堆栈中查看每一步各个变量的值、甚至进行资源加载和性能分析。 要学习使用开发者工具进行调试，请阅读 Chrome Dev Tools 使用指南，或其他浏览器的开发者工具帮助。 预览窗口 选择使用 预览窗口 预览后，会打开独立的游戏预览窗口。预览窗口 是内嵌于编辑器中的游戏视图功能，它可以不打开浏览器/模拟器即可在编辑器中运行游戏，这样做的优势在于运行后的游戏可以通过编辑器中的其它插件或 Gizmo 实时调整游戏中的模型以及游戏运行时的状态等，做到游戏运行时的\"所见即所得\"。 打开 预览窗口 后，可以看到在编辑器顶部的工具栏中多出了 播放/停止、暂停 和 步进 几个按钮： 播放/停止：用于切换游戏的运行/停止状态。 暂停：用于暂停运行中的游戏。 步进：使游戏以步进的方式运行，方便调试。 预览窗口 顶部工具栏中的按钮功能与浏览器的差不多，只不过自定义预览窗口的比例大小是通过设置为 Custom 后手动在弹出的窗口中配置的。 模拟器 选择使用 模拟器 预览后，会使用 Cocos Simulator（桌面模拟器）运行当前的游戏场景。使用模拟器运行游戏时，脚本中的日志信息（使用 cc.log 打印的内容）和报错信息会显示在 控制台 面板中。 使用 模拟器 预览时，支持自动打开调试窗口进行调试，可在 Cocos Creator -> 偏好设置 -> 预览 中设置，详情请参考 偏好设置 — 预览。 手机端预览 调试手机端的预览效果有以下方式： 使用 浏览器开发者工具的手机端预览模式 扫描预览二维码 将鼠标移动到编辑器工具栏左边的 IP 预览地址上，会显示一个预览的二维码，用手机扫描即可。 直接 在手机浏览器里输入预览地址 注意：手机需要和电脑在 同一网段。由于电脑的网络有可能有多个，如果编辑器预览 URL 的 IP 地址选择不正确，可以在主菜单栏的 Cocos Creator -> 偏好设置 -> 通用设置 -> 选择本机预览 IP 地址 中修改。 构建发布 预览和调试之后，如果您对您的游戏比较满意了，就可以通过主菜单的 项目/构建发布 打开 构建发布 面板，将游戏打包发布到目标平台上，包括 Web、iOS、Android、各类\"小游戏\"、PC 客户端等平台。详细的构建发布流程，请参考 跨平台发布游戏 一章的内容。 注意：使用 模拟器 运行游戏的效果，和最终发布到原生平台可能会有一定差别，对于任何重要的游戏功能，都请以构建发布后的版本来做最终的测试。 其他参考 预览流程简介与常见错误处理 "},"getting-started/support.html":{"url":"getting-started/support.html","title":"获取帮助和支持","keywords":"","body":"获取帮助和支持 更多教程 Cocos 引擎官方微信公众号 Cocos 引擎官方微信公众号，第一时间为您送上引擎动态、精品教程、达人专访等干货。 哔哩哔哩 — Cocos 官方 不定期直播、以及官方视频教程等持续更新中。 演示和范例项目 注意，所有 GitHub 上的演示和范例项目都会跟随版本进行更新，默认分支对应目前最新的 Cocos Creator 版本，老版本的项目会以 v0.7 这样的分支名区分，分支名会和相同版本的 Cocos Creator 对应，下载使用的时候请注意。 展示范例集合（GitHub | Gitee）：从基本组件的使用到渲染效果的展示，这个项目里包括了多个侧重功能不同的场景及多个游戏 Demo 供用户参考。 一步两步（GitHub | Gitee）：也就是 快速上手 文档里分步讲解制作的游戏。 物理测试范例（GitHub | Gitee）：包含了一些物理测试例和案例工程，如吞噬黑洞、简化小车、坠落小球等，介绍了一些基础的功能和使用方法，方便用户结合文档了解物理功能。 Simple-Games（GitHub | Gitee）：简单小游戏集合演示 Demo，用户可通过此案例学习完成一些简单并且常见的小游戏。 模块展示集合（GitHub | Gitee）：引擎各个功能的范例项目，基本涵盖了引擎的大部分功能模块，用户在使用功能时可参考此项目中的用法进行开发。 UI 展示 Demo（GitHub | Gitee）：各类 UI 组件组合使用的演示 Demo。 弹弹乐 3D（GitHub | Gitee）：用户可通过此项目制作弹弹球游戏。 快上车 3D（GitHub | Gitee）：基于物理的游戏制作 demo，用户可通过此项目制作快上车游戏。 适合新人的第三方工具和资源 代码编辑工具 VS Code：微软推出的轻量级文本编辑器，支持 Cocos Creator 代码提示和语法高亮 WebStorm 图集生产工具 TexturePacker Zwoptex 位图字体生产工具 Glyph Designer Hiero BMFont (Windows) 2D 骨骼动画工具 Spine Spriter DragonBones 粒子特效制作工具 Particle Designer Particle2dx：免费在线工具 其他游戏开发资源 Cocos Store：各类游戏美术资源、扩展工具 提交问题和反馈 除了本手册里提供的信息，您还可以随时通过下面的渠道获取信息或反馈问题给 Cocos Creator 开发团队： Cocos 论坛社区 Cocos 技术支持 或者参考 如何在 GitHub 上向 Creator 提交代码 来提交你的修改。 "},"getting-started/attention/":{"url":"getting-started/attention/","title":"注意事项","keywords":"","body":"注意事项 语法格式 Cocos Creator 3.0 不同于 Cocos Creator v2.x 的语法格式，Cocos Creator 3.0 已全面支持 ES6 和 TS，因此只支持 ES6 和 TS 的 class。此外，我们还支持了 TS 的语法提示。针对 Cocos Creator 支持 ES5 语法的 cc.Class 形式已不再支持，请各位开发者悉知。 "},"getting-started/first-game/":{"url":"getting-started/first-game/","title":"快速上手：制作第一个游戏","keywords":"","body":"快速上手：制作第一个游戏 Cocos Creator 编辑器的强大之处就是可以让开发者快速的制作游戏原型。 下面我们将跟随教程制作一款名叫 一步两步 的魔性小游戏。这款游戏考验玩家的反应能力，根据路况选择是要跳一步还是跳两步，“一步两步，一步两步，一步一步似爪牙似魔鬼的步伐”。 可以在 这里 体验一下游戏的完成形态。 新建项目 如果您还不了解如何获取和启动 Cocos Creator，请阅读 安装和启动 一节。 首先启动 Cocos Creator，然后新建一个名为 MindYourStep 的项目，如果不知道如何创建项目，请阅读 Hello World!。 新建项目后会看到如下的编辑器界面： 创建游戏场景 在 Cocos Creator 中，游戏场景（Scene） 是开发时组织游戏内容的中心，也是呈现给玩家所有游戏内容的载体。游戏场景中一般会包括以下内容： 场景物体 角色 UI 以组件形式附加在场景节点上的游戏逻辑脚本 当玩家运行游戏时，就会载入游戏场景，游戏场景加载后就会自动运行所包含组件的游戏脚本，实现各种各样开发者设置的逻辑功能。所以除了资源以外，游戏场景是一切内容创作的基础。现在，让我们来新建一个场景。 在 资源管理器 中点击选中 assets 目录，点击 资源管理器 左上角的加号按钮，选择文件夹，命名为 Scenes。 点击选中 Scenes 目录（下图把一些常用的文件夹都提前创建好了），点击鼠标右键，在弹出的菜单中选择 场景文件。 我们创建了一个名叫 New Scene 的场景文件，创建完成后场景文件 New Scene 的名称会处于编辑状态，将它重命名为 Main。 双击 Main，就会在 场景编辑器 和 层级管理器 中打开这个场景。 添加跑道 我们的主角需要在一个由方块（Block）组成的跑道上从屏幕左边向右边移动。我们使用编辑器自带的立方体（Cube）来组成道路。 在 层级管理器 中创建一个立方体（Cube），并命名为 Cube。 选中 Cube，按 Ctrl + D 复制出 3 个 Cube。 将 3 个 Cube 按以下坐标排列： 第一个节点位置（0，-1.5，0） 第二个节点位置（1，-1.5，0） 第三个节点位置（2，-1.5，0） 效果如下： 添加主角 创建主角节点 首先创建一个名为 Player 的空节点，然后在这个空节点下创建名为 Body 的主角模型节点，为了方便，我们采用编辑器自带的胶囊体模型做为主角模型。 分为两个节点的好处是，我们可以使用脚本控制 Player 节点来使主角进行水平方向移动，而在 Body 节点上做一些垂直方向上的动画（比如原地跳起后下落），两者叠加形成一个跳越动画。 然后将 Player 节点设置在（0，0，0）位置，使得它能站在第一个方块上。效果如下： 编写主角脚本 想要主角影响鼠标事件来进行移动，我们就需要编写自定义的脚本。如果您从没写过程序也不用担心，我们会在教程中提供所有需要的代码，只要复制粘贴到正确的位置就可以了，之后这部分工作可以找您的程序员小伙伴来解决。下面让我们开始创建驱动主角行动的脚本吧。 创建脚本 如果还没有创建 Scripts 文件夹，首先在 资源管理器 中右键点击 assets 文件夹，选择 新建 -> 文件夹，重命名为 Scripts。 右键点击 Scripts 文件夹，选择 新建 -> TypeScript，创建一个 TypeScript 脚本，有关 TypeScript 资料可以查看 TypeScript 官方网站。 将新建脚本的名字改为 PlayerController，双击这个脚本，打开代码编辑器（例如 VSCode）。 注意：Cocos Creator 中脚本名称就是组件的名称，这个命名是大小写敏感的！如果组件名称的大小写不正确，将无法正确通过名称使用组件！ 编写脚本代码 在打开的 PlayerController 脚本里已经有了预先设置好的一些代码块，如下所示： import { _decorator, Component } from 'cc'; const { ccclass, property } = _decorator; @ccclass(\"PlayerController\") export class PlayerController extends Component { /* class member could be defined like this */ // dummy = ''; /* use `property` decorator if your want the member to be serializable */ // @property // serializableDummy = 0; start () { // Your initialization goes here. } // update (deltaTime: number) { // // Your update function goes here. // } } 这些代码就是编写一个组件（脚本）所需的结构。其中，继承自 Component 的脚本称之为 组件（Component），它能够挂载到场景中的节点上，用于控制节点的行为，更详细的脚本信息可以查看 脚本。 我们在脚本 PlayerController 中添加对鼠标事件的监听，让 Player 动起来： import { _decorator, Component, Vec3, systemEvent, SystemEvent, EventMouse, Animation } from 'cc'; const { ccclass, property } = _decorator; @ccclass(\"PlayerController\") export class PlayerController extends Component { /* class member could be defined like this */ // dummy = ''; /* use `property` decorator if your want the member to be serializable */ // @property // serializableDummy = 0; // for fake tween // 是否接收到跳跃指令 private _startJump: boolean = false; // 跳跃步长 private _jumpStep: number = 0; // 当前跳跃时间 private _curJumpTime: number = 0; // 每次跳跃时常 private _jumpTime: number = 0.1; // 当前跳跃速度 private _curJumpSpeed: number = 0; // 当前角色位置 private _curPos: Vec3 = new Vec3(); // 每次跳跃过程中，当前帧移动位置差 private _deltaPos: Vec3 = new Vec3(0, 0, 0); // 角色目标位置 private _targetPos: Vec3 = new Vec3(); start () { // Your initialization goes here. systemEvent.on(SystemEvent.EventType.MOUSE_UP, this.onMouseUp, this); } onMouseUp(event: EventMouse) { if (event.getButton() === 0) { this.jumpByStep(1); } else if (event.getButton() === 2) { this.jumpByStep(2); } } jumpByStep(step: number) { if (this._startJump) { return; } this._startJump = true; this._jumpStep = step; this._curJumpTime = 0; this._curJumpSpeed = this._jumpStep / this._jumpTime; this.node.getPosition(this._curPos); Vec3.add(this._targetPos, this._curPos, new Vec3(this._jumpStep, 0, 0)); } update (deltaTime: number) { if (this._startJump) { this._curJumpTime += deltaTime; if (this._curJumpTime > this._jumpTime) { // end this.node.setPosition(this._targetPos); this._startJump = false; } else { // tween this.node.getPosition(this._curPos); this._deltaPos.x = this._curJumpSpeed * deltaTime; Vec3.add(this._curPos, this._curPos, this._deltaPos); this.node.setPosition(this._curPos); } } } } 现在我们可以把 PlayerController 组件添加到主角节点 Player 上。在 层级管理器 中选中 Player 节点，然后在 属性检查器 中点击 添加组件 按钮，选择 添加用户脚本组件 -> PlayerController，为主角节点添加 PlayerController 组件。 为了能在运行时看到物体，我们需要将场景中 Camera 的参数进行一些调整，Position 设置为（0，0，13），Color 设置为（50，90，255，255）： 然后点击工具栏中心位置的 Play 按钮： 在打开的网页中点击鼠标左键和右键，可以看到如下画面： 更多的预览功能，可以参考 项目预览调试 添加角色动画 从上面运行的结果可以看到单纯对 Player 进行水平方向的移动是十分呆板的，我们要让 Player 跳跃起来才比较有感觉，可以通过为 Player 添加垂直方向的动画来达到这个效果。有关 动画编辑器 的更多信息，请阅读 动画编辑器 选中场景中的 Body 节点，然后在编辑器下方的 动画编辑器 中添加 Animation 组件并创建 Clip，命名为 oneStep。 进入动画编辑模式，添加 position 属性轨道，并添加三个关键帧，position 值分别为（0，0，0）、（0，0.5，0）、（0，0，0）。 注意：退出动画编辑模式前记得要保存动画，否则做的动画就白费了。 我们还可以通过 资源管理器 来创建 Clip。创建一个名为 twoStep 的 Clip 并将它添加到 Body 的 Animation 上，这里为了录制方便调整了一下面板布局。 进入动画编辑模式，选择并编辑 twoStep 的 Clip，类似第 2 步，添加三个 position 的关键帧，分别为（0，0，0）、（0，1，0）、（0，0，0）。 在 PlayerController 组件中引用 动画组件，我们需要在代码中根据跳的步数不同来播放不同的动画。 首先需要在 PlayerController 组件中引用 Body 身上的 Animation。 @property({type: Animation}) public BodyAnim: Animation | null = null; 然后在 属性检查器 中将 Body 身上的 Animation 拖到这个变量上。 在跳跃的函数 jumpByStep 中加入动画播放的代码： if (this.BodyAnim) { if (step === 1) { this.BodyAnim.play('oneStep'); } else if (step === 2) { this.BodyAnim.play('twoStep'); } } 最后点击 Play 按钮，点击鼠标左键和右键，可以看到新的跳跃效果： 跑道升级 为了让游戏有更久的生命力，我们需要一个很长的跑道让 Player 在上面一直往右跑。在场景中复制一堆 Cube 并编辑位置来组成跑道显然不是一个明智的做法，我们可以通过脚本完成跑道的自动创建。 游戏管理器（GameManager） 一般游戏都会有一个管理器，主要负责整个游戏生命周期的管理，可以将跑道的动态创建代码放到这里。在场景中创建一个名为 GameManager 的节点，然后在 assets/Scripts 中创建一个名为 GameManager 的 TypeScript 脚本文件，并将它添加到 GameManager 节点上。 制作Prefab 对于需要重复生成的节点，我们可以将它保存成 Prefab（预制）资源，作为我们动态生成节点时使用的模板。 将生成跑道的基本元素 正方体（Cube） 制作成 Prefab，之后可以把场景中的三个 Cube 都删除了。 添加自动创建跑道代码 Player 需要一个很长的跑道，理想的方法是能动态增加跑道的长度，这样可以永无止境地跑下去，这里为了方便先生成一个固定长度的跑道，跑道长度可以自己定义。另外，我们可以在跑道上生成一些坑，当 Player 跳到坑上就 GameOver 了。 将 GameManager 脚本中的代码替换成以下代码： import { _decorator, Component, Prefab, instantiate, Node, CCInteger } from 'cc'; const { ccclass, property } = _decorator; // 赛道格子类型，坑（BT_NONE）或者实路（BT_STONE） enum BlockType { BT_NONE, BT_STONE, }; @ccclass(\"GameManager\") export class GameManager extends Component { // 赛道预制 @property({type: Prefab}) public cubePrfb: Prefab | null = null; // 赛道长度 @property public roadLength = 50; private _road: BlockType[] = []; start () { this.generateRoad(); } generateRoad() { // 防止游戏重新开始时，赛道还是旧的赛道 // 因此，需要移除旧赛道，清除旧赛道数据 this.node.removeAllChildren(); this._road = []; // 确保游戏运行时，人物一定站在实路上 this._road.push(BlockType.BT_STONE); // 确定好每一格赛道类型 for (let i = 1; i 将上面制作好的 Cube 的 prefab 拖到 GameManager 在 属性检查器 中的 CubePrfb 属性上。 在 GameManager 的 属性检查器 面板中可以通过修改 roadLength 的值来改变跑道的长度。 此时点击预览可以看到自动生成了跑道，不过因为 Camera 没有跟随 Player 移动，所以看不到后面的跑道，我们可以将场景中的 Camera 设置为 Player 的子节点。 这样 Camera 就会跟随 Player 的移动而移动，现在点击预览可以从头跑到尾地观察生成的跑道了。 增加开始菜单 开始菜单是游戏不可或缺的一部分，我们可以在这里加入游戏名称、游戏简介、制作人员等信息。 在 层级管理器 中添加一个 Button 节点并命名为 PlayButton。 可以看到在 层级管理器 中生成了一个 Canvas 节点，一个 PlayButton 节点和一个 Label 节点。因为 UI 组件需要在带有 Canvas 的父节点下才能显示，所以编辑器在发现没有 Canvas 节点时会自动创建一个。 然后将 Label 节点上 cc.Label 组件中的 String 属性从 Button 改为 Play。 在 Canvas 底下创建一个名为 StartMenu 的空节点，将 PlayButton 拖到它底下。我们可以通过点击工具栏上的 2D/3D 按钮切换到 2D 编辑视图下进行 UI 编辑操作，详细的描述请查阅 场景编辑。 在 StartMenu 下新建一个名为 BG 的 Sprite 节点作为背景框，调整它的位置到 PlayButton 的上方。 然后在 属性检查器 中将 cc.UITransform 组件的 ContentSize 设置为（200，200），同时将 资源管理器 中的 internal/default_ui/default_sprite_splash 拖拽到 SpriteFrame 属性框中。 在 层级管理器 的 StartMenu 节点下添加一个名为 Title 的 Label 节点用于开始菜单的标题。 在 属性检查器 中设置 Title 节点的属性，例如 Position、Color、String、FontSize 等。 根据需要增加操作的 Tips 节点，然后调整 PlayButton 的位置，一个简单的开始菜单就完成了 增加游戏状态逻辑 一般我们可以将游戏分为三个状态： 初始化（Init）：显示游戏菜单，初始化一些资源。 游戏进行中（Playing）：隐藏游戏菜单，玩家可以操作角色进行游戏。 结束（End）：游戏结束，显示结束菜单。 使用一个枚举（enum）类型来表示这几个状态。 enum GameState{ GS_INIT, GS_PLAYING, GS_END, }; 为了在游戏开始时不让用户操作角色，而在游戏进行时让用户操作角色，我们需要动态地开启和关闭角色对鼠标消息的监听。在 PlayerController 脚本中做如下修改： start () { // Your initialization goes here. // systemEvent.on(SystemEvent.EventType.MOUSE_UP, this.onMouseUp, this); } setInputActive(active: boolean) { if (active) { systemEvent.on(SystemEvent.EventType.MOUSE_UP, this.onMouseUp, this); } else { systemEvent.off(SystemEvent.EventType.MOUSE_UP, this.onMouseUp, this); } } 然后在 GameManager 脚本中引用 PlayerController 脚本： @property({type: PlayerController}) public playerCtrl: PlayerController | null = null; 完成后保存脚本，回到编辑器，将 层级管理器 中挂载了 PlayerController 脚本的 Player 节点拖拽到 GameManager 节点的 playerCtrl 属性框中。 同时，为了动态地开启/关闭开始菜单，还需要在 GameManager 脚本中引用 StartMenu 节点： @property({type: Node}) public startMenu: Node | null = null; 完成后保存脚本，回到编辑器，将 层级管理器 中的 StartMenu 节点拖拽到 GameManager 节点的 startMenu 属性框中。 增加状态切换代码 增加状态切换代码并修改 GameManger 脚本的初始化方法： start () { this.curState = GameState.GS_INIT; } init() { // 激活主界面 if (this.startMenu) { this.startMenu.active = true; } // 生成赛道 this.generateRoad(); if(this.playerCtrl){ // 禁止接收用户操作人物移动指令 this.playerCtrl.setInputActive(false); // 重置人物位置 this.playerCtrl.node.setPosition(Vec3.ZERO); } } set curState (value: GameState) { switch(value) { case GameState.GS_INIT: this.init(); break; case GameState.GS_PLAYING: if (this.startMenu) { this.startMenu.active = false; } // 设置 active 为 true 时会直接开始监听鼠标事件，此时鼠标抬起事件还未派发 // 会出现的现象就是，游戏开始的瞬间人物已经开始移动 // 因此，这里需要做延迟处理 setTimeout(() => { if (this.playerCtrl) { this.playerCtrl.setInputActive(true); } }, 0.1); break; case GameState.GS_END: break; } } 添加对 Play 按钮的事件监听 为了能在点击 Play 按钮后开始游戏，我们需要对按钮的点击事件做出响应。在 GameManager 脚本中加入响应按钮点击的代码，以便用户在点击按钮后进入游戏的 Playing 状态： onStartButtonClicked() { this.curState = GameState.GS_PLAYING; } 然后在 层级管理器 中选中 PlayButton 节点，在 属性检查器 的 cc.Button 组件中添加 ClickEvents 的响应函数，将 GameManager 节点拖拽到 cc.Node 属性框中： 现在预览场景就可以点击 Play 按钮开始游戏了。 添加游戏结束逻辑 目前游戏角色只是呆呆的往前跑，我们需要添加游戏规则，让它跑的更有挑战性。 角色每次跳跃结束都需要发出消息，并将自己当前所在的位置做为参数发出消息，在 PlayerController 脚本中记录自己跳了多少步： private _curMoveIndex = 0; // ... jumpByStep(step: number) { // ... this._curMoveIndex += step; } 并在每次跳跃结束发出消息： onOnceJumpEnd() { this.node.emit('JumpEnd', this._curMoveIndex); } 在 GameManager 脚本中监听角色跳跃结束事件，并根据规则判断输赢，增加失败和结束判断，如果跳到空方块或是超过了最大长度值都结束： checkResult(moveIndex: number) { if (moveIndex 监听角色跳跃消息，并调用判断函数： start () { this.curState = GameState.GS_INIT; // ?. 可选链写法 this.playerCtrl?.node.on('JumpEnd', this.onPlayerJumpEnd, this); } // ... onPlayerJumpEnd(moveIndex: number) { this.checkResult(moveIndex); } 此时预览，会发现重新开始游戏时会有判断出错的问题，这是由于重新开始时没有重置 PlayerController.ts 中的 _curMoveIndex 属性值导致的。所以我们需要在 PlayerController 脚本中增加一个 reset 函数： reset() { this._curMoveIndex = 0; } 然后在 GameManager 脚本的 init 函数中调用 reset 来重置 PlayerController.ts 中的 _curMoveIndex 属性。 init() { // ... this.playerCtrl.reset(); } 步数显示 我们可以将当前跳的步数显示在界面上，这样在跳跃过程中看着步数的不断增长会十分有成就感。 在 Canvas 下新建一个名为 Steps 的 Label 节点，调整位置、字体大小等属性。 在 GameManager 脚本中引用这个 Label： @property({type: Label}) public stepsLabel: Label | null = null; 保存脚本后回到编辑器，将 Steps 节点拖拽到 GameManager 在属性检查器中的 stepsLabel 属性框中： 将当前步数数据更新到 Steps 节点中。因为我们现在没有结束界面，游戏结束就跳回开始界面，所以在开始界面要看到上一次跳的步数，因此我们需要在进入 Playing 状态时，将步数重置为 0。 // GameManager.ts set curState (value: GameState) { switch(value) { case GameState.GS_INIT: this.init(); break; case GameState.GS_PLAYING: if (this.startMenu) { this.startMenu.active = false; } if (this.stepsLabel) { this.stepsLabel.string = '0'; // 将步数重置为0 } setTimeout(() => { // 直接设置 active 会直接开始监听鼠标事件，这里做了延迟处理 if (this.playerCtrl) { this.playerCtrl.setInputActive(true); } }, 0.1); break; case GameState.GS_END: break; } } 然后在响应角色跳跃的函数 onPlayerJumpEnd 中，将步数更新到 Label 控件上 onPlayerJumpEnd(moveIndex: number) { if (this.stepsLabel) { // 因为在最后一步可能出现步伐大的跳跃，但是此时无论跳跃是步伐大还是步伐小都不应该多增加分数 this.stepsLabel.string = '' + (moveIndex >= this.roadLength ? this.roadLength : moveIndex); } this.checkResult(moveIndex); } 光照和阴影 有光的地方就会有影子，光和影构成明暗交错的 3D 世界。接下来我们为角色加上简单的影子。 开启阴影 在 层级管理器 中点击最顶部的 Scene 节点，然后在 属性检查器 勾选 shadows 中的 Enabled，并修改 Distance 和 Normal 属性： 点击 Player 节点下的 Body 节点，将 cc.MeshRenderer 组件中的 ShadowCastingMode 设置为 ON。 此时在 场景编辑器 中会看到一个阴影面片，预览会发现看不到这个阴影，这是因为它在模型的正后方，被胶囊体盖住了。 调整光照 新建场景时默认会添加一个挂载了 cc.DirectionalLight 组件的 Main Light 节点，由这个平行光计算阴影。所以为了让阴影换个位置显示，我们可以调整这个平行光的方向。在 层级管理器 中点击选中 Main Light 节点，调整 Rotation 属性为（-10，17，0）。 点击预览可以看到影子效果： 添加主角模型 做为一个官方教程，用胶囊体当主角显的有点寒碜，所以我们花（低）重（预）金（算）制作了一个 Cocos 主角。 导入模型资源 从原始资源导入模型、材质、动画等资源不是本篇基础教程的重点，所以这边直接使用已经导入工程的资源。将 项目工程（GitHub | Gitee）中 assets 目录下的 cocos 文件夹拷贝到你自己工程的 assets 目录下。 添加到场景中 在 cocos 文件中已经包含了一个名为 Cocos 的 Prefab，将它拖拽到 层级管理器 中 Player 节点下的 Body 节点中，作为 Body 节点的子节点。 同时在 属性检查器 中移除原先的胶囊体模型： 此时会发现模型有些暗，可以在 Cocos 节点下加个聚光灯（Spotlight），以突出它锃光瓦亮的脑门。 添加跳跃动画 现在预览可以看到主角初始会有一个待机动画，但是跳跃时还是用这个待机动画会显得很不协调，所以我们可以在跳跃过程中将其换成跳跃的动画。在 PlayerController.ts 类中添加一个引用模型动画的变量： @property({type: SkeletalAnimation}) public CocosAnim: SkeletalAnimation|null = null; 同时，因为我们将主角从胶囊体换成了人物模型，可以弃用之前为胶囊体制作的动画，并注释相关代码： // @property({type: Animation}) // public BodyAnim: Animation|null = null; jumpByStep(step: number) { // ... // if (this.BodyAnim) { // if (step === 1) { // this.BodyAnim.play('oneStep'); // } else if (step === 2) { // this.BodyAnim.play('twoStep'); // } // } } 然后在 层级管理器 中将 Cocos 节点拖拽到 Player 节点的 CocosAnim 属性框中： 在 PlayerController 脚本的 jumpByStep 函数中播放跳跃动画： jumpByStep(step: number) { if (this._startJump) { return; } this._startJump = true; this._jumpStep = step; this._curJumpTime = 0; this._curJumpSpeed = this._jumpStep / this._jumpTime; this.node.getPosition(this._curPos); Vec3.add(this._targetPos, this._curPos, new Vec3(this._jumpStep, 0, 0)); if (this.CocosAnim) { this.CocosAnim.getState('cocos_anim_jump').speed = 3.5; // 跳跃动画时间比较长，这里加速播放 this.CocosAnim.play('cocos_anim_jump'); // 播放跳跃动画 } // if (this.BodyAnim) { // if (step === 1) { // this.BodyAnim.play('oneStep'); // } else if (step === 2) { // this.BodyAnim.play('twoStep'); // } // } this._curMoveIndex += step; } 在 PlayerController 脚本的 onOnceJumpEnd 函数中让主角变为待机状态，播放待机动画。 onOnceJumpEnd() { if (this.CocosAnim) { this.CocosAnim.play('cocos_anim_idle'); } this.node.emit('JumpEnd', this._curMoveIndex); } 预览效果如下： 最终代码 PlayerController.ts import { _decorator, Component, Vec3, systemEvent, SystemEvent, EventMouse, Animation, SkeletalAnimation } from 'cc'; const { ccclass, property } = _decorator; @ccclass(\"PlayerController\") export class PlayerController extends Component { @property({type: Animation}) public BodyAnim: Animation|null = null; @property({type: SkeletalAnimation}) public CocosAnim: SkeletalAnimation|null = null; // for fake tween private _startJump: boolean = false; private _jumpStep: number = 0; private _curJumpTime: number = 0; private _jumpTime: number = 0.3; private _curJumpSpeed: number = 0; private _curPos: Vec3 = new Vec3(); private _deltaPos: Vec3 = new Vec3(0, 0, 0); private _targetPos: Vec3 = new Vec3(); private _curMoveIndex = 0; start () { } reset() { this._curMoveIndex = 0; } setInputActive(active: boolean) { if (active) { systemEvent.on(SystemEvent.EventType.MOUSE_UP, this.onMouseUp, this); } else { systemEvent.off(SystemEvent.EventType.MOUSE_UP, this.onMouseUp, this); } } onMouseUp(event: EventMouse) { if (event.getButton() === 0) { this.jumpByStep(1); } else if (event.getButton() === 2) { this.jumpByStep(2); } } jumpByStep(step: number) { if (this._startJump) { return; } this._startJump = true; this._jumpStep = step; this._curJumpTime = 0; this._curJumpSpeed = this._jumpStep / this._jumpTime; this.node.getPosition(this._curPos); Vec3.add(this._targetPos, this._curPos, new Vec3(this._jumpStep, 0, 0)); if (this.CocosAnim) { this.CocosAnim.getState('cocos_anim_jump').speed = 3.5; //跳跃动画时间比较长，这里加速播放 this.CocosAnim.play('cocos_anim_jump'); //播放跳跃动画 } // if (this.BodyAnim) { // if (step === 1) { // this.BodyAnim.play('oneStep'); // } else if (step === 2) { // this.BodyAnim.play('twoStep'); // } // } this._curMoveIndex += step; } onOnceJumpEnd() { if (this.CocosAnim) { this.CocosAnim.play('cocos_anim_idle'); } this.node.emit('JumpEnd', this._curMoveIndex); } update (deltaTime: number) { if (this._startJump) { this._curJumpTime += deltaTime; if (this._curJumpTime > this._jumpTime) { // end this.node.setPosition(this._targetPos); this._startJump = false; this.onOnceJumpEnd(); } else { // tween this.node.getPosition(this._curPos); this._deltaPos.x = this._curJumpSpeed * deltaTime; Vec3.add(this._curPos, this._curPos, this._deltaPos); this.node.setPosition(this._curPos); } } } } GameManager.ts import { _decorator, Component, Prefab, instantiate, Node, Label, CCInteger, Vec3 } from 'cc'; import { PlayerController } from \"./PlayerController\"; const { ccclass, property } = _decorator; // 赛道格子类型，坑（BT_NONE）或者实路（BT_STONE） enum BlockType{ BT_NONE, BT_STONE, }; enum GameState{ GS_INIT, GS_PLAYING, GS_END, }; @ccclass(\"GameManager\") export class GameManager extends Component { // 赛道预制 @property({type: Prefab}) public cubePrfb: Prefab | null = null; // 赛道长度 @property public roadLength = 50; private _road: BlockType[] = []; // 主界面根节点 @property({type: Node}) public startMenu: Node | null = null; // 关联 Player 节点身上 PlayerController 组件 @property({type: PlayerController}) public playerCtrl: PlayerController | null = null; // 关联步长文本组件 @property({type: Label}) public stepsLabel: Label = null!; start () { this.curState = GameState.GS_INIT; this.playerCtrl.node.on('JumpEnd', this.onPlayerJumpEnd, this); } init() { // 激活主界面 if (this.startMenu) { this.startMenu.active = true; } // 生成赛道 this.generateRoad(); if(this.playerCtrl){ // 禁止接收用户操作人物移动指令 this.playerCtrl.setInputActive(false); // 重置人物位置 this.playerCtrl.node.setPosition(Vec3.ZERO); // 重置已经移动的步长数据 this.playerCtrl.reset(); } } set curState (value: GameState) { switch(value) { case GameState.GS_INIT: this.init(); break; case GameState.GS_PLAYING: this.startMenu.active = false; this.stepsLabel.string = '0'; // 将步数重置为0 // 设置 active 为 true 时会直接开始监听鼠标事件，此时鼠标抬起事件还未派发 // 会出现的现象就是，游戏开始的瞬间人物已经开始移动 // 因此，这里需要做延迟处理 setTimeout(() => { this.playerCtrl.setInputActive(true); }, 0.1); break; case GameState.GS_END: break; } } generateRoad() { // 防止游戏重新开始时，赛道还是旧的赛道 // 因此，需要移除旧赛道，清除旧赛道数据 this.node.removeAllChildren(); this._road = []; // 确保游戏运行时，人物一定站在实路上 this._road.push(BlockType.BT_STONE); // 确定好每一格赛道类型 for (let i = 1; i = this.roadLength ? this.roadLength : moveIndex); } // 检查当前下落道路的类型，获取结果 this.checkResult(moveIndex); } // update (deltaTime: number) { // // Your update function goes here. // } } 总结 恭喜您完成了用 Cocos Creator 制作的第一个游戏！在 GitHub | Gitee 可以下载完整的工程，希望这篇快速入门教程能帮助您了解 Cocos Creator 游戏开发流程中的基本概念和工作流程。如果您对编写和学习脚本编程不感兴趣，也可以直接从完成版的项目工程中把写好的脚本复制过来使用。 接下来您还可以继续完善游戏的各方各面，以下是一些推荐的改进方向： 为游戏增加难度，当角色在原地停留1秒就算失败 改为无限跑道，动态的删除已经跑过的跑道，延长后面的跑道。 增加游戏音效 为游戏增加结束菜单界面，统计玩家跳跃步数和所花的时间 用更漂亮的资源替换角色和跑道 可以增加一些可拾取物品来引导玩家“犯错” 添加一些粒子特效，例如角色运动时的拖尾、落地时的灰尘 为触屏设备加入两个操作按钮来代替鼠标左右键操作 此外如果希望将完成的游戏发布到服务器上分享给好友玩耍，可以阅读 发布工作流 一节的内容。 "},"release-notes/":{"url":"release-notes/","title":"升级指南","keywords":"","body":"升级指南 Cocos Creator 3.0 升级指南 v3.0 材质升级指南 资源分包升级指南 资源管理模块升级指南 "},"release-notes/upgrade-guide-v3.0.html":{"url":"release-notes/upgrade-guide-v3.0.html","title":"v3.0 升级指南","keywords":"","body":"Cocos Creator 3.0 升级指南 版本介绍 Cocos Creator 3.0 集成了原有 2D 和 3D 两套产品的所有功能，带来了诸多重大更新，将做为 Creator 之后的主力版本。同时 v3.0 还延续了 Cocos 在 2D 品类上轻量高效的优势，并且为 3D 重度游戏提供高效的开发体验。 对于 Cocos Creator 2.x 为了保障现有的 v2.4 项目平稳过渡，我们会将 v2.4 做为 LTS（长期支持）版本，提供后续 两年 的持续更新！在 2021 年，v2.4 将继续更新版本，提供缺陷修复和新的 Cocos Creator 小游戏平台支持，保障大家的项目成功上线。在 2022 年我们还将为开发者持续提供 v2.4 的关键问题修复，保障已上线的游戏平稳运营！因此： 现有的 v2.x 项目可以安心继续开发，无需强制升级到 v3.0。 新项目建议使用 v3.0 版本开发，我们会不断优化 v3.0 的开发体验和运行效率，支撑好 2D、3D 等不同品类的重度游戏顺利上线。 对于 Cocos Creator 3D 原有的 Cocos Creator 3D 做为 Creator 的分支版本，已经面向中国进行了长达一年的迭代，成功上线了 星空大决战、最强魔斗士 等重度项目！Cocos Creator 3.0 发布后，Cocos Creator 3D 也将包含在 v3.0 中，现有的 v1.2 项目都可直接升级，因此 Cocos Creator 3D 后续不会再发布独立版本。 Cocos Creator 3.0 使用了面向未来的全新引擎架构，将为引擎带来高性能、面向数据以及负载均衡的渲染器，并且无缝支持 Vulkan & Metal 多后端渲染，未来还会支持移动端 VR/AR 及部分主机平台。 关于 Cocos Creator 3.0 的详细介绍，请移步 官网更新说明。 如何迁移 Cocos Creator 2.x 项目 虽然 我们不建议开发中的项目，特别是即将上线的项目强升 v3.0，但是我们仍在 Cocos Creator 3.0 推出了 v2.x 资源导入工具。此工具支持旧项目资源完美导入，以及代码的辅助迁移。 资源导入 开发者只需要点击主菜单中的 文件 -> 导入 Cocos Creator 2.x 项目。 然后在弹出的文件浏览对话框中选择 v2.x 项目的根目录。 注意：旧项目推荐先升级到 v2.4.3 或以上版本，然后再导入到 v3.0，否则无法确保导入结果的正确性。 v2.x 项目中所有的资源便会自动呈现在弹出的 导入 Cocos Creator 2.x 项目 面板中，开发者可以再次确认要导入的资源，然后点击面板右下角的 导入 按钮完成导入。若开发者想要切换导入的 v2.x 项目，点击下图中的搜索图标按钮，即可重新选择项目。 面板左下角的 使用说明 按钮可跳转到导入项目插件的 GitHub 仓库，用于 更新导入插件 或者提交反馈。 代码迁移 当导入使用 JavaScript 进行开发的 v2.x 项目时，导入插件的代码辅助迁移功能会先将 JavaScript 转换成 TypeScript，再进行代码迁移。 例如，导入的 v2.x 项目 JavaScript 代码如下： // AudioController.js cc.Class({ extends: cc.Component, properties: { audioSource: { type: cc.AudioSource, default: null }, }, play: function () { this.audioSource.play(); }, pause: function () { this.audioSource.pause(); }, }); 由于各个项目代码的写法差异以及不同的复杂程度，目前导入插件对代码的迁移仅添加 组件类型声明、属性声明 和 函数声明，组件在场景中的引用都会得到 保留，并且函数内部的代码会以 注释 的形式迁移。 另外，v2.x 的原代码则会以注释的形式完整保留一份在迁移后代码的末尾，方便开发者手动转换时参考。 上述示例代码在经过导入插件的代码辅助迁移之后，结果如下所示： // AudioController.ts import { _decorator, Component, AudioSource } from 'cc'; const { ccclass, property } = _decorator; @ccclass('AudioController') export class AudioController extends Component { @property public audioSource:AudioSource = 'null'; play () { //this.audioSource.play(); } pause () { //this.audioSource.pause(); } } /** * 注意：已把原脚本注释，由于脚本变动过大，转换的时候可能有遗落，需要自行手动转换 */ // cc.Class({ // extends: cc.Component, // // properties: { // audioSource: { // type: cc.AudioSource, // default: null // }, // }, // // play: function () { // this.audioSource.play(); // }, // // pause: function () { // this.audioSource.pause(); // }, // // }); 注意： 如果是从 JavaScript 转换为 TypeScript 的。需要在 TypeScript 中声明 所有属性 并设置默认值。 如果 属性检查器 面板数据丢失，则需要检查属性类型是否与 v2.x 相同。 如果 JavaScript 代码使用外部类型，TypeScript 会提示：通过导入外部源文件或声明进行修复。 旧版本开发者快速上手 材质升级 在 v3.0 中我们持续改进了材质系统的设计和内置 Shader API，所以从 v2.x 升级到 v3.x 时，部分内容无法自动升级，还需要开发者手动进行调整，详情请参考 材质升级指南。 引擎 API 升级 针对 Cocos Creator 3D 1.2 用户 Cocos Creator 3.0 资源加载相关的 API 与 v2.4 一致，都对 loader 进行了重构，v1.2 用户可参考 v2.4 资源管理模块升级指南 进行升级。 组件类名更改 为了符合 v2.x 的 API 规范，Cocos Creator 3.0 将组件类名包含 Component 后缀这样的命名方式舍弃了，并做了数据的自动升级和代码的兼容。 不过建议开发者还是要在代码中搜索所有类似命名方式的使用，并尽快更改为无 Component 后缀的类名。可以使用下面正则表达式进行全局搜索（打开大小写敏感和正则匹配）： ([A-Z]\\w+)Component 针对 Cocos Creator 2.x 用户 节点上 UI 相关接口变更如下： 与坐标变换计算相关的接口（例如：size 和 anchor）变更如下： 需要先获取节点上的 UITransform 组件，再使用对应的接口，例如： const uiTrans = node.getComponent(UITransform)!; uiTrans.anchorX = 0.5; uiTrans.setContentSize(size); 其余接口变更如下： color：需要先获取节点上的渲染组件（例如：Sprite 组件），再使用对应的接口。 opacity：如果节点上有渲染组件，直接设置渲染组件的 color。如果没有渲染组件，则可以通过添加 UIOpacity 组件，并设置相关属性。 skew：该接口已被移除。 group：变更为 layer。 zIndex：变更为 UITransform 中的 priority。 CCSpriteFrame： 移除接口：copyWithZone、copy、clone 和 ensureLoadTexture。 变更接口： setFlipX 和 isFlipX -> flipUVX setFlipY 和 isFlipY -> flipUVY getTexture 和 setTexture -> texture（此处的类型是 Texture2D/RenderTexture）。 其余 get 和 set 对应的方法在 3.0 中都直接对应同名属性（例如：getOffset -> offset）。 CCTexture2D： 变更接口：genMipmaps -> mipmaps、initWithElement -> image。 initWithData 整个方法被移除，类似的使用是将原先要传入的 ArrayBufferView 数据，传给新建的 ImageAsset，然后再用 ImageAsset 传给新建的 Texture2D，从而获得一份图片资源。 cc.Action：相关接口全部移除。 物理： 2D 变更组件：cc.Collider -> Collider2D、cc.BoxCollider -> BoxCollider2D、cc.RigidBody -> RigidBody2D 等。 3D 变更组件：cc.Collider3D -> Collider、cc.BoxCollider3D -> BoxCollider、cc.RigidBody3D -> RigidBody 等。 tween： 变更接口：cc.repeatForever -> Tween.repeatForever、cc.reverseTime -> Tween.reverseTime、cc.show -> Tween.show 等。 动画： 变更接口：addClip -> createState、getClips -> clips、playAdditive -> crossFade、getAnimationState -> getState 等。 相机： 移除接口：findCamera、alignWithScreen、main、cameras、 zoomRatio 和 containsNode。 变更接口：backgroundColor -> clearColor、cullingMask -> visibility、depth -> clearDepth、getScreenToWorldPoint -> screenToWorld、getWorldToScreenPoint -> worldToScreen、getRay -> screenPointToRay 等。 音频： 变更接口：getLoop 和 setLoop -> loop、getVolume 和 setVolume -> volume、getCurrentTime 和 setCurrentTime -> currentTime、src -> clip。 材质： 所有相关改动都需要获得 MeshRenderer 或其子类身上的 材质实例 来完成。 移除接口：setBlend、setDepth、setStencilEnabled、setStencil、setCullMode 和 define，其中除了 define 是调用 recompileShaders 完成更新，其余的都是调用 overridePipelineStates 完成更新。 sys 下的平台变量变更如下： Cocos Creator 2.x Cocos Creator 3.0 BAIDU_GAME BAIDU_MINI_GAME VIVO_GAME VIVO_MINI_GAME OPPO_GAME OPPO_MINI_GAME HUAWEI_GAME HUAWEI_QUICK_GAME XIAOMI_GAME XIAOMI_QUICK_GAME JKW_GAME COCOSPLAY ALIPAY_GAME ALIPAY_MINI_GAME BYTEDANCE_GAME BYTEDANCE_MINI_GAME 全局变量 变更如下： Cocos Creator 2.x Cocos Creator 3.0 CC_BUILD BUILD CC_TEST TEST CC_EDITOR EDITOR CC_PREVIEW PREVIEW CC_DEV DEV CC_DEBUG DEBUG CC_JSB JSB CC_WECHATGAME WECHATGAME CC_RUNTIME RUNTIME_BASED CC_SUPPORT_JIT SUPPORT_JIT 动态加载资源： 在 v3.0 中使用 bundle.load 或 resources.load 动态加载 sprite-frame 或 texture 时，需要将路径指定到具体的子资源： // 加载 texture // v2.x resources.load('background', cc.Texture2D, () => {}); // v3.0 resources.load('background/texture', Texture2D, () => {}); // 加载 sprite frame // v2.x resources.load('background', cc.SpriteFrame, () => {}); // v3.0 resources.load('background/spriteFrame', SpriteFrame, () => {}); 编辑器升级 构建发布面板 Cocos Creator 3.0 中所有平台的构建都内置为插件，因此 构建发布 面板也与 v2.4 的不同，各平台独有的构建选项会单独放在一个可折叠的 section 控件内。 点击 构建 按钮后会跳转到 构建任务 面板，所有构建后的平台都会显示在这个面板中。可以在这个面板中修改构建后工程的构建选项再重新构建、可以查看构建日志、打开工程目录等。如果需要返回 构建发布 面板编译其他平台的话，点击 构建任务 面板左上方的 新建构建任务 按钮即可。 另外，构建时支持构建成文件分离的多模块结果，便于多模块并发加载、动态加载模块，并且微信引擎插件支持选择不同物理引擎后端。构建完成后生成的 settings.js 也改为 settings.json，并放置在 src 目录下，允许作为资源上传到服务器。 资源缩略图面板 在 资源管理器 中选中资源，即可在 资源预览 面板中显示资源的缩略图。若选中资源所在的文件夹，即可显示文件夹下所有资源的缩略图，方便查看。 动画编辑器升级 支持节点树面板中对节点的搜索与显示过滤 支持使用系统剪贴板复制粘贴节点上的所有动画数据（节点、轨道以及关键帧） 支持多选节点后批量添加属性轨道 优化关键帧选取和取消选取的操作体验（Ctrl + 鼠标点击选中关键帧可取消选中） 支持在动画编辑状态下继续编辑节点属性，包括粒子和模型材质属性等 项目设置面板更新 分成 Engine 管理器、项目设置、构建发布 三大部分。 物理碰撞组独立使用 PhysicsSystem.PhysicsGroup 类型，不再与 Node.Layers 共享分组配置： 压缩纹理配置 修改为在 项目设置 -> 构建发布 中配置预设。在 资源管理器 中选中图片资源，然后再在 属性检查器 中选择预设的方式。 旧项目升级后，编辑器会自动扫描项目内的所有压缩纹理配置情况，整理出几个预设。由于是自动扫描的，生成的名称可能不是想要的，可以自行在此处修改： 编辑器插件系统升级 Cocos Creator 3.0 拥有更加强大的插件系统，编辑器几乎所有功能模块都是以插件形式存在。你可以在扩展菜单中快速创建自己的插件，从而实现自己想要的效果。另外，Cocos Creator 3.0 还提供了扩展管理器，可以轻松管理所有扩展插件的运行和卸载。 构建目录差异 Cocos Creator 2.x 不同平台构建后生成的目录与 Cocos Creator 3.0 也有着一定程度上的差异。接下来我们以 v2.4.3 为例，和 v3.0 分别在 Web、原生和微信小游戏平台上进行对比。 Web 平台 v2.4.3 构建 Web Desktop 平台后生成的目录： v3.0 构建 Web Desktop 平台后生成的目录： 从以上两张图可以看出 Web 平台构建后生成的内容，v2.4.3 与 v3.0 大部分是相同的，不同之处包括以下几点： v3.0 将引擎相关的代码，例如核心模块、物理模块、插件脚本等都统一放到了 cocos-js 目录下，相比 v2.4.3 分散放在构建目录中看起来更加清晰。 v2.4.3 只有一个启动脚本 main.js，而 v3.0 则有以下两个启动脚本： index.js：用于做一些预处理工作 application.js：用于启动游戏 v2.4.3 中用于管理配置的 src/settings.js 在 v3.0 改为 src/settings.json。 v2.4.3 中的首屏图片 splash.png，在 v3.0 则默认存储在 settings.json 中。 v2.4.3 中的 style-desktop.css 和 style-mobile.css，在 v3.0 则合并为 style.css。 微信小游戏平台 v2.4.3 构建微信小游戏后生成的目录： v3.0 构建微信小游戏后生成的目录： 从以上两张图可以看出微信小游戏平台构建后生成的内容，v2.4.3 与 v3.0 大部分是相同的，不同之处包括以下几点： v3.0 将引擎相关的代码，例如核心模块、物理模块、插件脚本等都统一放到了 wechatgame/cocos-js 目录下。而 v2.4.3 则分散一部分放在 wechatgame 目录下，一部分放在 wechatgame/cocos 目录下。 v2.4.3 将小游戏的适配层代码都编译到 adapter-min.js 中，而 v3.0 则是将适配层代码全部以散文件的形式存储在 libs 目录下，没有进行编译。 v2.4.3 的启动脚本是 main.js，v3.0 的启动脚本则是 application.js。 v2.4.3 将所有动态代码的引用记录在了 ccRequire.js 中，而 v3.0 目前暂时没有这个功能。 v2.4.3 中用于管理配置的 src/settings.js 在 v3.0 改为 src/settings.json。 原生平台 v2.4.3 构建 Windows 平台后生成的发布包目录如下： v3.0 构建 Windows 平台后生成的发布包目录如下： 从以上两张图可以看出 Windows 平台构建后生成的发布包目录，v2.4.3 与 v3.0 差异较大： v2.4.3 的发布包名称是以 构建发布 面板中的 构建模板 命名的（例如 jsb-link），v3.0 则是以 当前构建的原生平台 命名的（例如 windows、Android）。 因为各个原生平台（例如 Android、Windows）构建后生成的底层 C++ 代码是完全一致的，所以在 v3.0，我们将 v2.4.3 存放在发布包目录 frameworks/runtime-src/Classes 中的底层 C++ 代码单独提取出来放在共享的项目目录下的 native/engine/common 文件夹中。这样在构建原生平台时，如果检测到已经存在该文件夹，这部分内容便不会再进行处理，加快构建速度。 v2.4.3 发布包目录中应用层相关的文件，在 v3.0 都统一合并到了 assets 目录中。 v2.4.3 应用层相关的文件包括： assets 目录（资源） jsb-adapter 目录（适配层代码） src 目录（引擎相关代码、插件脚本、配置管理脚本 settings.js 等） 相关配置文件（.cocos-project.json、cocos-project-template.json、project.json） 启动脚本（main.js） v3.0 assets 目录结构如下： v3.0 在合并的过程中也做了相应的调整和改动： 原 v2.4.3 全部放在发布包目录 src 目录下的引擎相关代码（例如核心模块、物理模块、插件脚本等），在 v3.0 都放到了发布包目录 assets/src/cocos-js 目录下。 原 v2.4.3 中用于管理配置的 src/settings.js，在 v3.0 改为 assets/src/settings.json。 v2.4.3 会将所有原生平台的构建工程都生成在发布包目录 frameworks/runtime-src 目录下： 而 v3.0 则是将构建工程生成在发布包目录 proj 目录下，且只生成当前构建平台的工程： 同时，v3.0 也做了代码和配置的分离，将一部分代码和配置放入源码管理，位于项目目录下的 native/engine/当前构建的平台名称 文件夹中（例如 native/engine/win32、native/engine/android）。开发者可以在这里集成 SDK 或者做二次开发，删除构建后生成的发布包目录（例如 build/windows）不会影响已经集成的 SDK。 一些编译时需要用到的资源，例如应用图标、应用启动脚本等，v2.4.3 是存储在构建工程中，而 v3.0 则是存储在项目目录的 native/engine/当前构建的平台名称 文件夹中。 升级常见问题（FAQ） 升级后项目脚本在 VS Code 打开时，绑定组件定义等操作出现报红现象 Cocos Creator 3.x 开启了 TypeScript 的严格模式，会对代码进行更严格的审查，排除开发过程中可能会出现的因为疏忽而导致的问题。 如果不想使用严格模式，可以在 Creator 顶部菜单栏的 项目 -> 项目设置 -> 脚本 中勾选 启用宽松模式。需要提醒的是，我们并不鼓励关闭严格模式，因为严格空值检查能够减少代码运行时的一些低级报错。 关于严格模式下的书写规范，可以参照官方案例 快上车 3D（GitHub | Gitee）。 Action 动作全都失效 因为 Cocos Creator 3.x 移除了 Action 动作系统，统一使用 Tween 缓动系统。 修改 2D 节点的 size 和 anchor 不生效 需要先获取节点上的 UITransform 组件，再使用对应的接口，例如： const uiTrans = node.getComponent(UITransform)!; uiTrans.anchorX = 0.5; uiTrans.setContentSize(size); 修改 2D 节点的 color 不生效 需要先获取节点上的渲染组件（例如 Sprite 组件），再使用对应的接口，例如： const uiColor = node.getComponent(Sprite)!; uiColor.color = color(255,255,255); 修改 2D 节点的 skew 不生效 从 v3.0 开始，skew 接口已经被移除。 无法获取分组，但 Creator 的项目设置面板中仍有分组设置（Layers） v2.x 的 group 分组管理从 v3.0 开始变更为 Layer，如下图所示。在 v2.x 中通过 node.group 获取到的是分组名，而在 v3.x 通过 node.layer 获取到的是 分组值，并且分组值是以 2 的指数幂设定。 User Layer 0 的 layer 值为：20 = 1。 User Layer 1 的 layer 值为：21 = 2。 User Layer 6 的 layer 值为：26 = 64。 通过 zIndex 设置同级节点失效 从 v3.0 开始 zIndex 接口已经被移除，若需要调整节点树的顺序请使用 priority 方法来替换使用。 通过 getComponent() 无法获取到节点上挂载的脚本 请查询对应脚本的类名，而不是脚本名，因为在 v3.x 中脚本组件是以脚本中定义的类名为准的，而不是脚本名。常出现因为大小写而导致脚本找不到的问题。详情请参考 创建脚本。 动态加载 resources 文件夹下的图片时提示找不到 图片设置为 sprite-frame、texture 或其他图片类型后，将会在 资源管理器 中生成一个对应类型的资源。但如果直接加载 testAssets/image，得到的类型将会是 ImageAsset，必须指定路径到具体的子资源。 例如一张设置为 sprite-frame 类型的图片在 resources 文件夹下的路径为 testAssets/image，那么要加载 SpriteFrame 应该这么写： resources.load(\"testAssets/image/spriteFrame\", SpriteFrame, (err, spriteFrame) => { this.node.getComponent(Sprite).spriteFrame = spriteFrame; }); 若加载的是 texture 类型的图片，则将 spriteFrame 修改为 texture 即可。 物体产生物理碰撞之后，原有的物理碰撞回调没有了 从 v3.0 开始，碰撞体回调需要在开始的时候进行注册，与原先 v2.x 会直接产生回调不同。因此开发者需要在物理回调的脚本中增加对回调函数的注册。例如： let collider = this.getComponent(Collider2D); if (collider) { // 只在两个碰撞体开始接触时被调用一次 collider.on(Contact2DType.BEGIN_CONTACT, this.onBeginContact, this); // 只在两个碰撞体结束接触时被调用一次 collider.on(Contact2DType.END_CONTACT, this.onEndContact, this); // 每次将要处理碰撞体接触逻辑时被调用 collider.on(Contact2DType.PRE_SOLVE, this.onPreSolve, this); // 每次处理完碰撞体接触逻辑时被调用 collider.on(Contact2DType.POST_SOLVE, this.onPostSolve, this); } }); 升级之后，物理碰撞分组不见了 目前导入插件还不支持物理碰撞矩阵，因此暂时需要开发者手动设置碰撞矩阵，可在 Creator 主菜单 项目 -> 项目设置 -> 物理 中重新设置。 音频系统的 audioEngine 接口失效，无法播放音频 从 v3.0 开始，移除了 audioEngine 接口，统一使用 AudioSource 组件来控制音频的播放。详情请参考 AudioSource 组件。 Button 按钮无法点击 排除代码和渲染层级问题，请查看 Button 节点的 Scale 属性中 Z 轴的值是否为 0，如果是，将其修改为 1 即可。 升级后对脚本进行修改，出现编辑器卡死的情况 检查升级后脚本中定义的组件类型的属性装饰器 property 是否未定义，如果未定义，则是由于导入插件太过于老旧导致的，请参考 插件升级 对导入插件进行更新升级。更新导入插件后，需要 重新进行项目升级。 升级后在脚本中修改节点的 Position 时，直接通过节点（例如 node.x）修改不生效 从 v3.0 开始，node 节点上不允许直接访问坐标位置，需要先访问 position 再访问坐标值。并且 v3.x 中的 position 为 只读属性，若需要修改，请使用 setPosition 方法。例如： // v2.x // 访问坐标轴 let xAxis = this.node.x; // 修改 X 轴坐标 this.node.x = 200; // v3.x // 访问坐标轴 let xAxis = this.node.position.x; // 修改 X 轴坐标 this.node.setPosition(200); TypeScript 参考教程 Cocos Creator 3.0 TypeScript 问题答疑及经验分享 TypeScript 官方网站 TypeScript - Classes TypeScript - Decorators TypeScript - DefinitelyTyped X 分钟速成 TypeScript TypeScript 源码 开发者回避使用 TypeScript 的三个借口 — 以及应当使用 TypeScript 的更有说服力的原因 "},"material-system/effect-2.x-to-3.0.html":{"url":"material-system/effect-2.x-to-3.0.html","title":"v3.0 材质升级指南","keywords":"","body":"Cocos Creator 3.0 材质升级指南 本文将详细介绍 Cocos Creator 2.x 的材质升级到 v3.0 的注意事项。 1. 材质系统基础设计简介 1.1 Cocos Creator 的材质系统框架 材质系统自上至下由四个核心类组成，分别是 Material、Effect、Technique 和 Pass，它们的关系可以通过下面的类图来理解： Material Material 资源可以看成是 EffectAsset 在场景中的资源实例，它本身的可配置参数有 effectAsset、technique、defines、states。 Effect 一个 Effect 资源代表一种材质类型，是材质系统中最重要的核心资源，如果希望在引擎中实现自定义的着色效果，需要书写自定义 Effect。 Technique 我们把完成一个最终效果的方案称为一个渲染技术 Technique，一个技术可由一个或多个 Pass 来融合完成。 Pass 一个 Pass 就是一次 GPU 绘制，一般包括一次顶点着色器和一次片元着色器，在 Creator 里 Pass 有很多可选配置参数。 1.2 Material 材质实例面板 Material 材质实例是所有开发者接触到的最直观的材质编辑窗口，所有实际材质实例的配置都是通过它完成的。 Cocos Creator 3.0 的 Material 实例面板如下： Cocos Creator 2.x 的 Material 实例面板如下： 由上面两图可以看出 v3.0 的实例面板相比 v2.4 的会复杂不少，一方面是由于材质配置复杂度有所增加，另一方面也是因为面板功能有所增强。 材质面板的可配置项主要分为五种类型 Effect 资源：下拉框会列出当前项目中所有的 Effect 资源，开发者可以选择当前材质使用的 Effect 资源。当切换了 Effect 后其他属性也会同步更新。 Technique 渲染技术选择：下拉框会列出当前使用的 Effect 资源中所有的 Technique，Effect 资源中可能会存在多个 Technique，每个 Technique 适用于不同的情况，比如效果差一点但是性能更好的 Technique 更适合用于手机平台。 Effect 中定义的宏选项：通过这些宏来控制某些代码是否可以被启用（对应逐个 Pass）。 Effect 中定义的属性列表（根据宏定义动态开放），并且使用不同的输入框适应不同类型的属性。编辑器的可编辑属性一般是 shader 中的某个 uniform 的映射，从 v3.0 开始也可以指定某个分量的映射（在 Effect 中使用 target 参数） 在 v3.0 还新增了 PipelineStates 选项，主要用于定义材质依赖的管线状态，比如 DepthStencilState、BlendState、CullMode 等。 1.3 编辑器体验 v2.x 与 v3.0 在材质系统的编辑器体验上也有一定的区别。 v3.0 在 层级管理器 中选中包含模型和材质的节点后，属性检查器 面板会显示各组件属性以及详细的 Material 配置面板： 而 v2.x 在 层级管理器 中选中包含模型和材质的节点后，属性检查器 面板只会显示各组件属性，并不会直接显示详细的 Material 配置面板： 而是需要跳转到 资源管理器 面板选中 Material 资源才可以在 属性检查器 中编辑： 2. Effect 资源 这个章节主要介绍资源在 v2.x 和 v3.0 的共性和差异。 2.1 Effect 格式和内容 Effect 资源方面，v2.x 和 v3.0 都是采用 YAML1.2 标准的语法和解析器，两个版本之间的差别不大。Effect 资源定义了一种材质类型，通过按照 语法格式 编写，可以定义以下信息： Technique 渲染技术列表 每个 Technique 的 pass 列表 每个 Pass 中所暴露给编辑器可编辑的属性列表（包含编辑器内的数据类型指定、分量映射关系等） 每个 Pass 的着色器程序，包含顶点和片元着色器程序 在语法细节方面，诸如 Property 声明和宏定义的方式都是一致的： 2.2 预设材质类型 v2.x 和 v3.0 在预设值材质方面有比较大的区别。 v2.x 的预设材质包括 2D Sprite、经典的 blinn-phong 光照材质、无光照 unlit 材质、默认的卡通 toon 材质、粒子材质等。 v3.0 的预设材质则是基于物理的渲染体系，包含基于物理光照的 standard PBR 材质、Skybox、toon 卡通渲染材质、3D 粒子材质（CPU & GPU）、粒子拖尾材质、传统的 2D Sprite 材质等。 v3.0 默认的 standard 材质支持标准的 Physically Based Rendering (PBR) 流程，其中包含很多提升材质质量和真实感的贴图信息，比如漫反射贴图、法线贴图、金属度（metallic）、粗糙度（roughness）、环境光遮蔽（occlusion）等等。整套算法基于标准的 BRDF 光照模型，这些是 v2.x 所不具备的，整体画面表现上 v3.0 也比 v2.x 要高一个档次。 2.3 Effect 书写细节差异 尽管 Cocos Creator 的 Effect 语法规则在 v2.x 和 v3.0 基本是一致的，但很多内置的头文件、变量名以及函数名还是有区别的。 以获取主方向光源的方向为例，在 v3.0 里是 cc_mainLitDir，同时要包含头文件 cc-global。而在 v2.x 中想要获取光源方向要用到 cc_lightDirection[i] 这样一个数组，同时要包含头文件 cc-lights。具体的差异可参考下方第三点 API 升级指南 部分的介绍。 一些默认的着色器函数是 v3.0 独有的，例如 CCStandardShading、CCToonShading 等，这些在 v2.x 上是没有的。同样可以参考下方第三点 API 升级指南 部分的介绍。 关于 uniform 声明方面，v3.0 强制使用 UBO 来组织，内存布局方面强制最小单位为 vec4，不再支持单独声明 float 或 vec3 等类型的 uniform。 在头文件方面，v3.0 的编辑器内置头文件资源就在 Internal DB 的 assets/chunks 目录下。引用时可以不加目录直接引用，主要包括一些常用的 工具函数 和 标准光照模型 等。而 v2.x 的头文件是内置在编辑器中，无法直观地了解具体有哪些。 2.4 新增 Pass 选项 v3.0 新增了一些新的 Pass 选项： PropertyIndex：指定这个 pass 的运行时 uniform 属性数据要和哪个 pass 保持一致，比如 forward add 等 pass 需要和 base pass 一致才能保证正确的渲染效果。一旦指定了此参数，材质面板上就不再会显示这个 pass 的任何属性。 embeddedMacros：指定在这个 pass 的 shader 基础上额外定义的常量宏。在多个 pass 的 shader 中只有宏定义不同时可使用此参数来复用 shader 资源。 详细的 Pass 参数请参考 参数列表。 3. API 升级指南 3.1 内置 Uniform 差异列表 如果要在 shader 中使用内置变量，则需要包含对应头文件。下表是常用功能 uniform 汇总表，有很多功能 v2.x 与 v3.0 是一样的，而有一些是有区别的。 v2.x Header & Name v3.0 Header & Name Type 用途 版本差异性 cc-local.chunk & cc_matWorld cc-local.chunk & cc_matWorld mat4 模型空间转世界空间矩阵 无差异 cc-local.chunk & cc_matWorldIT cc-local.chunk & cc_matWorldIT mat4 模型空间转世界空间逆转置矩阵 无差异 cc-global.chunk & cc_time cc-global.chunk & cc_time vec4 x：自开始以来的全球时间，以秒为单位y：当前帧的增量时间z：自开始以来的总帧数 无差异 cc-global.chunk & cc_screenSize cc-global.chunk & cc_screenSize vec4 xy：屏幕尺寸zw：屏幕尺寸倒数 无差异 cc-global.chunk & cc_screenScale cc-global.chunk & cc_screenScale vec4 xy：屏幕比例zw：逆屏幕比例 无差异 无 cc-global.chunk & cc_nativeSize vec4 xy：实际着色缓冲的尺寸zw：实际着色缓冲的尺寸倒数 v3.0 新功能，v2.x 没有 cc-global.chunk & cc_matView cc-global.chunk & cc_matView mat4 视图矩阵 无差异 cc-global.chunk & cc_matViewInv cc-global.chunk & cc_matViewInv mat4 视图逆矩阵 无差异 cc-global.chunk & cc_matProj cc-global.chunk & cc_matProj mat4 投影矩阵 无差异 cc-global.chunk & cc_matProjInv cc-global.chunk & cc_matProjInv mat4 投影逆矩阵 无差异 cc-global.chunk & cc_matViewProj cc-global.chunk & cc_matViewProj mat4 视图投影矩阵 无差异 cc-global.chunk & cc_matViewProjInv cc-global.chunk & cc_matViewProjInv mat4 视图投影逆矩阵 无差异 cc-global.chunk & cc_cameraPos cc-global.chunk & cc_cameraPos vec4 xyz：相机位置 无差异 无 cc-global.chunk & cc_exposure vec4 x：相机曝光y：相机曝光倒数z：是否启用 HDRw：HDR 转 LDR 缩放参数 v3.0 新功能，v2.x 没有 另外，v2.x 与 v3.0 在光源和阴影方面差异很大，v3.0 相比 v2.x 有了很大的提升。下表列出了一些常用的功能 uniform。 v2.x Header & Name v3.0 Header & Name Type 用途 版本差异性 cc-lights.chunk & cc_lightDirection[CC_MAX_LIGHTS] cc-global.chunk & cc_mainLitDir vec4 得到光源方向 v2.x：单个模型在 shader 中执行一次绘制受多少盏灯光影响，默认最大值为 1.0。如果要获取位置信息，填写 0 即可。例如 cc_lightDirection[0]v3.0：xyz：主方向光源方向 cc-lights.chunk & cc_lightColor[CC_MAX_LIGHTS] cc-global.chunk & cc_mainLitColor vec4 控制光的颜色强度 v2.x：光的 exp，就是光的 pow 强度。v3.0：xyz — 主方向光颜色；w — 主方向光强度 cc-lights.chunk & CC_CALC_LIGHTS cc-global.chunk & cc_ambientSky v2.x：宏定义v3.0：vec4 控制天空颜色强度 v2.x：这是一个宏，通过穿进去的 ambient 参数进行计算。而且还有函数重载，可以传入不同的参数。v3.0：xyz — 天空颜色；w — 亮度 无 cc-global.chunk & cc_ambientGround vec4 xyz：地面反射光颜色 v3.0 新功能，v2.x 没有 无 cc-environment.chunk & cc_environment samplerCube xyz：IBL 环境贴图 v3.0 新功能，v2.x 没有 3.2 Shader 内建函数和变量 在 v3.0，如果需要对接引擎动态合批和 instancing 流程，需要包含 cc-local-batch 头文件，通过 CCGetWorldMatrix 工具函数获取世界矩阵。 v3.0 新增着色函数 CCStandardShading 函数名 CCStandardShading 需要包含头文件 shading-standard.chunk，用于进行光照计算，构成 surface shader 流程。 #include #include void surf (out StandardSurface s) { // fill in your data here } vec4 frag () { StandardSurface s; surf(s); vec4 color = CCStandardShading(s); return CCFragOutput(color); } 在此框架下可方便地实现自己的 surface 输入，或其他 shading 算法。 注意：CCFragOutput 函数一般不需要自己实现，它只起到与渲染管线对接的作用。且对于含有光照计算的输出，因为计算结果已经在 HDR 范围，所以应该包含 output-standard 头文件而非 output。 CCToonShading 函数名 CCToonShading，需要包含头文件 shading-toon.chunk，进行卡通渲染的光影计算。 #include #include void surf (out ToonSurface s) { // fill in your data here } vec4 frag () { ToonSurface s; surf(s); vec4 color = CCToonShading(s); return CCFragOutput(color); } 3.3 光影计算相关函数 v2.x 与 v3.0 的光影计算有很大不同，主要包括以下两部分内容。 球面光 v2.x 中的 点光源 在 v3.0 调整为 球面光，有很多现成的功能，使用时需要加入头文件 cc-forward-light.chunk，常用功能 uniform 如下表所示： Name Type Info cc_sphereLitPos[MAX_LIGHTS] vec4 xyz：球面光位置 cc_sphereLitSizeRange[MAX_LIGHTS] vec4 x：球光尺寸y：球光范围 cc_sphereLitColor[MAX_LIGHTS] vec4 xyz：球光颜色w：球光强度 更多详细信息请参考 常用 shader 内置 Uniform。 聚光灯 v3.0 中的聚光灯有很多现成的功能，使用时需要加入头文件 cc-forward-light.chunk，常用功能 uniform 如下表所示： Name Type Info cc_spotLitPos[MAX_LIGHTS] vec4 xyz：聚光灯位置 cc_spotLitSizeRangeAngle[MAX_LIGHTS] vec4 x：聚光灯尺寸y：聚光灯范围z：聚光灯角度 cc_spotLitDir[MAX_LIGHTS] vec4 xyz：聚光灯方向 cc_spotLitColor[MAX_LIGHTS] vec4 xyz：聚光灯颜色w：聚光灯强度 更多详细信息请参考 常用 shader 内置 Uniform。 3.4 阴影部分 v2.x 与 v3.0 的阴影计算区别很大，v2.0 加入了头文件 shadow.chunk，而 v3.0 加入的是头文件 cc-shadow.chunk。 v2.0 头文件 shadow.chunk 的常用功能 uniform 和函数如下所示： Name Type Info cc_shadow_lightViewProjMatrix[CC_MAX_SHADOW_LIGHTS] mat4 在灯光坐标下绘制阴影贴图 cc_shadow_info[CC_MAX_SHADOW_LIGHTS] vec4 计算阴影偏移 Name（函数） Type Info getDepth float 返回深度值 shadowSimple float 阴影的硬采样会有锯齿问题 v3.0 头文件 cc-shadow.chunk 的常用功能 uniform 如下所示： Name Type Info cc_matLightPlaneProj mat4 平面阴影的变换矩阵 cc_shadowColor vec4 阴影颜色 ShadowPCF 软阴影 头文件 函数 v2.x：shadow.chunk shadowPCF3X3（3 * 3 采样）shadowPCF5X5（5 * 5 采样) v3.0：cc-shadow-map-fs.chunk CC_DIR_SHADOW_FACTOR：直接修改内存中阴影颜色的数值 "},"concepts/scene/":{"url":"concepts/scene/","title":"场景制作","keywords":"","body":"场景制作工作流程 场景是游戏中的环境因素的抽象集合，是创建游戏环境的局部单位，我们可以理解为游戏开发设计人员通过在编辑器中制作一个场景，来表现游戏中的一部分世界内容。 场景结构 Cocos Creator 通过节点树和节点组件系统实现了自由的场景结构。其中 Node 负责管理节点树的父子关系以及空间矩阵变换 Transform，这样可以轻松地在场景中管理和摆放所有的实体节点。 组件系统赋予了节点各种各样的高级功能，比如模型渲染（MeshRenderer 组件）、动画（Animation 组件）、光源（Light 组件）、地形（Terrain 组件）等。其中 3D 场景中的必要元素是 Camera 组件，Camera 组件代表的是游戏中的玩家视角，没有 Camera 就什么也看不见。因而在创建场景时，Creator 会默认创建一个挂载了 Camera 组件的节点。 场景制作相关工作流程 场景资源 节点和组件 坐标系和节点属性变换 节点层级和显示顺序 使用场景编辑器搭建场景 天空盒 全局雾 阴影 "},"asset/scene.html":{"url":"asset/scene.html","title":"场景资源","keywords":"","body":"场景资源 在 Cocos Creator 3.0 中，游戏场景（Scene）是游戏开发时组织游戏内容的中心，也是呈现给玩家所有游戏内容的载体。而场景文件本身也作为游戏资源存在，并保存了游戏的大部分信息，也是创作的基础。 注意：请尽量避免多人同时修改同一个场景资源，否则可能会导致冲突，且无法通过 git 合并解决冲突。 创建场景 创建场景目前有以下几种方式： 在 资源管理器 中右键点击想要放置场景文件的文件夹，然后选择 创建 -> Scene 即可。为了使项目具备良好的文件夹目录结构，强烈建议使用该方法创建场景。 在 资源管理器 中点击左上角的 + 创建按钮，然后选择 Scene 即可。 在顶部菜单栏中选择 文件 -> 新建场景，即可在 场景编辑器 中直接创建一个新场景。但 资源管理器 中不会出现新场景文件，需要在保存场景时弹出的 保存场景 窗口中手动保存场景文件，保存完成后才会在 资源管理器 的根目录下出现 scene.scene 场景文件。 保存场景 方法一：使用快捷键 Ctrl + S（Windows）或 Command + S（MacOS）来快速保存场景。 方法二：在顶部菜单栏中选择 文件 -> 保存场景。 切换场景 在 资源管理器 中，通过双击场景文件打开场景。 如果需要在游戏过程中切换场景，可通过 director.loadScene 等 API 来实现游戏中动态场景加载及切换。 场景属性 双击打开场景文件后，可以看到 层级管理器 中的 scene 是场景节点树的根节点。选中 scene 节点，在 属性检查器 中可设置场景是否自动释放，以及整个场景相关的属性，包括环境光设置，阴影设置、全局雾和天空盒设置。 场景资源的自动释放，详情请参考下文 场景资源自动释放策略 部分的内容。 各类属性的详细说明请参考： 环境光 阴影 全局雾 天空盒 场景资源自动释放策略 如果项目中的场景很多，随着新场景的切换，内存占用就会不断上升。除了使用 assetManager.releaseAsset 等 API 来精确释放不使用的资源，我们还可以使用场景的自动释放功能。 双击打开场景文件后，在 层级管理器 选中 scene 节点，即可在 属性检查器 中设置场景是否自动释放： 从当前场景切换到下一个场景时，如果当前场景不自动释放资源，则该场景中直接或间接引用到的所有资源（脚本动态加载的不算），默认 都不主动释放。反之如果启用了自动释放，则这些引用到的资源 默认 都会自动释放。 防止特定资源被自动释放 启用了某个场景的资源自动释放后，如果在脚本中保存了对该场景的资源的“特殊引用”，则当场景切换后，由于资源已经被释放，这些引用可能会变成非法的，有可能引起渲染异常等问题。为了让这部分资源在场景切换时不被释放，我们可以使用 Asset.addRef 增加引用计数来锁住这些资源。 “特殊引用”：以全局变量、单例、闭包、“动态资源”等形式进行的引用。 “动态资源”：在脚本中动态创建或动态修改的资源。 以上关于场景资源自动释放部分的内容可以归纳为下图中的几种情况： 关于资源释放，详细请查看 资源释放。 "},"concepts/scene/node-component.html":{"url":"concepts/scene/node-component.html","title":"节点和组件","keywords":"","body":"节点和组件 Cocos Creator 3.0 的工作流程是以组件式开发为核心的，组件式架构也称作 实体 — 组件架构（Entity-Component System），简单来说，就是以组合而非继承的方式进行游戏中各种元素的构建。 在 Cocos Creator 3.0 中，节点（Node） 是承载组件的实体，我们通过将具有各种功能的 组件（Component） 挂载到节点上，来让节点具有各式各样的表现和功能。接下来我们看看如何在场景中创建节点和添加组件。 节点 节点是场景的基础组成单位。节点之间是树状的组织关系，每个节点可以有多个子节点： 节点具有以下特性： 节点包含一组基础属性（位移、旋转、缩放），节点之间通过一组相对变换关系组织在一起，详情可参考 坐标系和变换。 节点间的更新顺序是逐级更新的。子节点的更新依赖于父节点，子节点跟随父节点变换 节点上可以添加组件，将多个组件与节点关联在一起 创建节点（Node） 要最快速地获得一个具有特定功能的节点，可以通过 层级管理器 左上角的 创建节点 按钮。我们以创建一个最简单的 Sphere（球体）节点为例，点击左上角的 + 创建节点按钮，然后选择 创建 3D 对象 -> 创建 Sphere 球体： 之后我们就可以在 场景编辑器 和 层级管理器 中看到新添加的 Sphere 节点了。新节点命名默认为 Sphere，表示这是一个主要由 Sphere 组件负责提供功能的节点。您也可以尝试再次点击 创建节点 按钮，选择其他的节点类型，可以看到它们的命名和表现会有所不同。需要注意的是：创建 UI 节点时会自动创建一个 Canvas 节点作为 UI 节点的根节点，具体内容可参考文档 UI 结构说明。 更多关于节点在层级管理器中的单选、多选、复制、删除等操作，可参考 层级管理器。 若要在脚本中动态创建节点，可参考文档 创建和销毁节点。 组件 我们刚刚创建了节点，现在我们来看看什么是组件，以及组件和节点的关系。 选中我们刚才创建的 Sphere 节点，可以看到 属性检查器 中的显示： 属性检查器 中以 Node 标题开始的部分就是节点的属性，节点属性包括了节点的位置、旋转、缩放等变换信息。我们将在 坐标系和节点属性变换 部分进行详细介绍。 接下来以 cc.MeshRenderer 标题开始的部分就是 Sphere 上挂载的 MeshRenderer 组件的属性。在 Creator 中，MeshRenderer 组件用于渲染静态的 3D 模型，其中的 Mesh 属性用于指定渲染所用的网格资源。因为我们刚刚创建的是 Sphere 节点，所以这里默认是 sphere.mesh。 而 Materials 属性用于指定渲染所用的 材质资源，你可以尝试从 资源管理器 中拖拽任意一个材质到 属性检查器 的 Materials 属性中，可以看到刚才默认的材质变成了指定的材质。 组件上设置好的任何资源，比如这里的 sphere.mesh，都会在场景加载时自动同时加载好。你也可以在自定义的组件中声明需要设置和自动加载的资源类型，详见 获取和加载资源。 除了在编辑器中手动添加组件，还可以通过脚本来控制组件，详情请参考 组件的创建和销毁。 节点属性对组件的影响 节点和 MeshRenderer 组件进行组合之后，就可以通过修改节点属性来控制对网格资源的渲染，您可以按照下图中红线标记属性的设置对您的节点进行调整，可以看到模型的旋转和缩放都发生了变化。 调整前： 调整后： 我们前面提到了组件式的结构是以组合方式来实现功能的扩展，节点和 MeshRenderer 组件的组合如下图所示： 添加其他组件 在一个节点上可以添加多个组件，来为节点添加更多功能。举个例子： 我们可以在上面的例子中继续选中 Sphere 这个节点，然后点击 属性检查器 最下方的 添加组件 按钮，选择 Light -> DirectionalLight 来添加一个 平行光 组件。 之后对 平行光 组件的属性进行设置，例如将平行光的 Color 属性调整为红色，可以看到球体模型的颜色发生了变化，也就是我们为节点添加的 DirectionalLight 组件生效了！ 这里只是简单举个效果较为明显的例子，使用中并不建议在 sphere 节点上添加 DirectionalLight 组件。 设置节点的可见性 引擎采用更加通用的节点，和相机相匹配。当节点设置的 Layer 属性包含在相机的 Visibility 属性 中时，节点便可以被相机看见，同时支持 3D 组件与 2D 组件的混合渲染。以便更灵活地控制节点组件的可见性，使分组显示多样化。 设置节点的 Layer 属性 节点的 Layer 属性是全局且唯一的，但是不同的节点可以设置相同的 Layer 属性，使其被同一个相机所观察。开发者可以使用引擎内置的 Layer 属性，也可以使用自定义的 Layer 属性，点击下图中的 Edit 按钮即可前往 项目设置 -> Layers 页面进行设置。详情请参考 层级 文档。 其中 User Layer 0 - User Layer 19 是提供给用户自定义设置的 layer 属性，用户只需要在 layer 后面填入自定义 layer name 就可以启用这个 layer 属性，并在节点上编辑。 小结 上面的例子中，我们先是将 MeshRenderer 组件和节点组合，有了可以指定渲染材质的网格资源，接下来我们通过修改节点属性，能够对这个模型进行缩放和旋转等不同方式的显示。现在我们又为这个节点添加了 DirectionalLight 组件，让节点可以根据平行光源的不同状态展现不同的效果。这就是 Cocos Creator 3.0 组件式开发的工作流程，我们可以用这样的方式将不同的功能组合在一个节点上，实现更多复杂目标。 需要注意的是，一个节点上只能添加一个渲染组件，渲染组件包括 MeshRenderer、Sprite、Label、Graphics、Mask、RichText、UIStaticBatch 等。 "},"concepts/scene/coord.html":{"url":"concepts/scene/coord.html","title":"坐标系和节点变换","keywords":"","body":"坐标系和节点变换属性 在文档 场景编辑器 和 节点和组件 中，我们介绍了可以通过 变换工具 Gizmo 和编辑 属性检查器 中节点的属性来变更节点的显示行为。这篇文档我们将会深入了解节点所在场景空间的坐标系，以及节点的 位置（Position）、旋转（Rotation）、缩放（Scale） 三大变换属性的工作原理。 坐标系 我们已经知道可以为节点设置位置属性，那么一个有着特定位置属性的节点在游戏运行时将会呈现在屏幕上的什么位置呢？就好像日常生活的地图上有了经度和纬度才能进行卫星定位，我们也要先了解 Cocos Creator 3.0 的坐标系，才能理解节点位置的意义。 世界坐标系（World Coordinate） 世界坐标系也叫做绝对坐标系，在 Cocos Creator 3.0 游戏开发中表示场景空间内的统一坐标体系，「世界」用来表示我们的游戏场景。 Creator 3.0 的世界坐标系采用的是笛卡尔右手坐标系，默认 x 向右，y 向上，z 向外，同时使用 -z 轴为正前方朝向。 本地坐标系（Local Coordinate） 本地坐标系也叫相对坐标系，是和节点相关联的坐标系。每个节点都有独立的坐标系，当节点移动或改变方向时，和该节点关联的坐标系将随之移动或改变方向。 Creator 3.0 的 节点（Node） 之间可以有父子关系的层级结构，我们通过修改节点的 Position 属性设定的节点位置是该节点相对于父节点的 本地坐标系，而非世界坐标系。 最后在绘制整个场景时 Creator 会把这些节点的本地坐标映射成世界坐标系坐标。 假设场景中有三个节点：NodeA、NodeB、NodeC，节点的结构如下图所示： 当场景中包含不同层级的节点时，会按照以下的流程确定每个节点在世界坐标系下的位置： 从场景根级别开始处理每个节点，上图中 NodeA 就是一个根级别节点。首先根据 NodeA 的 位置（Position） 属性，在世界坐标系中确定 NodeA 的本地坐标系原点位置（也就是 Position）。 接下来处理 NodeA 的所有直接子节点，也就是上图中的 NodeB（以及其他和 NodeB 平级的节点）。根据 NodeB 的 Position 属性，在 NodeA 的本地坐标系中确定 NodeB 在世界坐标系中的位置。 之后不管有多少级节点，都继续按照层级高低依次处理，每个节点都使用父节点的坐标系和自身位置属性来确定在世界坐标系中的位置。 变换属性 节点包括了 位置（Position）、旋转（Rotation） 和 缩放（Scale） 三个主要的变换属性，下面我们依次介绍。 位置（Position） 位置（Position） 由 X、Y 和 Z 属性组成，分别规定了节点在当前坐标系 x 轴、y 轴和 z 轴上的坐标，默认为 (0, 0, 0)。 上图中节点 NodeA 的世界坐标是 (50, 50, 50)，子节点 NodeB 的本地坐标是 (0, 2, 0)，此时若将 NodeB 移动到场景根目录，可以看到 NodeB 的世界坐标变成了 (50, 52, 50)： 由此可见，子节点 NodeB 的 Position 是以父节点 NodeA 的 Position 为坐标系原点的。 如果父节点 NodeA 改变 Position，子节点 NodeB 也会跟着改变位置（世界坐标系），但是子节点 NodeB 的 Position 属性不会发生变化，因为子节点 NodeB 在以父节点 NodeA 的 Position 为原点的本地坐标系中没有发生变化。 在 场景编辑器 中，可以随时使用 移动变换工具 来改变节点位置。 旋转（Rotation） 旋转（Rotation） 由 X、Y 和 Z 属性组成，默认为 (0, 0, 0)，是另外一个会对节点本地坐标系产生影响的重要属性。当改变 X 属性时，表示节点会以 x 轴为中心进行逆时针/顺时针旋转，以此类推，改变 Y 或者 Z 属性时也是一样的。 当属性值为 正 时，节点 逆时针 旋转。 当属性值为 负 时，节点 顺时针 旋转。 上图所示的节点层级关系和前一张图相同，只是节点 NodeA 在 z 轴上的 旋转（Rotation） 属性设为了 60 度，可以看到除了 NodeA 本身在以 z 轴为中心 逆时针 旋转了 60 度之外，其子节点 NodeB 也以 NodeA 的 z 轴为中心，一起 逆时针 旋转了 60 度。这也意味着旋转属性会影响到子节点。 注意：节点上的四元数 rotation 属性，表示的是绕任意轴旋转的角度。而 属性检查器 中的 Rotation 所对应的属性是欧拉角属性 EulerAngles，在脚本中可通过 Node.eulerAngles 获取 Rotation 的值。这两个属性可以根据需求分别使用，在使用 API 时请一定要注意它们和编辑器面板属性名的对应区别。 在 场景编辑器 中，可以随时使用 旋转变换工具 来设置节点的旋转。 缩放（Scale） 缩放（Scale） 属性也是由 X、Y 和 Z 三个属性组成，分别表示节点在 x 轴、y 轴和 z 轴上的缩放倍率，默认为 (1, 1, 1)。 上图所示的节点层级关系和介绍 Position 时的相同。将节点 NodeA 的缩放属性设为 (2, 1, 1)，也就是将 NodeA 在 x 轴方向放大到原来的 2 倍，y 轴和 z 轴则保持不变。可以看到子节点 NodeB 也在 x 轴方向放大到了原来的两倍，所以缩放属性会影响所有子节点。 在子节点上设置的缩放属性会和父节点的缩放叠加作用，子节点的子节点会将每一层级的缩放属性全部 相乘 来获得在世界坐标系下显示的缩放倍率。这一点和 位置、旋转 属性其实是一致的，只不过 位置 和 旋转 属性是 相加 作用，而 缩放 属性是 相乘，作用表现得更加明显。 缩放 属性不会影响当前节点的 位置 和 旋转，但会影响子节点的 位置。 在 场景编辑器 中，可以随时使用 缩放变换工具 来修改节点缩放。 "},"concepts/scene/node-tree.html":{"url":"concepts/scene/node-tree.html","title":"节点层级和渲染顺序","keywords":"","body":"节点层级和渲染顺序 通过前面的内容，我们了解了通过节点和组件的组合，能够在场景中创建多种元素。当场景中的元素越来越多时，我们就需要通过节点层级来将节点按照逻辑功能归类，并按需排列它们的显示顺序。 了解层级管理器 创建和编辑节点时，场景编辑器 可以展示直观的可视化场景元素。而节点之间的层级关系则需要使用 层级管理器 来检查和操作。请先阅读 层级管理器 面板介绍，来掌握 层级管理器 的使用方法。 节点树 通过 层级管理器 或运行时脚本的操作，建立的节点之间的完整逻辑关系，就叫做节点树。 我们用一个简单的游戏场景来看一下什么是节点树。下图中包括背景图像、一个主角（小球）、标题、跳板、钻石和开始游戏的按钮： 每个视觉元素都是一个节点，通常我们不会把所有节点平铺在场景上，而是会按照一定的分类和次序（比如根据自己的喜好）组织成节点树，例如： 我们把显示在上层的叫做父节点，显示在下层的叫做子节点。在 层级管理器 中，上图的节点树就会是这个样子： 因为 Creator 3.0 的 UI 节点需要其任意上级节点至少得有一个含有 UITransform 组件，在创建时若不符合规则，便会自动添加一个 Canvas 节点作为它的父级，所以上图中的节点树便将 UI 节点都统一放在了 Canvas 节点下。然后根据类别分别创建父节点，并将同类节点放在一个父节点下，从而构建出的节点树。 在实际游戏项目中我们还可以根据需要采用其他方式（例如游戏逻辑）来组织节点树。 节点渲染顺序 3D 节点的渲染与距离相机的 Z 坐标值，透明度等有关系。 UI 节点的渲染和遮挡关系则受节点树的影响，在 层级管理器 中会按照节点排列顺序从上到下依次渲染，也就是说显示在列表上面的节点在场景中会被下面的节点遮盖住。因此，子节点永远都会遮盖住父节点。详情可参考 UI 渲染排序规则。 其他渲染相关可参考： 图形渲染 粒子渲染 模型分组渲染 性能考虑 注意，虽然说父节点可以用来组织逻辑关系甚至是当做承载子节点的容器，但节点数量过多时，场景加载速度会受影响，因此在制作场景时应该避免出现大量无意义的节点，尽可能合并相同功能的节点。 "},"concepts/scene/scene-editing.html":{"url":"concepts/scene/scene-editing.html","title":"使用场景编辑器搭建场景","keywords":"","body":"使用场景编辑器搭建场景图像 本文将介绍使用 场景编辑器 创建和编辑场景图像时的工作流程和技巧。 使用节点创建菜单快捷添加基本节点类型 当我们开始在场景中添加内容时，一般会先从 层级管理器 的 创建节点菜单 开始，也就是点击左上角的 + 按钮弹出的菜单，从几个简单的节点分类中选择我们需要的基础节点类型并添加到场景中。 添加节点时，在 层级管理器 中选中的节点将成为新建节点的父节点，如果你选中了一个折叠显示的节点然后通过菜单添加了新节点，需要展开刚才选中的节点才能看到新添加的节点。 空节点 选择 创建节点菜单 中的 创建空节点 就能够创建一个不包含任何组件的节点。空节点可以作为组织其他节点的容器，也可以用来挂载开发者编写的逻辑和控制组件。另外在下文中我们也会介绍如何通过空节点和组件的组合，创造符合自己特殊要求的控件。 3D 对象 选择 创建节点菜单 中的 创建 3D 对象 可以创建编辑器自带的一些比较基础的静态模型控件，目前包括立方体、圆柱体、球体、胶囊、圆锥体、圆环体、平面和四方形。若需要创建其他类型的模型，可参考 MeshRenderer 组件。 UI 节点 选择 创建节点菜单 中的 创建 UI 可以创建 UI 节点。Creator 3.0 的 UI 节点需要其任意上级节点至少得有一个含有 UITransform 组件，在创建时若不符合规则，便会自动添加一个 Canvas 节点作为它的父级。并且每一个 UI 节点本身也会带有 UITransform 组件。 所以 Canvas 节点是 UI 渲染的 渲染根节点，所有渲染相关的 UI 节点都要放在 Canvas 下面，这样做有以下好处： Canvas 能提供多分辨率自适应的缩放功能，以 Canvas 作为渲染根节点能够保证我们制作的场景在更大或更小的屏幕上都保持较好的图像效果，详见 多分辨率适配方案相关文档。 Canvas 节点会根据屏幕大小自动居中显示，所以 Canvas 下的 UI 节点会以屏幕中心作为坐标系的原点。根据我们的经验，这样设置会简化场景和 UI 的设置（比如让按钮元素的文字默认出现在按钮节点的正中），也能让控制 UI 节点位置的脚本更容易编写。 2D 渲染节点 通过 创建节点菜单 可以创建像 ParticleSystem（粒子）、Sprite（精灵）、Label（文字）、Mask（遮罩）等由节点和基础渲染组件组成的节点类型。 这里的基础 2D 渲染组件，是无法用其他组件的组合来代替的。需要注意的是每个节点上只能添加一个渲染组件，重复添加会导致报错。但是可以通过将不同渲染节点组合起来的方式实现复杂的界面控件，比如下面的 UI 控件节点。 UI 控件节点 从 创建节点菜单 中的 UI 类别里可以创建包括 Button（按钮）、Widget（对齐挂件）、Layout（布局）、ScrollView（滚动视图）、EditBox（输入框）等节点在内的常用 UI 控件。 UI 节点大部分都是由渲染节点组合而成的，比如我们通过菜单创建的 Button 节点，就包括了一个包含 Button + Sprite 组件的按钮背景节点，加上一个包含 Label 组件的标签节点： 使用菜单创建基础类型的节点，是快速向场景中添加内容的推荐方法，之后我们还可以根据需要对使用菜单创建的节点进行编辑，创造我们需要的组合。 关于 UI 节点的更多内容，可参考 UI 结构说明。 逻辑节点的归属 除了有具体渲染等任务的节点之外，建议在场景根目录设置一些节点只负责挂载脚本，执行游戏逻辑，不包含任何渲染等相关内容。通常我们将这些节点放置在场景根层级，和 Canvas 节点并列，方便协作的时候其他开发者能够第一时间找到游戏逻辑并进行相关的数据绑定。 提高场景制作效率的技巧 场景编辑器 包括 3D 和 2D 两种视图，3D 视图用于 3D 场景编辑，2D 视图则主要用于 UI 节点等 2D 元素的编辑，可通过编辑器左上方工具栏中的 3D/2D 按钮切换场景视图。 以下几种快捷方式对两种视图都适用： 在 层级管理器 里选中一个节点，然后双击或者按 F 就可以在 场景编辑器 中聚焦这个节点。 选中一个节点后按 Cmd/Ctrl + D 会在该节点相同位置复制并粘贴一个同样的节点，当我们需要快速制作多个类似节点时可以用这个命令提高效率。 在 场景编辑器/层级管理器 中，按住 Cmd/Ctrl 键依次点击你想要的节点，就可以同时选中多个节点。Shift 键则可以连选节点，不需要一个一个选中。 对齐/平均分布节点 当 场景编辑器 为 2D 视图时，左上角有一排按钮可以用来在选中多个节点时将这些节点对齐或者平均分布。具体的规则如下： 假设三个 Label 节点都已经选中，从左到右的 6 个对齐按钮会依次将这些节点： 顶部对齐，按照最靠近上方的边界对齐（而不是最上方的节点的上边界） 垂直居中对齐，按照整体的水平中线对齐 底部对齐，按照最靠近下方的边界对齐 左对齐，按照最靠近左边的边界对齐 水平居中对齐，按照整体的垂直中线对齐 右对齐，按照最靠近右边的边界对齐 后半部分从左到右的 6 个分布按钮会依次将这些节点： 顶部分布，按照节点的上边界平均分布 垂直居中分布，按照节点的水平中线平均分布 底部分布，按照节点的下边界平均分布 左分布，按照节点的左边界平均分布 水平居中分布，按照节点的垂直中线平均分布 右分布，按照节点的右边界平均分布 注意：不管是一开始测定左右边界和中线还是之后将每个节点对齐/平均分布时的参照，都是节点约束框的中心或某条边界，而不是节点的位置坐标。 例如下图中我们将三个宽度不同的 Label 节点向右对齐后，得到的是三个节点约束框的右边界对齐，而不是三个节点位置的 x 坐标变成一致。 场景显示效果 目前还支持在场景中设置天空盒、全局雾效果以及阴影等，以便更好地丰富场景，渲染并展示场景环境。具体可参考： 天空盒 全局雾效 阴影 "},"asset/":{"url":"asset/","title":"资源系统","keywords":"","body":"关于资源 本章节将详细介绍 Cocos Creator 中资源的整体工作流程，并对各类资源的使用方法及可能需要注意的地方做出说明。 资源管理器 资源管理器 作为访问管理资源的重要工具，开发者在管理资源时推荐先熟悉资源管理器的使用方法，关于资源管理器的详细介绍可见：资源管理器 资源工作流 资源工作流 通用的资源工作流程包括导入资源、同步资源、定位资源等，详情请参考 资源工作流。 常见资源类型 接下来我们会介绍 Cocos Creator 中的主要资源类型： 场景资源 图像资源 纹理贴图资源 精灵帧资源 立方体贴图资源 图像资源的自动裁剪 图集资源 渲染纹理 预制资源 脚本资源 字体资源 音频资源 材质资源 模型资源 从第三方工具导出模型资源 glTF 模型 动画资源 Spine 骨骼动画资源 DragonBones 骨骼动画资源 TiledMap 瓦片图资源 JSON 资源 文本资源 资源管理 运行时资源管理部分的内容请参考 Asset Manager。 "},"asset/asset-workflow.html":{"url":"asset/asset-workflow.html","title":"资源工作流","keywords":"","body":"资源工作流 导入资源 Creator 提供了三种 导入资源 的方式： 以新建文件的方式，通过 Cocos Creator 窗口的 资源管理器 面板 创建按钮 导入资源 以复制文件的方式，在操作系统的文件管理器中，将资源文件复制到项目资源文件夹下，之后打开编辑器或激活编辑器窗口会自动刷新 资源管理器 的资源列表，完成导入资源。 以拖拽文件的方式，从操作系统的文件管理器中拖拽资源文件到 资源管理器 面板的某个文件夹位置，完成导入资源。 资源相关的名称如下： 名称 说明 dataBase 数据库 asset-db 项目资源数据库 internal-db 内置数据库 uuid 唯一标识符 meta 元信息 同步资源 资源管理器 面板中的资源和 操作系统的文件管理器 中看到的项目资源文件是同步的，在 资源管理器 中对资源的移动、重命名和删除，都会同步到 操作系统的文件管理器，反之亦然。 资源配置信息 .meta 文件 所有资源文件都会在导入时生成一份同名的 .meta 后缀的配置文件 这份配置文件提供了该资源在项目中的唯一标识 UUID 以及其他的一些配置信息，如图集中的小图引用，贴图资源的裁剪数据等，是识别一份合法资源的必要因素。 在 资源管理器 面板中 .meta 文件是不可见的，对资源的重命名，移动，删除，都会由编辑器自动同步该资源对应的 .meta 文件，以确保配置信息如 UUID 等保持不变，即不影响现有的引用。 不推荐直接在 操作系统的文件管理器 对资源文件进行操作，如有操作，请同步处理相应的 .meta 文件，如下建议： 关闭正在使用的编辑器，避免因为文件锁定或资源名称相同导致更新失败。 删除，重命名，移动资源时，请连同 .meta 文件一起删除，重命名，移动。 复制资源时如果连同 .meta 文件一起复制，将直接使用复制进来的 .meta 文件，而不是再生成新的 .meta 文件；如果只复制了资源文件，则会生成对应名称的新的 .meta 文件。 Library 中的资源 资源经过导入后会生成一份新的数据存在项目的 Library 文件夹里。在 Library 里的文件，其结构和资源是面向引擎的，是最终游戏时需要的格式，即机器友好，但对人的阅读不友好。这块。 当 library 丢失或损坏的时候，只要删除整个 library 文件夹再打开项目，就会重新生成资源库。 如何定位资源 一个资源有唯一的 uuid 来定位到该资源，但这种方式不够直观，还有另一种直观的方式：Database URL 格式例如 asset-db 对应的协议头是 db://assets，internal-db 对应的协议头是 db://internal。 有文件夹层级的资源格式，如 db://assets/prefabs/fire.prefab SVN 或 GIT 同步资源 需要注意 .meta 文件的换行符，建议统一下团队成员电脑的换行符风格和规则，避免同步项目资源后打开项目，出现了大量的 .meta 文件修改 "},"asset/image.html":{"url":"asset/image.html","title":"图像资源","keywords":"","body":"图像资源 图像资源又经常被称作贴图、图片，是游戏中绝大部分图像渲染的数据源。图像资源一般由图像处理软件（比如 Photoshop，Windows 上自带的画图）制作而成并输出成 Cocos Creator 可以使用的文件格式，目前支持 JPG、PNG、BMP 格式。 导入图像资源 将图像资源直接拖拽到 资源管理器 即可将其导入到项目中，之后我们就可以在 资源管理器 中看到如下图所示的图像资源： 属性检查器 中图像资源的相关属性说明如下： 属性 说明 Type 用于设置图像资源的类型，包括 raw、texture（默认）、normal map、sprite-frame、texture cube，具体说明可参考下文 图像资源类型 部分的内容。 Flip Vertical 是否沿 X 轴垂直翻转导入的贴图。 useComponentTexture 是否使用压缩纹理，详情请参考 压缩纹理。 图像资源的类型 在 资源管理器 面板选中导入的图像资源，在 属性检查器 面板中便可根据需要设置图像资源的使用类型，目前支持以下几种： raw：原始图片类型，无作用，用户不需要关心。 texture：图像资源类型，也是导入的图像资源的默认类型，详情可参考 纹理贴图资源。 normal map：法线贴图类型，常用于渲染 3D 模型，可在模型材质中勾选 USE NORMAL MAP 属性使用。需要注意的是，如果材质中没有定义 USE NORMAL MAP 就没有该属性。 sprite-frame：精灵帧资源，用于 UI 制作上，详情可参考 SpriteFrame。 texture cube：立方贴图类型，使用在全景图上，常用于制作天空盒。详情可参考 立方体贴图。 子资源 每个图像资源导入后或者设置图像资源类型后，编辑器便会自动在其下方创建相应类型的子资源。在 资源管理器 中点击图像资源左侧的三角图标，即可展开查看图像资源的子资源。 下图以 texture 类型的图像资源为例： 子资源的详细属性说明请参考对应资源类型的文档说明。normal map 的子资源属性与 texture 一致，可参考 纹理贴图资源 "},"asset/texture.html":{"url":"asset/texture.html","title":"纹理贴图资源","keywords":"","body":"纹理贴图资源（Texture） 纹理贴图资源是一种用于程序采样的资源，如模型上的贴图、精灵上的 UI。当程序渲染 UI 或者模型时，会使用纹理坐标获取纹理颜色，然后填充在模型网格上，再加上光照等等一系列处理便渲染出了整个场景。 纹理贴图资源可由图像资源（ImageAsset）转换而来，图像资源包括一些通用的图像转换格式如 PNG、JPEG 等等。 Texture2D Texture2D 是纹理贴图资源的一种，通常用于 3D 模型的渲染，如模型材质中的反射贴图、环境光遮罩贴图等等。 在将图像资源 导入 到 Creator 后，即可在 属性检查器 面板将其设置为 texture 类型，texture 类型便是 Texture2D 纹理资源。 Texture2D 属性 当导入图像资源时，编辑器默认将其设置为 texture 类型，并且在导入的图像资源下会自动创建一个或多个子资源，点击 资源管理器 中图像资源左侧的三角图标即可展开查看所有的子资源，如下图所示： 选中生成的 Texture2D 子资源后可以在 属性检查器 设置相关属性： 属性 说明 Anisotropy 各向异性值，应用各向异性过滤算法的最大阈值 Min/Mag Filter 缩小或者放大贴图时采用的纹理过滤方式，可选项包括 nearest（默认）和 linear。详情请参考下文 过滤方式 部分的内容 Mip Filter 多级纹理过滤算法，可选项包括 none、nearest 和 linear，当设置为 nearest 或者 linear 时，便会自动生成 mipmap。详情请参考下文 genMipmaps 部分的内容 Wrap Mode S/T 设置 S（U）/ T（V）方向上的纹理寻址模式，也就是像素对纹理在 S（U）或者 T（V）方向上的映射模式。可选项包括 repeat（默认）、clamp-to-edge 和 mirrored-repeat。详情请参考下文 寻址模式 部分的内容 接下来我们对部分属性进行简单的说明。 过滤方式 当 Texture2D 的原始大小与屏幕映射的纹理图像尺寸不一致时，通过不同的纹理过滤方式进行纹理单元到像素的映射会产生不同的效果。 Texture2D 中的 Min Filter 和 Mag Filter 属性，分别用于设置在缩小或者放大贴图时采用的纹理过滤方式： 邻近过滤（nearest） 邻近过滤是 默认 使用的纹理过滤方式。使用中心位置距离采样点最近的纹理单元颜色值作为该采样点的颜色值，不考虑其他相邻像素的影响。 需要注意的是使用临近过滤方式可能会出现边缘不平滑，锯齿较为明显的情况。 线性过滤（linear） 线性过滤使用距离采样点最近的 2 x 2 的纹理单元矩阵进行采样，取四个纹理单元颜色值的平均值作为采样点的颜色，像素之间的颜色值过渡会更加平滑。 需要注意的是使用线性过滤方式可能会出现边缘黑边的情况，如果是像素类游戏，可能会出现模糊情况。 genMipmaps 为了加快 3D 场景渲染速度和减少图像锯齿，贴图被处理成由一系列被预先计算和优化过的图片组成的序列，这样的贴图被称为 mipmap。mipmap 中每一个层级的小图都是原图的一个特定比例的缩小细节的复制品，当贴图被缩小或者只需要从远距离观看时，mipmap 就会转换到适当的层级。 当 Texture2D 的 Mip Filter 属性设置为 nearest 或者 linear 时，会在两个相近的层级之间插值，自动生成 mipmap（仅对非压缩格式生效）。因为渲染远距离物体时，mipmap 贴图比原图小，提高了显卡采样过程中的缓存命中率，所以渲染的速度得到了提升。同时因为 mipmap 的小图精度较低，从而减少了摩尔纹现象，可以减少画面上的锯齿。另外因为额外生成了一些小图，所以 mipmap 需要额外占用约三分之一的内存空间。 寻址模式 一般来说，纹理坐标在水平轴（U）和垂直轴（V）的取值范围为 [0，1]，当传递的顶点数据中的纹理坐标取值超出 [0，1] 范围时，就可以通过不同的寻址模式来控制超出范围的纹理坐标如何进行纹理映射。 Texture2D 中的 Wrap Mode S 和 Wrap Mode T 属性便是分别用于设置纹理在 UV 方向上的寻址模式： 重复寻址模式（repeat） 重复寻址模式是默认使用的纹理寻址模式。对于超出 [0，1] 范围的纹理坐标，使用 [0，1] 内的纹理坐标内容不断重复，也就是在超出纹理坐标范围外的地方重复放置纹理贴图。 注意：在 WebGL1.0 平台，当贴图宽高不是二次幂时，repeat 寻址模式是无效的。运行时会自动将其切换为 clamp-to-edge 寻址模式，这将会使材质的 tilingOffset 等属性失效。 当 Texture2D 的 Wrap Mode S 和 Wrap Mode T 属性都设置为 repeat 时，效果图如下： 钳位寻址模式（clamp-to-edge） 将纹理坐标约束在 0 到 1 之间，只复制一遍 [0，1] 的纹理坐标。对于 [0，1] 之外的部分，将使用边缘的纹理坐标内容进行延伸，产生类似边缘被拉伸的效果。 当两个属性都设置为 clamp-to-edge 时，效果图如下： 镜像寻址模式（mirrored-repeat） 类似重复寻址模式，只不过贴图是镜像重复放置的。 当两个属性都设置为 mirrored-repeat 时，效果图如下： 使用 Texture2D Texture2D 是使用范围非常广泛的资源，在 Creator 中的使用方式主要包括在编辑器中使用和动态获取使用： 在编辑器的 属性检查器 面板中，任何标记为 Texture2D 类型的属性，都可以将 Texture2D 资源拖拽到属性框中使用。例如设置材质资源的 Texture2D 类型资源： 注意：如果材质中没有定义 USE TEXTURE 就没有该属性。 动态使用时，需要先获取图像资源（ImageAsset），然后根据获取到的 ImageAsset 实例化出 Texture2D 资源。 resources.load(\"testAssets/image/texture\", Texture2D, (err: any, texture: Texture2D) => { const spriteFrame = new SpriteFrame(); spriteFrame.texture = texture; this.node.getComponent(Sprite).spriteFrame = spriteFrame; }); 详情请参考 资源加载。 参考链接 LearnOpenGL — 纹理 "},"asset/sprite-frame.html":{"url":"asset/sprite-frame.html","title":"精灵帧资源","keywords":"","body":"精灵帧资源（SpriteFrame） Cocos Creator 的 SpriteFrame 是 UI 渲染基础图形的容器。其本身管理图像的裁剪和九宫格信息，默认持有一个与其同级的 Texture2D 资源引用。 导入精灵帧资源 使用默认的 资源导入 方式将图像资源导入到项目中，然后在 属性检查器 中将图像资源的类型设置为 sprite-frame，并点击右上角的绿色打钩按钮保存： Creator 便会自动在导入的图像资源下创建一个如下图所示的 spriteFrame 资源： 图像资源在 资源管理器 中会以自身图片的缩略图作为图标。在 资源管理器 中选中图像子资源后，属性检查器 下方会显示该图片的缩略图。 属性 spriteFrame 资源属性如下： 属性 功能说明 Packable 是否参与动态合图，详情请参考下文 Packable 部分的内容 Rotated 只读属性，不可更改。用于查看 Texture Packer 资源中的子资源是否被旋转 Offset X、Y 只读属性，不可更改。用于查看 Texture Packer 资源中矩形框的偏移量 Trim Type 裁剪类型，包括：1. Auto — 自动裁剪（默认），详情请参考 图像资源的自动剪裁2. Custom — 自定义裁剪3. None — 无裁剪，使用原图 Trim Threshold 透明度阈值，默认为 1，取值范围为 0~1，会将透明度在设定值以下的像素裁减掉。当 Trim Type 设置为 Auto 时生效 Trim X、Y、Width、Height 设置裁剪矩形框，当 Trim Type 设置为 Custom 时生效 Border Top、Bottom、Left、Right 设置九宫格图边距，可点击下方的 编辑 按钮进行可视化编辑 Packable 如果引擎开启了 动态合图 功能，动态合图会自动将合适的贴图在开始场景时动态合并到一张大图上来减少 Drawcall。但是将贴图合并到大图中会修改原始贴图的 UV 坐标，如果在自定义 effect 中使用了贴图的 UV 坐标，这时 effect 中的 UV 计算将会出错，需要将贴图的 Packable 属性设置为 false 来避免贴图被打包到动态合图中。 使用 SpriteFrame 使用 texture 渲染 将 SpriteFrame 资源拖拽到 Sprite 组件 的 SpriteFrame 属性框中，即可切换 Sprite 显示的图像。 在运行时，以上图中导入的名为 content 的图片为例，整个资源分为三部分： content：图像源资源 ImageAsset content 的子资源 spriteFrame，即精灵帧资源 SpriteFrame content 的子资源 texture，即贴图资源 Texture2D 当资源存放在 resources 目录下时，我们可直接加载到 spriteFrame 资源，代码示例如下： const url = 'test_assets/test_atlas/content/spriteFrame'; resources.load(url, SpriteFrame, (err: any, spriteFrame) => { const sprite = this.getComponent(Sprite); sprite.spriteFrame = spriteFrame; }); 但在有些情况下只能加载到图像源资源 ImageAsset，因此我们提供了 createWithImage 方法来帮助用户通过加载到的 ImageAsset 创建一个 SpriteFrame 资源。根据 ImageAsset 的来源不同，有以下两种创建方式： 存放在服务器上的资源只能加载到图像源资源 ImageAsset，加载方法请参考 动态加载资源。创建 SpriteFrame 资源的代码示例如下： const self = this; const url = 'test_assets/test_atlas/content'; resources.load(url, ImageAsset, (err: any, imageAsset) => { const sprite = this.getComponent(Sprite); sprite.spriteFrame = SpriteFrame.createWithImage(imageAsset); }); 或者用户也可以手动填充信息，代码示例如下： const self = this; const url = 'test_assets/test_atlas/content'; resources.load(url, ImageAsset, (err: any, imageAsset) => { const sprite = this.getComponent(Sprite); const spriteFrame = new SpriteFrame(); const tex = new Texture2D(); tex.image = imageAsset; spriteFrame.texture = tex; sprite.spriteFrame = spriteFrame; }); 通过 Canvas 绘制的 ImageAsset 创建，代码示例如下： const sprite = this.getComponent(Sprite); sprite.spriteFrame = SpriteFrame.createWithImage(canvas); 或者用户也可以手动填充信息，代码示例如下： const sprite = this.getComponent(Sprite); const img = new ImageAsset(canvas); const tex = new Texture2D(); tex.image = img; const sp = new SpriteFrame(); sp.texture = tex; sprite.spriteFrame = sp; 使用 RenderTexture 渲染 RenderTexture 是一个渲染纹理，它可以将摄像机上的内容直接渲染到一张纹理上而不是屏幕上。SpriteFrame 通过管理 RenderTexture 可以轻松地将 3D 相机内容显示在 UI 上。具体的使用方法及代码示例如下： const cameraComp = this.getComponent(Camera); const renderTexture = new RenderTexture(); const size = view.getVisibleSize(); renderTexture.reset({ width: size.width, height: size.height, colorFormat: RenderTexture.PixelFormat.RGBA8888, depthStencilFormat: RenderTexture.DepthStencilFormat.DEPTH_24_STENCIL_8 }); cameraComp.targetTexture = renderTexture; const spriteFrame = new SpriteFrame(); spriteFrame.texture = renderTexture; const sprite = this.getComponent(Sprite); sprite.spriteFrame = spriteFrame; API 接口文档：SpriteFrame 资源类型。 "},"ui-system/components/engine/trim.html":{"url":"ui-system/components/engine/trim.html","title":"图像资源的自动剪裁","keywords":"","body":"图像资源的自动剪裁 导入图像资源后生成的 SpriteFrame 默认会进行自动剪裁，去除原始图片周围的透明像素区域。这样我们在使用 SpriteFrame 渲染 Sprite 时，将会获得有效图像更精确的大小。当 SpriteFrame 为自动剪裁时，下图中自动剪裁的相关信息为置灰状态，不可修改： Sprite 组件剪裁相关设置详解 和图片裁剪相关的 Sprite 组件设置有以下两个： Trim 勾选后将在渲染 Sprite 图像时去除图像周围的透明像素，我们将看到刚好能把图像包裹住的约束框。取消勾选，Sprite 节点的约束框会包括透明像素的部分。 Size Mode 用来将节点的尺寸设置为原图或原图裁剪透明像素后的大小，通常用于在序列帧动画中保证图像显示为正确的尺寸。有以下几种选择： TRIMMED 选择该选项，会将节点的尺寸（size）设置为原始图片裁剪掉透明像素后的大小。 RAW 选择该选项，会将节点尺寸设置为原始图片包括透明像素的大小。 CUSTOM 自定义尺寸，用户在使用 矩形变换工具 拖拽改变节点的尺寸，或通过修改 Size 属性，或在脚本中修改 width 或 height 后，都会自动将 Size Mode 设为 CUSTOM。表示用户将自己决定节点的尺寸，而不需要考虑原始图片的大小。 下图中展示了两种常见组合的渲染效果： 自带位置信息的序列帧动画 有很多动画师在绘制序列帧动画时，会使用一张较大的画布，然后将角色在动画中的运动直接通过角色在画布上的位置变化表现出来。在使用这种素材时，我们需要将 Sprite 组件 的 Trim 设为 false，将 Size Mode 设为 RAW。这样动画在播放每个序列帧时，都将使用原始图片的尺寸，并保留图像周围透明像素的信息，这样才能正确显示绘制在动画中的角色位移。 而 Trim 设为 true，则是在位移完全由角色位置属性控制的动画中，更推荐使用的方式。 TexturePacker 设置 在制作序列帧动画时，我们通常会使用 TexturePacker 这样的工具将序列帧打包成图集，并在导入后通过图集资源下的 SpriteFrame 来使用。在 TexturePacker 中输出图集资源时，Sprites 分类下的 Trim mode 请选择 Trim，一定不要选择 Crop, flush position，否则透明像素剪裁信息会丢失，您在使用图集里的资源时也就无法获得原始图片未剪裁的尺寸和偏移信息了。目前建议使用 TexturePacker 4.x 以上版本进行打包，以防止低版本导出数据不一致造成的导入失败。 "},"asset/atlas.html":{"url":"asset/atlas.html","title":"图集资源","keywords":"","body":"图集资源（Atlas） 图集（Atlas）也称作 Sprite Sheet，是游戏开发中常见的一种美术资源。图集是通过专门的工具将多张图片合并成一张大图，并通过 plist 等格式的文件索引的资源。可供 Cocos Creator 使用的图集资源由 plist 和 png 文件组成。下面就是一张图集使用的图片文件： 为什么要使用图集资源 在游戏中使用多张图片合成的图集作为美术资源，有以下优势： 合成图集时会去除每张图片周围的空白区域，加上可以在整体上实施各种优化算法，合成图集后可以大大减少游戏包体和内存占用 多个 Sprite 如果渲染的是来自同一张图集的图片时，这些 Sprite 可以使用同一个渲染批次来处理，大大减少 CPU 的运算时间，提高运行效率。 更形象生动的解释可以观看来自 CodeAndWeb 的教学视频 What is a Sprite Sheet（什么是图集），需要使用 VPN 打开视频。 制作图集资源 要生成图集，首先您应该准备好一组原始图片： 接下来可以使用专门的软件生成图集，我们推荐的图集制作软件包括： TexturePacker 4.x Zwoptex 使用这些软件生成图集时请选择 cocos2d-x 格式的 plist 文件。最终得到的图集文件是同名的 plist 和 png。 使用 TexturePacker 打包图集时的设置可参考 TexturePacker 设置。 注意：Cocos Creator 3.x 不支持 TexturePacker v4.x 以下的图集格式，否则导入时会出现报错。 导入图集资源 将上面所示的 plist 和 png 文件同时拖拽到 资源管理器 中，就可以生成可以在编辑器和脚本中使用的图集资源了。 Atlas 和 SpriteFrame 导入图集资源后，点击类型为 Atlas 的图集资源左边的三角图标，展开后可以看到图集资源里包含了很多类型为 SpriteFrame 的子资源，每个子资源都可以单独使用/引用。 关于 SpriteFrame 的使用方式，详情请参考 SpriteFrame 文档。 "},"asset/auto-atlas.html":{"url":"asset/auto-atlas.html","title":"自动图集资源","keywords":"","body":"自动图集资源 (Auto Atlas) 自动图集 作为 Cocos Creator 自带的合图功能，可以将指定的一系列碎图打包成一张大图，具体作用和 Texture Packer 的功能很相近。 创建自动图集资源 在 资源管理器 中点击左上角的 + 创建按钮，然后选择 自动图集配置，即可在 资源管理器 中新建一个 auto-atlas.pac 资源。 自动图集资源 目前是以当前文件夹下的所有 SpriteFrame 作为碎图资源，然后在构建过程中将其打包成一个大的 Sprite Atlas，之后我们会增加其他的选择碎图资源的方式。如果碎图资源 SpriteFrame 有配置过，那么打包后重新生成的 SpriteFrame 将会保留这些配置。 配置自动图集资源 在 资源管理器 中选中一个 自动图集资源 后，属性检查器 面板将会显示 自动图集资源 的所有可配置项。 属性 功能说明 Max Width 单张图集最大宽度 Max Height 单张图集最大高度 Padding 图集中碎图之间的间距 Allow Rotation 是否允许旋转碎图 Force Squared 是否强制将图集长宽大小设置成正方形 Power of Two 是否将图集长宽大小设置为二次方倍数 Algorithm 图集打包策略，目前暂时只有一个选项 MaxRects Padding Bleed 在碎图的边框外扩展出一像素外框，并复制相邻碎图像素到外框中。该功能也称作 Extrude Filter Unused 不包含未被引用的资源，该选项仅在构建后生效 其余属性与 Texture 是一样的，详情请参考 纹理贴图。 配置完成后可以点击 预览 按钮来预览打包的结果，按照当前自动图集配置生成的相关结果将会展示在 属性检查器 下面的区域。 注意：每次配置完成后，需要重新点击 预览 才会重新生成预览图。 结果分为： Packed Textures：显示打包后的图集图片以及图片相关的信息，如果会生成的图片有多张，则会往下在 属性检查器 中列出来。 Unpacked Textures：显示不能打包进图集的碎图资源，造成的原因有可能是这些碎图资源的大小比图集资源的大小还大导致的，这时候可能需要调整下图集的配置或者碎图的大小了。 生成图集 预览项目或者在 Cocos Creator 中使用碎图的时候都是直接使用的碎图资源，在 构建项目 这一步才会真正生成图集到项目中，注意在构建时要勾选 自动图集 选项才会生效。正常情况下，生成图集资源后，会删除包体内原有的小图的 texture 和 image 图片资源，以下两种特殊情况会有特殊处理： 当图集资源在 resources 目录下，除了正常生成图集资源以外，也会同时生成原始 spriteFrame 生成的 texture 以及 image 资源。 当图集资源文件夹内任意 spriteFrame 依赖的 texture 被其他资源直接使用（例如被直接作为纹理贴图使用），被依赖的 texture 及其 image 资源将会被一同打包出来。 以上两种情况事实上都会增大包体，构建将会警告提示，如非必须，请不要这样使用。 "},"asset/label-atlas.html":{"url":"asset/label-atlas.html","title":"艺术数字资源","keywords":"","body":"艺术数字资源 (LabelAtlas) 艺术数字资源 是一种用户自定义的资源，它可以用来配置艺术数字字体的属性。 创建艺术数字资源 在 资源管理器 中点击右键，然后选择 创建 -> 艺术数字配置，或者点击 资源管理器 左上角的加号按钮： 即可新建一个艺术数字资源： 属性 属性 功能说明 SpriteFrame 设置事先绘制好的包含所需字体样式的图片 Item Width 指定每一个字符的宽度 Item Height 指定每一个字符的高度 Start Char 指定艺术数字字体里面的第一个字符，如果字符是空格，也需要在这个属性里面输入空格字符 Font Size 显示每个字符的大小，由 Item Width 和 Item Height 自动计算得出，不可编辑 艺术数字资源 在使用之前需要先配置包含所需字体样式的 SpriteFrame 贴图，如下图： 然后将其拖拽到 艺术数字资源 的 SpriteFrame 属性框中： 设置完成后请点击右上角的绿色打钩按钮保存。 使用艺术数字资源 使用艺术数字资源只需要在 层级管理器 中新建一个 Label 节点，然后在 属性检查器 中将新建好的艺术数字资源拖拽到节点 Label 组件的 Font 属性上即可。详情可参考 Label 组件。 "},"asset/prefab.html":{"url":"asset/prefab.html","title":"预制资源","keywords":"","body":"预制件（Prefab） 预制件用于存储一些可以复用的场景对象，它可以包含节点、组件以及组件上的数据。由预制件生成的实例既可以继承模板的数据，又可以有自己定制化的数据修改。 基础概念 名称 说明 示例 预制件资源 在 资源管理器 中的预制件资源，是预制件的序列化文件。 预制件实例 预制件资源被拖拽到 层级管理器 中就会生成一个预制件实例，它的根节点目前标记为亮绿色，它的子节点为暗绿色 预制件编辑模式 双击预制件资源，会进入预制件的编辑模式，此时所有的非嵌套预制件节点都显示为暗绿色。可点击 场景编辑器 左上方的按钮来 保存 修改或者 关闭 编辑模式 嵌套的预制件实例 一个预制件资源中的某个子节点是另一个预制件资源的实例，则这个子预制件实例就是一个嵌套的预制件实例 创建预制件 在场景中将节点编辑好之后，直接将节点从 层级管理器 拖到 资源管理器 中即可完成预制件资源的创建。 完成创建后，原节点自动变为该预制件的实例，根节点呈现 亮绿色，非嵌套预制件子节点呈现 暗绿色。 使用预制件 将预制件资源从 资源管理器 拖拽到 层级管理器 或 场景编辑器，即可在场景中生成一个预制件的实例。 场景中的预制件实例对象，数据源来自预制件资源的反序列化，所以它的数据默认同步了预制件资源，如果对预制件实例中的各项属性进行修改，修改的数据会被存储在预制件实例中，所以不会影响到预制件资源和它生成的其它预制件实例的数据。 进入预制件编辑模式 在 资源管理器 中双击预制件资源可从场景编辑模式切换到预制件编辑模式。 此时可以在编辑器中编辑预制件资源，编辑完成之后，点击场景编辑器中的 保存 按钮即可保存编辑后的预制件资源，之后点击 关闭 按钮即可返回场景编辑模式。 注意：请尽量避免多人同时修改同一个 Prefab 资源，否则可能会导致冲突，且无法通过 git 合并解决冲突。 预制件节点的状态 预制件节点在 属性检查器 中呈现 绿色 时表示与资源关联正常；呈现 红色 则表示关联的资源丢失。 场景中编辑预制件节点 通用操作 在 层级管理器 中选中预制件节点，属性检查器 的顶部便会出现几个可操作的按钮： 图标 说明 还原为普通节点。预制件节点可变为普通节点，即完全脱离和资源的关系。还可以通过点击编辑器主菜单中的 节点 -> 取消关联当前的 prefab 资源 来实现。 定位资源。便于快速在 资源管理器 中定位到预制件资源。 从资源还原。将当前预制件实例的数据还原为预制件资源中的数据，其中名字、位置和旋转不会被还原为预制件资源中的数据。 更新到资源。将当前预制件实例的所有数据更新到所关联的预制件资源中。 新增节点 在预制件实例下增加的新节点，在节点名字的右下角会有一个 + 标志，它的数据存储在预制件的实例下，所以不会影响关联的预制件资源的数据。 目前的一些限制 在预制件实例中添加/删除组件 在预制件实例中删除从预制件资源中创建的节点 在预制件实例中更改从预制件资源中创建的节点的层级关系 不允许预制件嵌套自己 "},"asset/font.html":{"url":"asset/font.html","title":"字体资源","keywords":"","body":"字体资源 使用 Cocos Creator 制作的游戏中可以使用三类字体资源：系统字体，动态字体和位图字体。 其中系统字体是通过调用游戏运行平台自带的系统字体来渲染文字，不需要用户在项目中添加任何相关资源。要使用系统字体，请使用 Label组件 中的 Use System Font 属性。 导入字体资源 动态字体 目前 Cocos Creator 支持 TTF 格式的动态字体。只要将扩展名为 TTF 的字体文件拖拽到 资源管理器 中，即可完成字体资源的导入。 位图字体 位图字体由 fnt 格式的字体文件和一张 png 图片组成，fnt 文件提供了对每一个字符小图的索引。这种格式的字体可以由专门的软件生成，请参考： Glyph Designer Hiero BMFont (Windows) 在导入位图字体时，请务必将 fnt 文件和 png 文件同时拖拽到 资源管理器 中。 请注意，在导入位图字体之后，需要将 png 文件的类型更改为 sprite-frame，否则位图字体将无法正常使用。 导入后的字体在 资源管理器 中显示如下： 注意 为了提高资源管理效率，建议将导入的 fnt 和 png 文件存放在单独的目录下，不要和其他资源混在一起。 使用字体资源 字体资源需要通过 Label 组件来渲染，下面是在场景中创建带有 Label 组件的节点的方法。 使用菜单创建 Label（字体）节点 在 层级管理器 中点击左上角的 创建节点 按钮，并选择 创建渲染节点/Label（文字），就会在场景中创建出一个带有 Label 组件的节点。 您也可以通过主菜单的 节点/创建渲染节点/Label（文字） 来完成创建，效果和上面的方法一样。 关联字体资源 使用上面方法创建的字体组件默认使用系统字体作为关联的资源，如果想要使用导入到项目中的 TTF 或位图字体，可以将您的字体资源拖拽到创建的 Label 组件中的 Font 属性栏中。 这时场景中的字体会立刻用刚才指定的字体资源进行渲染。您也可以根据项目需要，自由的切换同一个 Label 组件的 Font 属性，来使用 TTF 或位图字体。切换字体文件时，Label 组件的其他属性不受影响。 如果要恢复使用系统字体，可以点击 Use System Font 的属性复选框，来清除 Font 属性中指定的字体文件。 拖拽创建 Label（字体）节点 另外一种快捷使用指定资源创建字体节点的方法，是直接从 资源管理器 中拖拽字体文件（TTF 或位图字体都可以）到 层级管理器 中。和上面用菜单创建的唯一区别，是使用拖拽方式创建的文字节点会自动使用拖拽的字体资源来设置 Label 组件的 Font 属性。 "},"asset/audio.html":{"url":"asset/audio.html","title":"音频资源","keywords":"","body":"音频资源（AudioClip） Cocos Creator 支持导入大多数常见的音频文件格式，将其直接拖拽到 资源管理器 面板即可，导入后会在 资源管理器 中生成相应的音频资源（AudioClip）。 我们根据音频的长短将其分为长度较长的 音乐 和长度短的 音效，Creator 通过 AudioSource 组件控制播放不同的音频资源来实现游戏内的背景音乐和音效。详情请参考 AudioSource 组件参考。 支持的音频资源的格式 目前 Cocos Creator 支持导入以下格式的音频文件： 音频格式 说明 .ogg .ogg 是一种开源的有损音频压缩格式，与同类型的音频压缩格式相比，优点在于支持多声道编码，采用更加先进的声学模型来减少损失音质，同时文件大小在相同条件下比 .mp3 格式小。目前 Android 系统所有的内置铃声也都使用 .ogg 文件。 .mp3 .mp3 是最常见的一种数字音频编码和有损压缩格式。通过舍弃 PCM 音频资料中对人类听觉不重要的部分，达到压缩成较小文件的目的。但对于大多数用户的听觉感受来说，压缩后的音质与压缩前的相比并没有明显的下降。MP3 被大量软硬件支持，应用广泛，是目前的主流。 .wav .wav 是微软与 IBM 公司专门为 Windows 开发的一种标准数字音频文件，该文件能记录各种单声道或立体声的声音信息，并能保证声音不失真，因为音频格式未经过压缩。但文件占用相对较大。 .mp4 .mp4 是一套用于音频、视频信息的压缩编码标准，对于不同的对象可采用不同的编码算法，从而进一步提高压缩效率。 .m4a .m4a 是仅有音频的 MP4 文件。音频质量是压缩格式中非常高的，同时在相同的比特率下，文件占用更小。 采用不同的音频编码格式，在相同的条件下，生成的音频文件大小和音质都各有不同。 "},"asset/material.html":{"url":"asset/material.html","title":"材质资源","keywords":"","body":"材质资源 材质创建 材质创建方式如下： 或 材质控制着每个模型最终的着色，材质由 Effect 构成，由材质操控 Effect 的着色流程。材质本身也可以看作是 Effect 资源的容器，材质可以任意切换当前要使用的 Effect 资源。下图就是我们创建的材质默认选择的 Effect 资源。 同时，我们还可以通过点击 Effect 属性右边的框要切换当前材质的 Effect。 Effect 创建 Effect 的创建方式跟 Material 的创建方式类似。 创建出来的 Effect 默认是一个 PBR 的 Effect。 以上就是一个材质的创建流程，更多信息可以参考：Effect 书写格式与语法 "},"asset/model/mesh.html":{"url":"asset/model/mesh.html","title":"模型资源","keywords":"","body":"模型资源 目前，Creator 支持 FBX 和 glTF 两种格式的模型文件。 FBX：支持 FBX 2020 及更早的文件格式。 glTF：支持 glTF 2.0 及更早的文件格式，详情可参考 glTF 模型。 关于如何从第三方工具导出这两种模型文件，请参考 导入从 DCC 工具导出的模型。 模型导入 从外部导入编辑器中后，在 资源管理器 中可得到对应的模型资源文件，其目录结构如下：（以 glTF 文件为例，fbx 文件相同） 无动画的模型文件结构如下： 包含动画的模型文件结构如下： .material — 材质文件 .mesh — 模型文件 .texture — 模型贴图文件 .animation — 模型动画文件 .skeleton — 模型骨骼文件 .prefab — 导入时自动生成的预制件 模型使用 将模型文件导入后，直接将模型文件的根节点从 资源管理器 拖拽到 层级管理器 中想要放置的节点下，即可完成节点创建，此时模型就成功在场景中创建了。 或者也可以将模型文件的节点展开，选中模型文件节点下的 .prefab 文件，从 资源管理器 拖拽到 层级管理器 中同样能够完成创建。 模型资源属性 当在 资源管理器 中选中模型资源文件时（ .fbx 或 .gltf），在 属性检查器 中就可以直接设置模型资源的相关属性。 Model 模块 属性 说明 法线（Normals） 导入法线信息，包括以下四种选项：1. 可选（Optional）：只导入模型文件中包含的法线，适用于非常清楚自己模型数据的情况。2. 排除（Exclude）：不导入法线。3. 仅在必要时重新计算（Required）：导入模型文件中的法线，若模型文件中不包含法线则重新计算，适用于大部分情况。模型数据本身没问题的话还是推荐使用该项，没有额外的处理。4. 重新计算（Recalculate）：无论模型文件中是否包含法线，都直接重新计算并导入。选择该项会增加计算量，但是可以消除模型原始数据法线没有归一化带来的后续问题。 切线（Tangents） 导入切线信息，包括 Optional、Exclude、Require、Recalculate 四种选项，选项功能可参考 法线 的说明，二者相差不大。 跳过验证（Skip Validation） 是否跳过对模型文件的标准检测。 是否禁用 Mesh 拆分（Disable mesh split） 为了解决实时骨骼动画系统下 uniform vector 数量限制问题，目前在资源导入期会根据骨骼数量做拆分，这会对其他系统也产生影响。如果确定不会使用实时计算模式（对应 SkeletalAnimation 组件的 useBakedAnimation 选项未勾选时），可以勾选此项以提升性能。但注意改变此选项会影响生成的 prefab 内容，需要对应更新场景中的引用。后续重构会移除此流程。 Animation 模块 上方的动画文件表格是当前模型下的所有动画资源信息，下方是当前选中动画的具体帧数信息的编辑区域，可以在此处更改动画名称或进行简单的动画裁剪。 点击图上红框内的 + 按钮可以添加动画文件，添加的新文件默认拷贝一份完整的 clip 数据，可以在下方的 Start、End 输入框中输入帧数来裁剪动画。(目前暂时不支持拖拽裁剪动画) 点击图上红框内的 - 按钮可以删除当前选中的动画文件 Material 模块 DumpMaterial：当对模型文件自带的材质不满意想要修改时，需开启此选项，将文件结构目录下的材质文件 dump 出模型资源中，此时就可以进行材质的调整修改了 Dumper Directory：这里可以指定或者查看 dump 出来的目录位置 "},"asset/model/dcc-export-mesh.html":{"url":"asset/model/dcc-export-mesh.html","title":"从第三方工具导出模型资源","keywords":"","body":"导入从 DCC 工具导出的模型 目前大多数数字内容制作（Digital Content Creation, DCC）工具（3ds Max、Maya、Blender）都能导出 FBX 和 glTF 这两种格式的模型文件，所以这些工具导出的内容都能在 Cocos Creator 中得到良好的展示。 导出 FBX 因为 DCC 工具的坐标系和游戏引擎的坐标系可能不一致，所以在导出模型时需要进行一些变换才能在引擎中得到想要的结果。例如：Blender 的坐标系为 X 轴朝右，Y 轴朝里，Z 轴朝上，而 Cocos Creator 3.x 的坐标系为 X 轴朝右，Y 轴朝上，Z 轴朝外，所以需要调整旋转才能使得轴向一致。 以下以 Blender 2.8 作为例子，介绍模型的导入流程，首先我们在 Blender 中创建一个模型。 在 Blender 的 FBX 导出选项 中，我们选择 Up 为 Y Up，Forward 为 -Z Forward。 导入到 Cocos Creator 中，可以看到节点在 X 轴做了 -90 的旋转，以便将轴和 Creator 的对齐。 如果不想要这个旋转值，Blender 的 FBX 导出插件提供了一个实验性功能（Apply Transform），可以将旋转数据直接变换到模型的顶点数据中。 返回编辑器，在 属性检查器 中可以看到旋转数据没有了： 导出 glTF glTF 使用的也是右手坐标系，Blender 的 导出 glTF 的选项 比较简单，只要把 +Y Up 选项勾上就可以了，导出的数据中也没有旋转值。 朝向问题 游戏开发过程中可能会需要用到模型的朝向，例如想要一些物体面向玩家（使用了 LookAt 方法），这时就需要考虑模型的初始朝向，这里提供两种方法来调整模型的初始朝向。 Cocos Creator 3.x 是以 -Z 轴做为正前方的朝向，而在 Blender 中正前方朝向为 +Y 轴，所以在制作模型时需要以 Y 轴正方向做为物体的朝向，经过导出的变换后，在 Creator 中就会是以 -Z 轴做为正前方的朝向。 如果不想在 DCC 工具中改变朝向，可以在场景中尝试为导入的模型增加一个父节点，然后旋转模型以使得模型的初始朝向为 -Z 轴，之后的各种旋转相关的操作都以父节点为操作对象。 美术制作规范说明 合理制定模型资源下的子资源命名（例如：网格、材质），每修改一次子资源命名就会导致项目内关联该子资源的地方出现丢失。 当模型有一部分需要透明，一部分不需要透明时，应该分两个材质导出。如果是一个材质导出容易出现模型穿透现象，需要手动调整材质。 外部资源引用，导出的时候使用相对路径。否则，在多人合作下，会识别不到原资源路径，导致模型内置材质无法正确获取到贴图而呈现黄色。3ds Max 导出本地路径修改方式如下： "},"asset/model/glTF.html":{"url":"asset/model/glTF.html","title":"glTF 模型","keywords":"","body":"glTF 模型 Cocos Creator 支持 glTF 2.0 及更早的文件格式。 URI 解析 Creator 支持 glTF 中指定以下形式的 URI： Data URI 相对 URI 路径 文件 URL 文件路径 转换关系 当导入 glTF 模型到 Creator 时，glTF 中的资源将会按照以下关系转换为 Creator 中的资源： glTF 资源 Cocos Creator 资源 glTF 场景 预制件 glTF 网格 网格 glTF 蒙皮 骨骼 glTF 材质 材质 glTF 贴图 贴图 glTF 图像 图像 glTF 动画 动画剪辑 glTF 场景 导入后，glTF 场景将转换为 Creator 中的预制件资源，glTF 场景中递归包含的节点也将按照相同层级关系一一转换为预制件中的节点。 场景根节点 预制件将使用一个不带任何空间转换信息的节点作为根节点，glTF 场景的所有 根节点 将作为该节点的子节点。 节点转换 glTF 节点中的属性将按照下表中的映射关系转换为预制件节点中的属性： glTF 节点属性 预制件节点属性 层级关系 层级关系 位移 位置 旋转 旋转 缩放 缩放 矩阵 解压，并分别设置位置、旋转、缩放 网格引用 网格渲染器组件 蒙皮引用 蒙皮网格渲染器组件 初始权重 （蒙皮）网格渲染器组件权重 网格渲染器 若 glTF 节点引用了网格，那么导入后相对应的预制件节点也会添加网格渲染组件（MeshRenderer）。若该 glTF 节点还引用了蒙皮，那么相对应的预制件节点还会添加蒙皮网格渲染组件（SkinnedMeshRenderer）。 （蒙皮）网格渲染组件中的网格、骨骼和材质，都会与转换后的 glTF 网格、蒙皮、材质资源一一对应。 若 glTF 节点指定了初始权重，则转换后的（蒙皮）网格渲染器也将带有此权重。 glTF 网格 导入后，glTF 网格将转换为 Cocos Creator 中的网格资源。 glTF 网格中的所有 基元体 将被一一转换为 Creator 中的子网格。 若 glTF 网格指定了 权重，则相应地，转换后的 Creator 网格中也将存储相应的权重。 glTF 基元体 glTF 基元体的索引数组将一一对应转换为 Cocos Creator 子网格的索引数组。 glTF 基元模式将按照下表中的映射关系转换为 Cocos Creator 基元模式： glTF 基元模式 Cocos Creator 基元模式 POINTS gfx.PrimitiveMode.POINT_LIST LINES gfx.PrimitiveMode.LINE_LIST LINE_LOOP gfx.PrimitiveMode.LINE_LOOP LINE_STRIP gfx.PrimitiveMode.LINE_STRIP TRIANGLES gfx.PrimitiveMode.TRIANGLE_LIST TRIANGLE_STRIP gfx.PrimitiveMode.TRIANGLE_STRIP TRIANGLE_FAN gfx.PrimitiveMode.TRIANGLE_FAN glTF 顶点属性将转换为 Cocos Creator 顶点属性，属性名称的转换如下表所示： glTF 顶点属性名称 Cocos Creator 顶点属性名称 POSITION gfx.AttributeName.ATTR_POSITION NORMAL gfx.AttributeName.ATTR_NORMAL TANGENT gfx.AttributeName.ATTR_TANGENT TEXCOORD_0 gfx.AttributeName.ATTR_TEX_COORD TEXCOORD_1..TEXCOORD_8 gfx.AttributeName.ATTR_TEX_COORD1..gfx.AttributeName.ATTR_TEX_COORD8 COLOR_0 gfx.AttributeName.ATTR_COLOR COLOR_1..COLOR_2 gfx.AttributeName.ATTR_COLOR1..gfx.AttributeName.ATTR_COLOR2 JOINTS_0 gfx.AttributeName.ATTR_JOINTS WEIGHTS_0 gfx.AttributeName.ATTR_WEIGHTS 注意：若 glTF 基元体中存在其他 JOINTS、WEIGHTS 顶点属性，例如 JOINTS_1、WEIGHTS_1，则意味着此 glTF 网格的顶点可能受到多于 4 根骨骼的影响。 对于每个顶点，所有由 JOINTS_{}、WEIGHTS_{} 确定的权重信息将按权重值进行排序，取出影响权重最大的四根骨骼作为 gfx.AttributeName.ATTR_JOINTS 和 gfx.AttributeName.ATTR_WEIGHTS。 glTF 形变目标将被转换为 Cocos Creator 子网格形变数据。 glTF 蒙皮 导入后，glTF 蒙皮将转换为 Cocos Creator 中的骨骼资源。 glTF 材质 导入后，glTF 材质将转换为 Cocos Creator 中的材质资源。 glTF 贴图 导入后，glTF 贴图将转换为 Cocos Creator 中的贴图资源。 glTF 贴图中引用的 glTF 图像将转换为对相应转换后的 Cocos Creator 图像的引用。 glTF 贴图属性将按照下表中的映射关系转换为 Cocos Creator 贴图属性： glTF 贴图属性 Cocos Creator 贴图属性 放大筛选器 放大筛选器 缩小筛选器 缩小筛选器、Mip Map 筛选器 S 环绕模式 S 环绕模式 T 环绕模式 环绕模式 glTF 贴图放大筛选器将按照下表中的映射关系转换为 Cocos Creator 贴图放大筛选器： glTF 贴图放大筛选器 Cocos Creator 贴图放大筛选器 NEAREST TextureBase.Filter.NEAREST LINEAR TextureBase.Filter.LINEAR glTF 贴图缩小筛选器将按照下表中的映射关系转换为 Cocos Creator 贴图缩小筛选器和 Cocos Creator 贴图 Mip Map 筛选器： glTF 贴图缩小筛选器 Cocos Creator 贴图缩小筛选器 Cocos Creator 贴图 Mip Map 筛选器 NEAREST TextureBase.Filter.NEAREST TextureBase.Filter.NONE LINEAR_MIPMAP_LINEAR TextureBase.Filter.LINEAR TextureBase.Filter.NONE LINEAR_MIPMAP_NEAREST TextureBase.Filter.NEAREST TextureBase.Filter.NEAREST LINEAR TextureBase.Filter.LINEAR TextureBase.Filter.NEAREST NEAREST_MIPMAP_LINEAR TextureBase.Filter.NEAREST TextureBase.Filter.LINEAR NEAREST_MIPMAP_NEAREST TextureBase.Filter.LINEAR TextureBase.Filter.LINEAR glTF 贴图环绕模式将按照下表中的映射关系转换为 Cocos Creator 贴图环绕模式： glTF 贴图环绕模式 Cocos Creator 贴图环绕模式 CLAMP_TO_EDGE TextureBase.WrapMode.CLAMP_TO_EDGE REPEAT TextureBase.WrapMode.REPEAT MIRRORED_REPEAT TextureBase.WrapMode.MIRRORED_REPEAT glTF 图像 导入后，glTF 图像将转换为 Cocos Creator 中的图像资源。 当 glTF 图像的 URI 是 Data URI 时，图像数据将从 Data URI 中获取。否则，将根据 Cocos Creator 图像位置解析算法 解析并引用外部图像文件，其中 url 就是 glTF 图像的 URI，startDir 为 glTF 文件所在目录。 glTF 动画 导入后，glTF 动画将转换为 Cocos Creator 动画资源。 "},"asset/spine.html":{"url":"asset/spine.html","title":"Spine 骨骼动画资源","keywords":"","body":"骨骼动画资源（Spine） Creator 中的骨骼动画资源是由 Spine 编辑器 导出的，目前支持 JSON 和 二进制 两种数据格式。 各 Creator 版本对应支持的 Spine 版本如下所示： Creator 版本 Spine 版本 v3.0 及以上 v3.8（原生平台不支持特定版本 v3.8.75） v2.3 及以上 v3.8 v2.2 v3.7 v2.0.8～v2.1 v3.6 v2.0.7 及以下 v2.5 导入骨骼动画资源 骨骼动画所需资源有： .json/.skel 骨骼数据 .png 图集纹理 .txt/.atlas 图集数据 创建骨骼动画 从 资源管理器 中将骨骼动画资源拖动到 属性检查器 Spine 组件的 SkeletonData 属性中： 从服务器远程加载 Spine 加载文本格式的 Spine 资源 let comp = this.getComponent('sp.Skeleton') as sp.Skeleton; let image = \"http://localhost/download/spineres/1/1.png\"; let ske = \"http://localhost/download/spineres/1/1.json\"; let atlas = \"http://localhost/download/spineres/1/1.atlas\"; assetManager.loadAny([{ url: atlas, ext: '.txt' }, { url: ske, ext: '.txt' }], (error, assets) => { assetManager.loadRemote(image, (error, texture: Texture2D) => { let asset = new sp.SkeletonData(); asset.skeletonJson = assets[1]; asset.atlasText = assets[0]; asset.textures = [texture]; asset.textureNames = ['1.png']; skeleton.skeletonData = asset; }); }); 加载二进制格式的 Spine 资源 let comp = this.getComponent('sp.Skeleton') as sp.Skeleton; let image = \"http://localhost/download/spineres/1/1.png\"; let ske = \"http://localhost/download/spineres/1/1.skel\"; let atlas = \"http://localhost/download/spineres/1/1.atlas\"; assetManager.loadAny([{ url: atlas, ext: '.txt' }, { url: ske, ext: '.bin' }], (error, assets) => { assetManager.loadRemote(image, (error, texture: Texture2D) => { let asset = new sp.SkeletonData(); asset._nativeAsset = assets[1]; asset.atlasText = assets[0]; asset.textures = [texture]; asset.textureNames = ['1.png']; asset._uuid = ske; // 可以传入任意字符串，但不能为空 asset._nativeURL = ske; // 传入一个二进制路径用作 initSkeleton 时的 filePath 参数使用 comp.skeletonData = asset; let ani = comp.setAnimation(0, 'walk', true); }); }); "},"asset/dragonbones.html":{"url":"asset/dragonbones.html","title":"DragonBones 骨骼动画资源","keywords":"","body":"骨骼动画资源（DragonBones） DragonBones 骨骼动画资源是由 DragonBones 编辑器 导出的数据格式（支持 DragonBones v5.6.3 及以下）。 导入 DragonBones 骨骼动画资源 DragonBones 骨骼动画资源包括： .json/.dbbin 骨骼数据 .json 图集数据 .png 图集纹理 创建骨骼动画资源 在场景中使用 DragonBones 骨骼动画资源需要两个步骤： 创建节点并添加 DragonBones 组件： 从 资源管理器 里将骨骼动画资源拖动到已创建 DragonBones 组件的 Dragon Asset 属性中： 为 DragonBones 组件设置图集数据 从 资源管理器 里将图集数据拖动到 DragonBones 组件的 Dragon Atlas Asset 属性中： 在项目中的存放 为了提高资源管理效率，建议将导入的资源文件存放在单独的目录下，不要和其他资源混在一起。 "},"asset/tiledmap.html":{"url":"asset/tiledmap.html","title":"TiledMap 瓦片图资源","keywords":"","body":"瓦片图资源（TiledMap） 瓦片图资源是由 Tiled 编辑器 所导出的数据格式。 Creator 版本 Tiled 版本 v3.0 及以上 v1.4 v2.2 及以上 v1.2.0 v2.1 及以下 v1.0.0 导入地图资源 地图所需资源有： .tmx 地图数据 .png 图集纹理 .tsx tileset 数据配置文件（部分 tmx 文件需要） 创建瓦片图资源 从 资源管理器 里将地图资源拖动到已创建 TiledMap 组件的 Tmx File 属性中： 在项目中的存放 为了提高资源管理效率，建议将导入的 tmx、tsx 和 png 文件存放在单独的目录下，不要和其他资源混在一起。需要注意的是要把 tmx 文件和 tsx 文件放在同一目录管理，否则可能会导致资源无法被正确加载。 "},"scripting/":{"url":"scripting/","title":"脚本指南及事件机制","keywords":"","body":"脚本指南及事件机制 Cocos Creator 脚本用于实现用户定义的（游戏）行为，支持 JavaScript 和 TypeScript 两种编程语言。通过编写脚本组件，并将它挂载到场景节点中来驱动场景中的物体。 在组件脚本的编写过程中，开发者可以通过声明属性，将脚本中需要调节的变量映射到 属性检查器 中，以便策划和美术进行调整。与此同时，也可以通过注册特定的回调函数，来帮助初始化、更新甚至销毁节点。 内容 编程语言支持 脚本基础 脚本使用 脚本进阶 事件系统 模块规范与示例 插件脚本 更多参考 添加引擎内 Log 信息 废弃 API 推荐编码规范 "},"scripting/language-support.html":{"url":"scripting/language-support.html","title":"编程语言支持","keywords":"","body":"语言支持 Cocos Creator 支持 TypeScript 和 JavaScript 两种编程语言。但需要注意的是，JavaScript 只支持以 插件脚本 的形式导入使用。 TypeScript Cocos Creator 支持 TypeScript 4.1.0。在此基础上，做了以下限制： tsconfig.json 不会被读取。每个项目都隐含着如下选项： { \"compilerOptions\": { \"target\": \"ES2015\", \"module\": \"ES2015\", \"isolatedModules\": true, \"experimentalDecorators\": true, \"moduleResolution\": /* Cocos Creator 特定的模块解析算法 */, \"forceConsistentCasingInFileNames\": true, } } 隐含的 isolatedModules 选项意味着： 不支持 const enums。 重导出 TypeScript 类型和接口时应该使用 export type。例如使用 export type { Foo } from './foo'; 而不是 export { Foo } from './foo';。 不支持 export = 和 import =。 命名空间导出的变量必须声明为 const，而不是 var 或 let。 同一命名空间的不同声明不会共享作用域，需要显式使用限定符。 编译过程中的类型错误将被忽略。 编译时不会读取 tsconfig.json，意味着 tsconfig.json 的编译选项并不会影响编译。 开发者仍然可以在项目中使用 tsconfig.json 以配合 IDE 实现类型检查等功能。为了让 IDE 的 TypeScript 检查功能和 Creator 行为兼容，开发者需要额外注意一些事项，详情可参考 tsconfig。 TypeScript 参考教程 Cocos Creator 3.0 TypeScript 问题答疑及经验分享 TypeScript 官方网站 TypeScript - Classes TypeScript - Decorators TypeScript - DefinitelyTyped X 分钟速成 TypeScript TypeScript 源码 开发者回避使用 TypeScript 的三个借口 — 以及应当使用 TypeScript 的更有说服力的原因 JavaScript 语言特性 Creator 支持的 JavaScript 语言规范为 ES6。 此外，以下几项更新于 ES6 规范的语言特性或提案仍旧在支持之列： 类字段 Promise 对象 可选链操作符 ?. 空值合并操作符 ?? 逻辑赋值操作符 逻辑空赋值操作符 ??= 逻辑与赋值操作符 &&= 逻辑或赋值操作符 ||= 全局对象 globalThis 以下语言特性同样支持，但需要开启相关的编译选项： 异步函数 特别地，Creator 目前支持 Legacy 装饰器提案，其具体用法和含义请参考 babel-plugin-proposal-decorators。由于该 提案 仍处于阶段 2，引擎暴露的所有装饰器相关功能接口都在以下划线开头的 _decorator 命名空间下。 编译选项 Creator 开放了部分编译选项，这些选项将应用到整个项目。 选项 名称 含义 useDefineForClassFields 符合规范的类字段 当开启时，将使用 Define 语义实现类字段，否则将使用 Set 语义实现类字段。仅当目标不支持 ES6 类字段时生效。 allowDeclareFields 允许声明类字段 当开启时，在 TypeScript 脚本中将允许使用 declare 关键字来声明类字段，并且，当字段未以 declare 声明且未指定显式的初始化式时，将依照规范初始化为 undefined。 运行环境 从用户的角度来说，Creator 未绑定任何 JavaScript 实现，因此建议开发者严格依照 JavaScript 规范编写脚本，以获取更好的跨平台支持。 举例来说，当希望使用 全局对象 时，应当使用标准特性 globalThis： globalThis.blahBlah // 任何环境下 globalThis 一定存在 而非 window、global、self 或 this： typeof window // 可能是 'undefined' typeof global // 在浏览器环境下可能是 'undefined' 再如，Creator 未提供 CommonJS 的模块系统，因此以下代码片段会带来问题： const blah = require('./blah-blah'); // 错误，require 是未定义的 module.exports = blah; // 错误 module 是未定义的 反之，应使用标准模块语法： import blah from './blah-blah'; export default blah; JavaScript 参考教程 JavaScript 标准参考教程 JavaScript 秘密花园 JavaScript 内存详解 & 分析指南 "},"scripting/script-basics.html":{"url":"scripting/script-basics.html","title":"脚本基础","keywords":"","body":"脚本基础 该部分内容主要介绍脚本的一些基础概念、创建方式、运行环境等： 创建脚本 配置代码编辑环境 脚本运行环境 装饰器使用 属性参数参考 生命周期回调 "},"scripting/setup.html":{"url":"scripting/setup.html","title":"创建脚本","keywords":"","body":"创建脚本 创建组件脚本 在 Cocos Creator 中，脚本也是资源的一部分。你可以在 资源管理器 中选中想要放置脚本文件的文件夹，然后右键点击并选择 TypeScript 来创建一个组件脚本，或者也可以直接点击左上角的创建按钮（+）。 然后命名为 say-hello，便可以在 层级管理器 中看到生成了一个名为 say-hello 的脚本文件： 一份简单的组件脚本如下： import { _decorator, Component, Node } from 'cc'; const { ccclass, property } = _decorator; @ccclass('SayHello') export class SayHello extends Component { /* class member could be defined like this */ // dummy = ''; /* use `property` decorator if your want the member to be serializable */ // @property // serializableDummy = 0; start () { // Your initialization goes here. } // update (deltaTime: number) { // // Your update function goes here. // } } 注意：我们更推荐用户使用 TypeScript 来编写脚本，目前 资源管理器 中仅支持创建 TypeScript 文件。但用户也可以在外部创建 JavaScript，然后将其以 插件脚本 的形式导入到 Creator 使用。 编辑脚本 开发者可根据自己的需求，选择自己喜爱的文本工具（如：Vim、Sublime Text、Web Storm、VSCode 等）进行脚本编辑，请在编辑器菜单栏 偏好设置 的 外部程序 中设置脚本编辑器。 然后双击脚本资源，可以直接打开脚本编辑器进行编辑。编辑完脚本并保存，然后返回编辑器，Cocos Creator 会自动检测到脚本的改动，并迅速编译。 在代码编写之前，可先阅读以下文档了解更多关于脚本的内容： 配置代码编辑环境 脚本基础 添加脚本到场景节点中 将脚本添加到场景节点中，实际上就是为这个节点添加一个脚本组件。在 层级管理器 中选中希望添加脚本的场景节点，此时该节点的属性会显示在 属性检查器 中，添加脚本组件包括以下两种方式： 直接将 资源管理器 中的脚本拖拽到 属性检查器 中。 点击 属性检查器 最下方的 添加组件 按钮，然后选择 自定义脚本 -> SayHello 来添加我们刚刚编写的脚本组件。或者也可以直接搜索 SayHello 来添加，前提是需要开启 偏好设置 -> 实验室 中的 使用弹窗方式添加组件 功能。 需要注意的是，脚本组件的组件名是以脚本中定义的类名为准的，而不是脚本文件名。创建脚本时，脚本文件会按照以下规则生成脚本类名： 使用大驼峰式命名法 头部不能有数字 不含特殊字符 以脚本文件名中的符号和空格作为间隔，每个间隔后的首字母大写。例如脚本文件名为 say-hello，脚本类名则为 SayHello。 之后如果有对脚本文件名/脚本类名进行二次修改，这两者之间并不会自动同步，如果需要的话，可以手动同步。 以上面的 say-hello.ts 为例，若我们在 资源管理器 中将其重命名为 hello，可以看到 属性检查器 中的脚本组件名还是原来的 SayHello，只有脚本名称变成了 hello： 若我们双击打开 say-hello.ts，将类名改为 Hello： import { _decorator, Component, Node } from 'cc'; const { ccclass, property } = _decorator; @ccclass('Hello') export class Hello extends Component {} 保存脚本后返回编辑器，可以看到 属性检查器 中的脚本组件名变成了 Hello，但是脚本文件名还是原来的 say-hello： "},"scripting/coding-setup.html":{"url":"scripting/coding-setup.html","title":"配置代码编辑环境","keywords":"","body":"配置代码编辑环境 在 偏好设置 面板中指定了 默认脚本编辑器，便可以在 资源管理器 中双击脚本文件打开代码编辑器快速编辑代码。本篇内容主要以 Visual Studio Code 为例介绍如何配置开发环境。 Visual Studio Code （以下简称 VS Code）是微软推出的轻量化跨平台 IDE，支持 Windows、Mac、Linux 平台，安装和配置非常简单。使用 VS Code 管理和编辑项目脚本代码，可以轻松实现语法高亮、智能代码提示、网页调试等功能。 安装 VS Code 前往 VS Code 的 官方网站，点击首页的下载链接即可下载。 MacOS 用户解压下载包后双击 Visual Studio Code 即可运行。 Windows 用户下载后运行 VSCodeUserSetup.exe 按提示完成安装即可运行。 智能提示数据 Cocos Creator 3.x 在创建项目时，项目目录下会自动生成一个 tsconfig.json 文件，里面配置了一个代码提示用的目录文件路径，用 VS Code 打开项目编写代码时便会自动提示 Cocos Creator 引擎 API。若项目升级，引擎 API 也会自动更新。 启动 VS Code 后选择主菜单的 File -> Open Folder...，在弹出的对话框中选择项目根目录，也就是 assets、project.json 所在的路径。然后新建一个脚本，或者打开原有的脚本进行编辑时，就会有语法提示了。 注意：当使用自定义引擎，或者切换使用内置引擎/自定义引擎时，若出现 API 智能提示不更新的情况，请执行以下步骤以获得最新的代码智能提示： 删除自定义引擎中 bin 目录（内置引擎是 resources\\resources\\3d\\engine\\bin 目录）下的 cache 文件夹 在引擎目录下执行 npm run build-declaration 设置文件显示和搜索过滤 在 VS Code 的主菜单中选择 文件（Windows）／Code（Mac）-> 首选项 -> 设置，或者选择左下角 中的 Setting 选项，这个操作会打开用户配置文件 USER SETTINGS： 此时在上方的搜索框中输入 exclude 搜索，找到 Files: Exclude 和 Search: Exclude 模块： 然后点击 添加模式 补充以下内容中缺少的部分： { \"files.exclude\": { \"**/.git\": true, \"**/.DS_Store\": true, \"**/*.meta\": true, \"library/\": true, \"local/\": true, \"temp/\": true }, \"search.exclude\": { \"**/node_modules\": true, \"**/bower_components\": true, \"build/\": true, \"temp/\": true, \"library/\": true, \"**/*.anim\": true } } 以上字段将为 VS Code 设置搜索时排除的目录，以及在文件列表中隐藏的文件类型。由于 build、temp、library 都是编辑器运行时自动生成的路径，而且会包含我们写入的脚本内容，所以应该在搜索中排除。而 assets 目录下的每个文件都会生成一个 .meta 文件，一般来说我们不需要关心它的内容，只要让编辑器帮我们管理这些文件就可以了。 VS Code 扩展使用 Cocos Creator 在顶部菜单栏的 开发者 -> VS Code 工作流 中集成了 添加编译任务 和 添加 Chrome Debug 配置 功能，以便更好地辅助开发： 添加编译任务：用于在 VS Code 中触发 Creator 的脚本编译，详情请参考下文 使用 VS Code 激活脚本编译 部分的内容。 添加 Chrome Debug 配置：用于调试网页版游戏，详情请参考下文 使用 VS Code 调试网页版游戏 部分的内容。 使用 VS Code 激活脚本编译 使用外部脚本编辑器修改项目脚本后，需要返回 Cocos Creator 以触发脚本编译。 我们在 Creator 中提供了 添加编译任务 功能，通过一个预览服务器的 API 向特定地址发送请求来激活 Creator 的编译，这样在外部脚本编辑器修改了项目脚本后，执行 编译任务 便可触发脚本编译，不需要返回 Cocos Creator。 安装 cURL 首先需要确保操作系统中可以运行 cURL 命令，如果在 Windows 操作系统的命令行中运行 curl 提示找不到命令，则需要先安装 curl 到操作系统： 前往 http://www.confusedbycode.com/curl/ 点击下图箭头所示的控件，完成人机身份验证（若无法正常显示控件，请科学上网） 点击 curl-7.46.0-win64.exe 开始下载并安装 安装时请使用默认设置，安装完成后可以打开一个命令行窗口，输入 curl，如果提示 curl: try 'curl --help' or 'curl --manual' for more information 就表示安装成功了。 添加 VS Code 编译任务 要在 VS Code 中激活脚本编译，需要执行以下步骤： 在 Creator 顶部菜单栏点击 开发者 -> VS Code Workflow -> 添加编译任务，该操作会在项目目录的 .vscode 文件夹下添加 tasks.json 任务配置文件。 在 VS Code 里按下快捷键 Cmd/Ctrl + P，激活 快速打开 输入框，然后输入 task CocosCreator compile，选择 CocosCreator compile。 然后选择输出类型： 任务运行完成，会在 VS Code 窗口下方的输出面板中显示结果（根据 VS Code 版本及配置的不同，输出结果也会有所差异）。 这样之后在 VS Code 编辑脚本完成后，执行第 2 个步骤便可触发 Creator 的脚本编译，不需要返回 Creator。 VS Code 还可以为编译任务配置快捷键，在主菜单中选择 文件（Windows）／Code（Mac）-> 首选项 -> 键盘快捷方式，或者选择左下角 中的 键盘快捷方式 选项，这个操作会打开快捷键配置文件。然后根据需要修改编译任务的快捷键，例如下图将其设置成了 Cmd/Ctrl + Shift + B： 之后在 VS Code 中按下快捷键 Cmd/Ctrl + Shift + B 便会自动显示 CocosCreator compile，不需要手动搜索。 更多关于 VS Code 中配置和执行任务的信息，请参考 Integrate with External Tools via Tasks 文档。 使用 VS Code 调试网页版游戏 VS Code 有着优秀的调试能力，我们可以直接在源码工程中调试网页版游戏程序。 首先需要安装： Chrome（谷歌浏览器） VS Code 插件：Debugger for Chrome 点击 VS Code 左侧导航栏的 扩展 按钮打开扩展面板，在搜索框中输入 Debugger for Chrome 并点击安装。安装之后可能需要重启 VS Code 才能生效。 接下来在 Cocos Creator 顶部菜单栏中点击 开发者 -> VS Code 工作流 -> 添加 Chrome Debug 配置，这个菜单命令会在项目文件夹下添加一个 .vscode/launch.json 文件作为调试器的配置： 之后便可以在 VS Code 中点击左侧栏的 调试 按钮打开调试面板，并在最上方的调试配置中选择 Cocos Creator Launch Chrome against localhost，然后点击左侧绿色的开始按钮进行调试。 调试的时候依赖 Cocos Creator 编辑器内置的 Web 服务器，所以需要在编辑器启动状态下才能进行调试。如果编辑器预览游戏时使用的端口不是默认端口，则需要手动修改 launch.json 里的 url 字段，将正确的端口添加上去。 调试过程中可以在源码文件上直接下断点，进行监控，是比使用 Chrome 内置的 DevTools 调试更方便和友好的工作流程。 学习 VS Code 的使用方法 前往 VS Code 官网文档，了解从编辑功能操作、个性化定制、语法高亮设置到插件扩展等各方面的使用方法。 "},"scripting/basic.html":{"url":"scripting/basic.html","title":"脚本运行环境","keywords":"","body":"运行环境 Cocos Creator 3.0 引擎的 API 都存在模块 cc 中，使用标准的 ES6 模块导入语法将其导入： import { Component, // 导入类 Component _decorator, // 导入命名空间 _decorator Vec3 // 导入类 Vec3 } from 'cc'; import * as modules from 'cc'; // 将整个 Cocos Creator 模块导入为命名空间 Cocos Creator @_decorator.ccclass(\"MyComponent\") export class MyComponent extends Component { public v = new Vec3(); } 保留标识符 cc 注意，由于历史原因，cc 是 Cocos Creator 3.0 保留使用的标识符，其行为 相当于 在任何模块顶部定义了名为 cc 的对象。因此，开发者不应该将 cc 用作任何 全局对象 的名称： /* const cc = {}; // 每个 Cocos Creator 脚本都等价于在此处含有隐式定义 */ import * as modules from 'cc'; // 错误：命名空间导入名称 cc 由 Cocos Creator 保留使用 const cc = { x: 0 }; console.log(cc.x); // 错误：全局对象名称 cc 由 Cocos Creator 保留使用 function f () { const cc = { x: 0 }; console.log(cc.x); // 正确：cc 可以用作局部对象的名称 const o = { cc: 0 }; console.log(o.cc); // 正确：cc 可以用作属性名 } console.log(cc, typeof cc); // 错误：行为是未定义的 "},"scripting/decorator.html":{"url":"scripting/decorator.html","title":"装饰器使用","keywords":"","body":"装饰器使用 cc 类 将装饰器 ccclass 应用在类上时，此类称为 cc 类。cc 类注入了额外的信息以控制 Cocos Creator 对该类对象的序列化、编辑器对该类对象的展示等。因此，未声明 ccclass 的组件类，也无法作为组件添加到节点上。 ccclass 装饰器的参数 name 指定了 cc 类的名称，cc 类名是 独一无二 的，这意味着即便在不同目录下的同名类也是不允许的。当需要获取相应的 cc 类时，可以通过其 cc 类名来查找，例如： 序列化。若对象是 cc 类对象，则在序列化时将记录该对象的 cc 类名，反序列化时将根据此名称找到相应的 cc 类进行序列化。 当 cc 类是组件类时，Node 可以通过组件类的 cc 类名查找该组件。 @ccclass('Example') export class Example extends Component { } 组件类装饰器 此类装饰器是只能用来修饰 Component 的子类。 executeInEditMode 默认情况下，所有组件都只会在运行时执行，也就是说它们的生命周期回调在编辑器模式下并不会触发。executeInEditMode 允许当前组件在编辑器模式下运行，默认值为 false。 const { ccclass, executeInEditMode } = _decorator; @ccclass('Example') @executeInEditMode(true) export class Example extends Component { update (dt: number) { // 会在编辑器下每帧执行 } } requireComponent requireComponent 参数用来指定当前组件的依赖组件，默认值为 null。当组件添加到节点上时，如果依赖的组件不存在，引擎会自动将依赖组件添加到同一个节点，防止脚本出错。该选项在运行时同样有效。 const { ccclass, requireComponent } = _decorator; @ccclass('Example') @requireComponent(Sprite) export class Example extends Component { } executionOrder executionOrder 用来指定脚本生命周期回调的执行优先级。小于 0 的脚本将优先执行，大于 0 的脚本将最后执行。排序方式如下： 对于同一节点上的不同组件，数值小的先执行，数值相同的按组件添加先后顺序执行 对于不同节点上的同一组件，按节点树排列决定执行的先后顺序 该优先级设定只对 onLoad、onEnable、start、update 和 lateUpdate 有效，对 onDisable 和 onDestroy 无效。 const { ccclass, executionOrder } = _decorator; @ccclass('Example') @executionOrder(3) export class Example extends Component { } disallowMultiple 同一节点上只允许添加一个同类型（含子类）的组件，防止逻辑发生冲突，默认值为 false。 const { ccclass, disallowMultiple } = _decorator; @ccclass('Example') @disallowMultiple(true) export class Example extends Component { } menu @menu(path) 用来将当前组件添加到组件菜单中，方便用户查找。 const { ccclass, menu } = _decorator; @ccclass('Example') @menu('foo/bar') export class Example extends Component { } help 指定当前组件的帮助文档的 URL。设置完成后，在 属性检查器 中就会出现一个帮助图标，点击即可打开指定的网页。 const { ccclass, help } = _decorator; @ccclass('Example') @help('https://docs.cocos.com/creator/3.0/manual/zh/scripting/decorator.html') export class Example extends Component { } 属性装饰器 属性装饰器 property 可以被应用在 cc 类的属性或访问器上。属性装饰器用于控制 Cocos Creator 编辑器中对该属性的序列化、属性检查器 中对该属性的展示等。 属性装饰器的各种特性是通过 @property() 的参数来指定的。完整可选择参数可以参考：属性参数 property 装饰器写法参考如下： @property({ type: Node, visible: true, }) targetNode: Node | null = null; 接着，下方会罗列出一些常用属性参数写法。 type 参数 选项 type 指定了属性的 cc 类型。可以通过以下几种形式的参数指定类型： 基础属性类型 CCInteger、CCFloat、CCBoolean、CCString 是基础属性类型标识，一般仅用于数组属性的内部类型声明。非数组类型不需要显式声明这些类型。 CCInteger 声明类型为 整数 CCFloat 声明类型为 浮点数 CCString 声明类型为 字符串 CCBoolean 声明类型为 布尔值 其他 cc 类型 所有的 cc 类型 都需要显式指定，否则编辑器无法正确识别类型，序列化也无法写入正确类型。 数组类型 当使用基础属性类型或者 cc 类作为数组元素时，可以被通过数组类型声明被编辑器所识别。例如 [CCInteger]、[Node] 将分别以整数数组和节点数组的形式在 属性检查器 中展示。 若属性未指定类型，Cocos Creator 将从属性的默认值或初始化式的求值结果推导其类型： 若值的类型是 JavaScript 原始类型 number、string、boolean，则其类型分别对应 Creator 的CCFloat、CCString 和 CCBoolean。 其他情况下属性的类型则是 未定义 的，编辑器上会提示 Type(Unknown) 字样。 注意：当声明 JavaScript 内置构造函数 Number、String、Boolean 用作类型时将给出警告，并且将分别视为 cc 类型中的 CCFloat、CCString、CCBoolean。已经初始化的数组属性修改类型后，需要手动清除掉原来的数组数据，重新赋值，否则会因为数据类型不一致，导致数据错乱。 注意：需要在编辑器 属性检查器 中展示的属性，属性名开头不应该带 _，否则会识别为 private 属性，private 属性不会在编辑器组件属性面板上显示。 下列代码演示了不同 cc 类型的属性声明： import { _decorator, CCInteger, Node, Enum } from 'cc'; const { ccclass, property, integer, float, type } = _decorator; enum A { c, d } Enum(A); @ccclass class MyClass { @property // JavaScript 原始类型，根据默认值自动识别为 Creator 的浮点数类型。 index = 0; @property(Node) // 声明属性 cc 类型为 Node。当属性参数只有 type 时可这么写，等价于 @property({type: Node}) targetNode: Node | null = null; // 等价于 targetNode: Node = null!; // 声明属性 children 的 cc 类型为 Node 数组 @property({ type: [Node] }) children: Node[] = []; @property({ type: String, }) // 警告：不应该使用构造函数 String。等价于 CCString。也可以选择不声明类型 text = ''; @property children2 = []; // 未声明 cc 类型，从初始化式的求值结果推断元素为未定义的数组 @property _valueB = 'abc'; // 此处 '_' 开头的属性，只序列化，不会在编辑器属性面板显示 @property({ type: A }) accx : A = A.c; } 为了方便，额外提供几种装饰器以快速声明 cc 类型。如果你只需要为属性定义 type 参数，那么可以直接使用下列装饰器替代 @property： 装饰器 对应的 property 写法 @type(t) @property(t) @integer @property(CCInteger) @float @property(CCFloat) import { _decorator, CCInteger, Node } from 'cc'; const { ccclass, property, integer, float, type } = _decorator; @ccclass class MyClass { @integer // 声明属性的 cc 类型为整数 index = 0; @type([Node]) // 声明属性 children 的 cc 类型为 Node 数组 children: Node[] = []; @type(String) // 警告：不应该使用构造函数 String。等价于 CCString。也可以选择不声明类型 text = ''; // JavaScript 原始类型 `number`、`string`、`boolean` 通常可以不用声明 // 可以直接写 @property text = ''; } 开发者如果确实需要使用构造参数，可以通过 `arguments` 获取，但要记得如果这个类会被序列化，必须保证构造参数都缺失的情况下仍然能 new 出对象。 --> 当开发者在 **属性检查器** 中添加了一个组件，然后再回到脚本中修改属性默认值的话，**属性检查器** 中组件的属性值是不会发生变化的，因为组件中属性的当前值已经序列化到场景中，不再是第一次创建时用的默认值了。如果要强制把组件的所有属性设回默认值，可以在 **属性检查器** 中组件右上方的设置按钮中选择 **Reset**。 `default` 允许设置为以下几种值类型： 1. 任意 `number`、`string` 或 `boolean` 类型的值 2. `null` 或 `undefined` 3. 继承自 `ValueType` 的子类，如 `Vec3`、`Color` 或 `Rect` 的实例化对象： ```typescript @property({ type: Vec3 }) pos = null; ``` 4. 空数组 `[]` 或空对象 `{}` --> visible 参数 一般情况下，属性是否显示在 属性检查器 中取决于属性名是否以 _ 开头。如果是以 _ 开头，则不显示。 如果要强制显示在 属性检查器 中，可以设置 visible 参数为 true： @property({ visible: true }) private _num = 0; 如果要强制隐藏，可以设置 visible 参数为 false： @property({ visible: false }) num = 0; serializable 参数 属性默认情况下都会被序列化，序列化后就会将编辑器中设置好的属性值保存到场景等资源文件中，之后在加载场景时就会自动还原成设置好的属性值。如果不想序列化，可以设置 serializable: false。 @property({ serializable: false }) num = 0; override 参数 所有属性都会被子类继承，如果子类要覆盖父类同名属性，需要显式设置 override 参数，否则会有重名警告： @property({ tooltip: \"my id\", override: true }) id = \"\"; 参考链接 属性参数 脚本进阶 "},"scripting/reference/attributes.html":{"url":"scripting/reference/attributes.html","title":"属性参数参考","keywords":"","body":"属性参数 属性参数用来给已定义的属性附加元数据，类似于脚本语言的 Decorator 或者 C# 的 Attribute。 属性检查器相关参数 参数名 说明 类型 默认值 备注 type 限定属性的数据类型 (Any) undefined 详见 type visible 在 属性检查器 面板中显示或隐藏 boolean (注1) 详见 visible 参数 displayName 在 属性检查器 面板中显示为另一个名字 string undefined - tooltip 在 属性检查器 面板中添加属性的 Tooltip string undefined - multiline 在 属性检查器 面板中使用多行文本框 boolean false - readonly 在 属性检查器 面板中只读 boolean false - min 限定数值在编辑器中输入的最小值 number undefined - max 限定数值在编辑器中输入的最大值 number undefined - step 指定数值在编辑器中调节的步长 number undefined - range 一次性设置 min、max、step [min, max, step] undefined step 值可选 slide 在 属性检查器 面板中显示为滑动条 boolean false - 序列化相关参数 以下参数不能用于 get 方法： 参数名 说明 类型 默认值 备注 serializable 序列化该属性 boolean true 详见 serializable 参数 formerlySerializedAs 指定之前序列化所用的字段名 string undefined 重命名属性时，声明这个参数来兼容之前序列化的数据 editorOnly 在导出项目前剔除该属性 boolean false - 其它参数 参数名 说明 类型 默认值 备注 override 当重写父类属性时需要定义该参数为 true boolean false 详见 override 参数 不支持 ES6 定义方式 | --> 注1：visible 的默认值取决于属性名。当属性名以下划线 _ 开头时，默认隐藏，否则默认显示。 "},"scripting/life-cycle-callbacks.html":{"url":"scripting/life-cycle-callbacks.html","title":"生命周期回调","keywords":"","body":"﻿ 生命周期回调 Cocos Creator 为组件脚本提供了生命周期的回调函数。开发者只需要定义特定的回调函数，Creator 就会在特定的时期自动执行相关脚本，开发者不需要手工调用它们。 目前提供给开发者的生命周期回调函数主要有（按生命周期触发先后排列）： onLoad onEnable start update lateUpdate onDisable onDestroy onLoad 组件脚本的初始化阶段，我们提供了 onLoad 回调函数。onLoad 回调会在节点首次激活时触发，比如所在的场景被载入，或者所在节点被激活的情况下。在 onLoad 阶段，保证了你可以获取到场景中的其他节点，以及节点关联的资源数据。onLoad 总是会在任何 start 方法调用前执行，这能用于安排脚本的初始化顺序。通常我们会在 onLoad 阶段去做一些初始化相关的操作。例如： import { _decorator, Component, Node, SpriteFrame, find } from 'cc'; const { ccclass, property } = _decorator; @ccclass(\"test\") export class test extends Component { @property({type:SpriteFrame}) bulletSprite=null; @property({type:Node}) gun=null; _bulletRect=null; onLoad(){ this._bulletRect=this.bulletSprite.getRect(); this.gun = find('hand/weapon', this.node); } } onEnable 当组件的 enabled 属性从 false 变为 true 时，或者所在节点的 active 属性从 false 变为 true 时，会激活 onEnable 回调。倘若节点第一次被创建且 enabled 为 true，则会在 onLoad 之后，start 之前被调用。 start start 回调函数会在组件第一次激活前，也就是第一次执行 update 之前触发。start 通常用于初始化一些中间状态的数据，这些数据可能在 update 时会发生改变，并且被频繁的 enable 和 disable。 import { _decorator, Component, Node } from 'cc'; const { ccclass, property } = _decorator; @ccclass(\"starttest\") export class starttest extends Component { private _timer: number = 0.0; start () { this._timer = 1.0; } update (deltaTime: number) { this._timer += deltaTime; if(this._timer >= 10.0){ console.log('I am done!'); this.enabled = false; } } } update 游戏开发的一个关键点是在每一帧渲染前更新物体的行为，状态和方位。这些更新操作通常都放在 update 回调中。 import { _decorator, Component, Node } from 'cc'; const { ccclass, property } = _decorator; @ccclass(\"updatetest\") export class updatetest extends Component { update (deltaTime: number) { this.node.setPosition(0.0,40.0*deltaTime,0.0); } } lateUpdate update 会在所有动画更新前执行，但如果我们要在动效（如动画、粒子、物理等）更新之后才进行一些额外操作，或者希望在所有组件的 update 都执行完之后才进行其它操作，那就需要用到 lateUpdate 回调。 import { _decorator, Component, Node } from 'cc'; const { ccclass, property } = _decorator; @ccclass(\"lateupdatetest\") export class lateupdatetest extends Component { lateUpdate (deltaTime: number) { this.node.setPosition(0.0,50,0.0); } } onDisable 当组件的 enabled 属性从 true 变为 false 时，或者所在节点的 active 属性从 true 变为 false 时，会激活 onDisable 回调。 onDestroy 当组件或者所在节点调用了 destroy()，则会调用 onDestroy 回调，并在当帧结束时统一回收组件。 "},"scripting/usage.html":{"url":"scripting/usage.html","title":"脚本使用","keywords":"","body":"脚本使用 该部分内容主要介绍如何在项目中使用脚本： 访问节点和其他组件 常用节点和组件接口 创建和销毁节点 使用计时器 组件和组件执行顺序 加载和切换场景 获取和加载资源 tsconfig 配置 "},"scripting/access-node-component.html":{"url":"scripting/access-node-component.html","title":"访问节点和其他组件","keywords":"","body":"访问节点和组件 你可以在 属性检查器 里修改节点和组件，也能在脚本中动态修改。动态修改的好处是能够在一段时间内连续地修改属性、过渡属性，实现渐变效果。脚本还能够响应玩家输入，能够修改、创建和销毁节点或组件，实现各种各样的游戏逻辑。要实现这些效果，你需要先在脚本中获得你要修改的节点或组件。 在本篇教程，我们将介绍如何 获得组件所在的节点 获得其它组件 使用 属性检查器 设置节点和组件 查找子节点 全局节点查找 访问已有变量里的值 获得组件所在的节点 获得组件所在的节点很简单，只要在组件方法里访问 this.node 变量： start() { let node = this.node; node.setPosition(0.0, 0.0, 0.0); } 获得其它组件 如果你经常需要获得同一个节点上的其它组件，这就要用到 getComponent 这个 API，它会帮你查找你要的组件。 import { _decorator, Component, Label } from 'cc'; const { ccclass, property } = _decorator; @ccclass(\"test\") export class test extends Component { private label: any = null start() { this.label = this.getComponent(Label); let text = this.name + 'started'; // Change the text in Label Component this.label.string = text; } } 你也可以为 getComponent 传入一个类名。对用户定义的组件而言，类名就是脚本的文件名，并且 区分大小写。例如 \"SinRotate.ts\" 里声明的组件，类名就是 \"SinRotate\"。 let rotate = this.getComponent(\"SinRotate\"); 在节点上也有一个 getComponent 方法，它们的作用是一样的： start() { console.log( this.node.getComponent(Label) === this.getComponent(Label) ); // true } 如果在节点上找不到你要的组件，getComponent 将返回 null，如果你尝试访问 null 的值，将会在运行时抛出 \"TypeError\" 这个错误。因此如果你不确定组件是否存在，请记得判断一下： import { _decorator, Component, Label } from 'cc'; const { ccclass, property } = _decorator; @ccclass(\"test\") export class test extends Component { private label: any = null; start() { this.label = this.getComponent(Label); if (this.label) { this.label.string = \"Hello\"; } else { console.error(\"Something wrong?\"); } } } 获得其它节点及其组件 仅仅能访问节点自己的组件通常是不够的，脚本通常还需要进行多个节点之间的交互。例如，一门自动瞄准玩家的大炮，就需要不断获取玩家的最新位置。Cocos Creator 提供了一些不同的方法来获得其它节点或组件。 利用属性检查器设置节点 最直接的方式就是在 属性检查器 中设置你需要的对象。以节点为例，这只需要在脚本中声明一个 type 为 Node 的属性： // Cannon.ts import { _decorator, Component, Node } from 'cc'; const { ccclass, property } = _decorator; @ccclass(\"Cannon\") export class Cannon extends Component { // 声明 Player 属性 @property({ type: Node }) private player = null; } 这段代码在 properties 里面声明了一个 player 属性，默认值为 null，并且指定它的对象类型为 Node。这就相当于在其它语言里声明了 public Node player = null;。脚本编译之后，这个组件在 属性检查器 中看起来是这样的： 接着你就可以将层级管理器上的任意一个节点拖到这个 Player 控件： 这样一来它的 player 属性就会被设置成功，你可以直接在脚本里访问 player： // Cannon.ts import { _decorator, Component, Node } from 'cc'; const { ccclass, property } = _decorator; @ccclass(\"Cannon\") export class Cannon extends Component { @property({ type: Node }) private player = null; start() { console.log('The player is ' + this.player.name); } } 利用属性检查器设置组件 在上面的例子中，如果你将属性的 type 声明为 Player 组件，当你拖动节点 \"Player Node\" 到 属性检查器，player 属性就会被设置为这个节点里面的 Player 组件。这样你就不需要再自己调用 getComponent 啦。 // Cannon.ts import { _decorator, Component } from 'cc'; const { ccclass, property } = _decorator; import { Player } from \"Player\"; @ccclass(\"Cannon\") export class Cannon extends Component { @property({ type: Player }) private player = null; start() { let PlayerComp = this.player; } } 你还可以将属性的默认值由 null 改为数组 []，这样你就能在 属性检查器 中同时设置多个对象。 不过如果需要在运行时动态获取其它对象，还需要用到下面介绍的查找方法。 查找子节点 有时候，游戏场景中会有很多个相同类型的对象，像是炮塔、敌人和特效，它们通常都有一个全局的脚本来统一管理。如果用 属性检查器 来一个一个将它们关联到这个脚本上，那工作就会很繁琐。为了更好地统一管理这些对象，我们可以把它们放到一个统一的父物体下，然后通过父物体来获得所有的子物体： // CannonManager.ts import { _decorator, Component, Node } from 'cc'; const { ccclass, property } = _decorator; @ccclass(\"CannonManager\") export class CannonManager extends Component { start() { let cannons = this.node.children; //... } } 你还可以使用 getChildByName： this.node.getChildByName(\"Cannon 01\"); 如果子节点的层次较深，你还可以使用 find，find 将根据传入的路径进行逐级查找： find(\"Cannon 01/Barrel/SFX\", this.node); 全局名字查找 当 find 只传入第一个参数时，将从场景根节点开始逐级查找： this.backNode = find(\"Canvas/Menu/Back\"); 访问已有变量里的值 如果你已经在一个地方保存了节点或组件的引用，你也可以直接访问它们 通过模块访问 你可以使用 import 来实现脚本的跨文件操作，让我们看个示例： // Global.ts, now the filename matters import { _decorator, Component, Node } from 'cc'; const { ccclass, property } = _decorator; @ccclass(\"Global\") export class Global extends Component { public static backNode: any = null; public static backLabel: any = null; } 每个脚本都能用 import{ } from + 文件名(不含路径) 来获取到对方 exports 的对象。 // Back.ts import { _decorator, Component, Node, Label } from 'cc'; const { ccclass, property } = _decorator; // this feels more safe since you know where the object comes from import{Global}from \"./Global\"; @ccclass(\"Back\") export class Back extends Component { onLoad() { Global.backNode = this.node; Global.backLabel = this.getComponent(Label); } } // AnyScript.ts import { _decorator, Component, Node } from 'cc'; const { ccclass, property } = _decorator; // this feels more safe since you know where the object comes from import{Global}from \"./Global\"; @ccclass(\"AnyScript\") export class AnyScript extends Component { start () { const text = \"Back\"; Global.backLabel.string = text; } } "},"scripting/basic-node-api.html":{"url":"scripting/basic-node-api.html","title":"常用节点和组件接口","keywords":"","body":"常用节点和组件接口 在通过 访问节点和组件 介绍的方法获取到节点或组件实例后，这篇文章将会介绍通过节点和组件实例可以通过哪些常用接口实现我们需要的种种效果和操作。这一篇也可以认为是 Node 和 Component 类的 API 阅读指南，可以配合 API 一起学习理解。 节点状态和层级操作 假设我们在一个组件脚本中，通过 this.node 访问当前脚本所在节点。 激活/关闭节点 节点默认是激活的，我们可以在代码中设置它的激活状态，方法是设置节点的 active 属性： this.node.active = false; 设置 active 属性和在编辑器中切换节点的激活、关闭状态，效果是一样的。当一个节点是关闭状态时，它的所有组件都将被禁用。同时，它所有子节点，以及子节点上的组件也会跟着被禁用。要注意的是，子节点被禁用时，并不会改变它们的 active 属性，因此当父节点重新激活的时候它们就会回到原来的状态。 也就是说，active 表示的其实是该节点 自身的 激活状态，而这个节点 当前 是否可被激活则取决于它的父节点。并且如果它不在当前场景中，它也无法被激活。我们可以通过节点上的只读属性 activeInHierarchy 来判断它当前是否已经激活。 this.node.active = true; 若节点原先就处于 可被激活 状态，修改 active 为 true 就会立即触发激活操作： 在场景中重新激活该节点和节点下所有 active 为 true 的子节点 该节点和所有子节点上的所有组件都会被启用，它们中的 update 方法之后每帧会执行 这些组件上如果有 onEnable 方法，这些方法将被执行 this.node.active = false; 如该节点原先就已经被激活，修改 active 为 false 就会立即触发关闭操作： 在场景中隐藏该节点和节点下的所有子节点 该节点和所有子节点上的所有组件都将被禁用，也就是不会再执行这些组件中的 update 中的代码 这些组件上如果有 onDisable 方法，这些方法将被执行 更改节点的父节点 假设父节点为 parentNode，子节点为 this.node，您可以： this.node.parent = parentNode; 或 this.node.removeFromParent(false); parentNode.addChild(this.node); 这两种方法是等价的。 注意： removeFromParent 通常需要传入一个 false，否则默认会清空节点上绑定的事件和 action 等。 通过 创建和销毁节点 介绍的方法创建出新节点后，要为节点设置一个父节点才能正确完成节点的初始化。 索引节点的子节点 this.node.children：返回节点的所有子节点数组。 this.node.childrenCount：返回节点的子节点数量。 注意：以上两个 API 都只会返回节点的直接子节点，不会返回子节点的子节点。 更改节点的变换（位置、旋转、缩放） 更改节点位置 有以下两种方法： 使用 setPosition 方法： this.node.setPosition(100, 50, 100); this.node.setPosition(new Vec3(100, 50, 100)); 设置 position 变量： this.node.position = new Vec3(100, 50, 100); 更改节点旋转 this.node.setRotation(90, 90, 90); 或通过欧拉角设置本地旋转： this.node.setRotationFromEuler(90, 90, 90); 更改节点缩放 this.node.setScale(2, 2, 2); 常用组件接口 Component 是所有组件的基类，任何组件都包括如下的常见接口（假设我们在该组件的脚本中，以 this 指代本组件）： this.node：该组件所属的节点实例 this.enabled：是否每帧执行该组件的 update 方法，同时也用来控制渲染组件是否显示 update(deltaTime: number)：作为组件的成员方法，在组件的 enabled 属性为 true 时，其中的代码会每帧执行 onLoad()：组件所在节点进行初始化时（节点添加到节点树时）执行 start()：会在该组件第一次 update 之前执行，通常用于需要在所有组件的 onLoad 初始化完毕后执行的逻辑 "},"scripting/create-destroy.html":{"url":"scripting/create-destroy.html","title":"创建和销毁节点","keywords":"","body":"创建和销毁节点 创建新节点 除了通过场景编辑器创建节点外，我们也可以在脚本中动态创建节点。通过 new Node() 并将它加入到场景中，可以实现整个创建过程。 以下是一个简单的例子: import { _decorator, Component, Node } from 'cc'; const { ccclass, property } = _decorator; @ccclass(\"test\") export class test extends Component { start(){ let node =new Node('box'); node.setPosition(0,0,-10); } } 克隆已有节点 有时我们希望动态的克隆场景中的已有节点，我们可以通过 instantiate 方法完成。使用方法如下： import { _decorator, Component, Node,instantiate, director } from 'cc'; const { ccclass, property } = _decorator; @ccclass(\"test\") export class test extends Component { @property({type:Node}) private target: Node = null; start(){ let scene = director.getScene(); let node = instantiate(this.target); node.parent = scene; node.setPosition(0, 0,-10); } } 创建预制节点 和克隆已有节点相似，你可以设置一个预制（Prefab）并通过 instantiate 生成节点。使用方法如下： import { _decorator, Component, Prefab, instantiate, director } from 'cc'; const { ccclass, property } = _decorator; @ccclass(\"test\") export class test extends Component { @property({type:Prefab}) private target: Prefab = null; start(){ let scene = director.getScene(); let node = instantiate(this.target); node.parent = scene; node.setPosition(0,0,0); } } 销毁节点 通过 node.destroy() 函数，可以销毁节点。值得一提的是，销毁节点并不会立刻被移除，而是在当前帧逻辑更新结束后，统一执行。当一个节点销毁后，该节点就处于无效状态，可以通过 isValid 判断当前节点是否已经被销毁。 使用方法如下： import { _decorator, Component, Node } from 'cc'; const { ccclass, property } = _decorator; @ccclass(\"test\") export class test extends Component { @property({type:Node}) private target: Node = null; private positionz: number = -20; start(){ // 5秒后销毁节点 setTimeout(function () { this.target.destroy(); }.bind(this), 5000); } update(deltaTime: number){ console.info(this.target.isValid); this.positionz += 1*deltaTime; if (this.target.isValid) { this.target.setPosition(0.0,0.0,this.positionz); } } } destroy 和 removeFromParent 的区别 调用一个节点的 removeFromParent 后，它并不会从内存中释放，因为引擎内部仍会持有它的数据。因此如果一个节点不再使用，请直接调用它的 destroy 而不是 removeFromParent，否则会导致内存泄漏。 总之，如果一个节点不再使用，destroy 就对了，不需要 removeFromParent 也不需要设置 parent 为 null 哈。 "},"scripting/scheduler.html":{"url":"scripting/scheduler.html","title":"使用计时器","keywords":"","body":"使用计时器 在 Cocos Creator 3.0 中，我们为组件提供了方便的计时器。 也许有人会认为 setTimeout 和 setInterval 就足够了，开发者当然可以使用这两个函数，不过我们更推荐使用计时器，因为它更加强大灵活，和组件也结合得更好！ 下面来看看它的具体使用方式： 开始一个计时器 this.schedule(function() { // 这里的 this 指向 component this.doSomething(); }, 5); 上面这个计时器将每隔 5s 执行一次。 更灵活的计时器 // 以秒为单位的时间间隔 let interval = 5; // 重复次数 let repeat = 3; // 开始延时 let delay = 10; this.schedule(function() { // 这里的 this 指向 component this.doSomething(); }, interval, repeat, delay); 上面的计时器将在 10 秒后开始计时，每 5 秒执行一次回调，重复 3 + 1 次。 只执行一次的计时器（快捷方式） this.scheduleOnce(function() { // 这里的 this 指向 component this.doSomething(); }, 2); 上面的计时器将在两秒后执行一次回调函数，之后就停止计时。 取消计时器 开发者可以使用回调函数本身来取消计时器： this.count = 0; this.callback = function () { if (this.count == 5) { // 在第六次执行回调时取消这个计时器 this.unschedule(this.callback); } this.doSomething(); this.count++; } this.schedule(this.callback, 1); 注意：组件的计时器调用回调时，会将回调的 this 指定为组件本身，因此回调中可以直接使用 this。 下面是 Component 中所有关于计时器的函数： schedule：开始一个计时器 scheduleOnce：开始一个只执行一次的计时器 unschedule：取消一个计时器 unscheduleAllCallbacks：取消这个组件的所有计时器 这些 API 的详细描述都可以在我们的 API 文档中找到。 除此之外，如果需要每一帧都执行一个函数，请直接在 Component 中添加 update 函数，这个函数将默认被每帧调用，这在 生命周期文档 中有详细描述。 注意：Node 不包含计时器相关 API "},"scripting/component.html":{"url":"scripting/component.html","title":"组件和组件执行顺序","keywords":"","body":"组件和组件执行顺序 所有继承自 Component 的类都称为组件类，其对象称为组件，实现了 Cocos Creator 3.0 EC 系统中的组件概念。 组件类必须是 cc 类。 import { Component } from 'cc'; @ccclass(\"MyComponent\") class MyComponent extends Component { } 组件的创建和销毁 组件的生命周期完全由节点操控。与普通类对象不同，组件不能由构造函数创建： const component = new MyComponent(); // 错误：组件无法由构造函数创建 相反地，组件必须由节点来创建，通过如下方法将组件添加到节点上： const myComponent = node.addComponent(MyComponent); 当组件不再被需要的时候，可以调用 node.removeComponent(myComponent) 移除指定的组件并将其销毁。 import { Component } from 'cc'; @ccclass(\"MyComponent\") class MyComponent extends Component { constructor () { console.log(this.node.name); // 错误：组件并未附加到节点上 } public printNodeName () { console.log(this.node.name); } } const myComponent = node.addComponent(MyComponent); myComponent.printNodeName(); // 正确 node.removeComponent(myComponent); myComponent.printNodeName(); // 错误：组件已被该节点移除 组件执行顺序 使用统一的控制脚本来初始化其他脚本 项目中一般会有一个像 Game.ts 这样的脚本作为总的控制脚本，而其余脚本，像 Configuration.ts、GameData.ts 和 Menu.ts 三个组件，如果要在 Game.ts 里初始化，那么它们的初始化过程是这样的： // Game.ts import { _decorator, Component, Node } from 'cc'; const { ccclass, property } = _decorator; import { Configuration } from './Configuration'; import { GameData } from './GameData'; import { Menu }from './Menu'; @ccclass(\"Game\") export class Game extends Component { private configuration = Configuration; private gameData = GameData; private menu = Menu; onLoad () { this.configuration.init(); this.gameData.init(); this.menu.init(); } } 其中在 Configuration.ts、GameData.ts 和 Menu.ts 中需要实现 init 方法，并将初始化逻辑放进去。这样就可以保证 Configuration、GameData 和 Menu 的初始化顺序。 在 update 中用自定义方法控制更新顺序 同理如果要保证以上三个脚本的每帧更新顺序，也可以将分散在每个脚本里的 update 替换成自己定义的方法： //Configuration.ts static updateConfig (deltaTime: number) { } 然后在 Game.ts 脚本的 update 里调用这些方法： // Game.ts update (deltaTime: number) { this.configuration.updateConfig(deltaTime); this.gameData.updateData(deltaTime); this.menu.updateMenu(deltaTime); } 控制同一个节点上的组件执行顺序 在同一个节点上的组件执行顺序，可以通过组件在 属性检查器 里的排列顺序来控制，排列在上的组件会先于排列在下的组件执行。可以通过组件右上角的齿轮按钮里的 Move Up 和 Move Down 菜单来调整组件的排列顺序，即执行顺序。 假如有两个组件 CompA 和 CompB，它们的内容分别是： // CompA.ts import { _decorator, Component, Node } from 'cc'; const { ccclass, property } = _decorator; @ccclass(\"CompA\") export class CompA extends Component { onLoad () { console.log('CompA onLoad!'); } start () { console.log('CompA start!'); } update (deltaTime: number) { console.log('CompA update!'); } } // CompB.ts import { _decorator, Component, Node } from 'cc'; const { ccclass, property } = _decorator; @ccclass(\"CompB\") export class CompB extends Component { onLoad () { console.log('CompB onLoad!'); } start () { console.log('CompB start!'); } update (deltaTime: number) { console.log('CompB update!'); } } 组件顺序 CompA 在 CompB 上面时，输出： CompA onLoad! CompB onLoad! CompA start! CompB start! CompA update! CompB update! 在 属性检查器 里通过 CompA 组件右上角设置菜单里的 Move Down 将 CompA 移到 CompB 下面后，输出： CompB onLoad! CompA onLoad! CompB start! CompA start! CompB update! CompA update! 设置组件执行优先级 如果以上方法还是不能提供所需的控制粒度，还可以直接设置组件的 executionOrder。executionOrder 会影响组件生命周期回调执行的优先级。executionOrder 越小，该组件相对其它组件就会越先执行。executionOrder 默认为 0，因此设置为负数的话，就会在其它默认的组件之前执行。设置方法如下： //Configuration.ts import { _decorator, Component, Node } from 'cc'; const { ccclass, executionOrder } = _decorator; @ccclass(\"Configuration\") @executionOrder(-1) export class Configuration extends Component { onLoad () { console.log('Configuration onLoad!'); } } // Menu.ts import { _decorator, Component, Node } from 'cc'; const { ccclass, executionOrder } = _decorator; @ccclass(\"Menu\") @executionOrder(1) export class Menu extends Component { onLoad () { console.log('Menu onLoad!'); } } 通过如上方法设置，Configuration.ts 的 onLoad 会在 Menu.ts 的 onLoad 方法之前执行。 注意：executionOrder 只对 onLoad、onEnable、start、update 和 lateUpdate 有效，对 onDisable 和 onDestroy 无效。 "},"scripting/scene-managing.html":{"url":"scripting/scene-managing.html","title":"加载和切换场景","keywords":"","body":"加载和切换场景 在 Cocos Creator 3.0 中，我们使用场景文件名（不包含扩展名）来索引指代场景。并通过以下接口进行加载和切换操作： director.loadScene(\"MyScene\"); 除此之外，从 v2.4 开始 Asset Bundle 还增加了一种新的加载方式： bundle.loadScene('MyScene', function (err, scene) { director.runScene(scene); }); Asset Bundle 提供的 loadScene 只会加载指定 bundle 中的场景，并不会自动运行场景，还需要使用 director.runScene 来运行场景。loadScene 还提供了更多参数来控制加载流程，开发者可以自行控制加载参数或者在加载完场景后做一些处理。 更多关于加载 Asset Bundle 中的场景，可参考文档 Asset Bundle。 通过常驻节点进行场景资源管理和参数传递 引擎同时只会运行一个场景，当切换场景时，默认会将场景内所有节点和其他实例销毁。如果我们需要用一个组件控制所有场景的加载，或在场景之间传递参数数据，就需要将该组件所在节点标记为「常驻节点」，使它在场景切换时不被自动销毁，常驻内存。我们使用以下接口： game.addPersistRootNode(myNode); 上面的接口会将 myNode 变为常驻节点，这样挂在上面的组件都可以在场景之间持续作用，我们可以用这样的方法来储存玩家信息，或下一个场景初始化时需要的各种数据。 需要注意的是，目标节点必须为位于层级的根节点，否则设置无效。 如果要取消一个节点的常驻属性： game.removePersistRootNode(myNode); 需要注意的是上面的 API 并不会立即销毁指定节点，只是将节点还原为可在场景切换时销毁的节点。 场景加载回调 加载场景时，可以附加一个参数用来指定场景加载后的回调函数： director.loadScene(\"MyScene\", onSceneLaunched); 上一行里 onSceneLaunched 就是声明在本脚本中的一个回调函数，在场景加载后可以用来进一步的进行初始化或数据传递的操作。 由于回调函数只能写在本脚本中，所以场景加载回调通常用来配合常驻节点，在常驻节点上挂载的脚本中使用。 预加载场景 director.loadScene 会在加载场景之后自动切换运行新场景，有些时候我们需要在后台静默加载新场景，并在加载完成后手动进行切换。那就可以预先使用 preloadScene 接口对场景进行预加载： director.preloadScene(\"table\", function () { console.log('Next scene preloaded'); }); 之后在合适的时间调用 loadScene，就可以真正切换场景。 director.loadScene(\"table\"); 就算预加载还没完成，你也可以直接调用 director.loadScene，预加载完成后场景就会启动。 "},"scripting/load-assets.html":{"url":"scripting/load-assets.html","title":"获取和加载资源","keywords":"","body":"获取和加载资源 Cocos Creator 3.0 采用与 Cocos Creator v2.x 统一的资源管理机制，在本篇教程，我们将介绍： 资源属性的声明 如何在 属性检查器 里设置资源 动态加载资源 加载远程资源和设备资源 资源的依赖和释放 资源属性的声明 在 Cocos Creator 3.0 中，所有继承自 Asset 的类型都统称资源，如 Texture2D、SpriteFrame、AnimationClip、Prefab 等。它们的加载是统一并且自动化的，相互依赖的资源能够被自动预加载。 例如，当引擎在加载场景时，会先自动加载场景关联到的资源，这些资源如果再关联其它资源，其它也会被先被加载，等加载全部完成后，场景加载才会结束。 脚本中可以这样定义一个 Asset 属性： //test.ts import { _decorator, Component, Node, SpriteFrame } from 'cc'; const { ccclass, property } = _decorator; @ccclass(\"test\") export class test extends Component { @property({type: SpriteFrame}) private spriteFrame: SpriteFrame = null; } 如何在属性检查器里设置资源 只要在脚本中定义好类型，就能直接在 属性检查器 很方便地设置资源。假设我们创建了这样一个脚本： //test.ts import { _decorator, Component, Node, SpriteFrame, Texture2D } from 'cc'; const { ccclass, property } = _decorator; @ccclass(\"test\") export class test extends Component { @property({type: Texture2D}) private texture: Texture2D = null; @property({type: SpriteFrame}) private spriteFrame: SpriteFrame = null; } 将它添加到节点后，在 属性检查器 中是这样的： 接下来我们从 资源管理器 里面分别将一个 Texture 和一个 SpriteFrame 拖到 属性检查器 的对应属性中： 结果如下： 这样就能在脚本里直接拿到设置好的资源： start () { let spriteFrame = this.spriteFrame; let texture = this.texture; } 在 属性检查器 里设置资源虽然很直观，但资源只能在场景里预先设好，没办法动态切换。如果需要动态切换，你需要看看下面的内容。 动态加载 关于动态加载，请参考 动态加载资源 "},"scripting/tsconfig.html":{"url":"scripting/tsconfig.html","title":"tsconfig 配置","keywords":"","body":"tsconfig 项目中 tsconfig.json 的 绝大多数 编译选项并不影响 Cocos Creator 对 TypeScript 的编译。因此，你需要小心配置其中的某些选项，以使得 IDE 的检查功能和 Cocos Creator 的编译行为一致。 以下选项不应当显式修改： compilerOptions.target compilerOptions.module 例如，若将 tsconfig.json 设置为： { \"compilerOptions\": { \"target\": \"es5\", \"module\": \"cjs\" } } 那么以下脚本代码在（使用 tsc 作为检查器的）IDE 中不会引起错误，因为 compilerOptions.module 设置为了 cjs。 const myModule = require(\"path-to-module\"); 然而 Cocos Creator 隐含的 compilerOptions.module 是 es2015，因此在运行时可能会提示 \"require 未定义\" 等错误。 以下脚本代码对于 Cocos Creator 来说是合法的，但 IDE 可能会报告错误。因为 compilerOptions.target 设置为了 es5，而 Set 是 ES6 才引入的。 const mySet = new Set(); 对于其他选项，你可以自由修改。 例如，当你希望禁止你项目中所有 TypeScript 脚本对隐式 any 的使用，就可以在 tsconfig.json 中将 compilerOptions.noImplicitAny 设为 true。如此当你用 Visual Studio Code 等 IDE 检查该文件时就会收到相应的错误提示。 对于大多数项目而言，tsconfig.json 的某些选项是固定的。例如 compilerOptions.target、compilerOptions.module 以及 Cocos Creator 的类型声明文件位置等。 由于 tsc 的良好设计，extends 选项使得 tsconfig.json 可以是级联的。Cocos Creator 意识到了这一点，因此固定的 tsconfig 选项被放置在 {项目路径}/tmp/tsconfig.cocos.json 下，并由 Cocos Creator 管理。 于是，项目根路径下的 tsconfig 可以如下配置以共享这些固定选项： { extends: './tmp/tsconfig.cocos.json', compilerOptions: { /* 自定义的 tsconfig 选项 */ } } 所幸，当你创建新项目时，Creator 将会自动生成这样的 tsconfig。 "},"scripting/reference-class.html":{"url":"scripting/reference-class.html","title":"脚本进阶","keywords":"","body":"脚本进阶 在阅读到此章节时，默认您已经对脚本系统较为熟悉，包括装饰器等。否则，请参阅： 脚本基础 装饰器 实例化 通过脚本定义一个 Foo 类和 Bar 类，Foo 类需要使用 Bar 类定义的属性，此时可以在 Foo 类中将 Bar 类直接 new 出一个对象： class Foo { public bar: Bar = null;; constructor() { this.bar = new Bar(); } } let bar = new Foo(); 实例方法 实例方法请在原型对象中声明： class Foo { public text!: string; constructor() { this.text = \"this is sprite\" } // 声明一个名叫 \"print\" 的实例方法 print() { console.log(this.text); } } let obj = new Foo(); // 调用实例方法 obj.print(); 判断类型 需要做类型判断时，可以用 TypeScript 原生的 instanceof： class Sub extends Base { } let sub = new Sub(); console.log(sub instanceof Sub); //true console.log(sub instanceof Base); //true let base = new Base(); console.log(base instanceof Sub); // false 静态变量和静态方法 静态变量或静态方法可以用 static 声明： class Foo { static count = 0; static getBounds() { } } 静态成员会被子类继承，继承时 Creator 会将父类的静态变量 浅拷贝 给子类，因此： class Object { static count = 11; static range: { w: 100, h: 100 } } class Foo extends Object { } console.log(Foo.count); // 结果是 11，因为 count 继承自 Object 类 Foo.range.w = 200; console.log(Object.range.w); // 结果是 200，因为 Sprite.range 和 Object.range 指向同一个对象 如果不需要考虑继承，私有的静态成员也可以直接定义在类的外面： // 局部方法 doLoad(sprite) { // ... }; // 局部变量 let url = \"foo.png\"; class Sprite { public url = ''; load() { this.url = url; doLoad(this); }; }; 继承 父构造函数 注意：不论子类是否有定义构造函数，在子类实例化前，父类的构造函数都会被自动调用。 class Node { name: string; constructor() { this.name = \"node\"; } } class Sprite extends Node { constructor() { super(); // 子构造函数被调用前，父构造函数已经被调用过，所以 this.name 已经被初始化过了 console.log(this.name); // \"node\" // 重新设置 this.name this.name = \"sprite\"; } } let obj = new Sprite(); console.log(obj.name); // \"sprite\" 重写 所有成员方法都是虚方法，子类方法可以直接重写父类方法： class Shape { getName() { return \"shape\"; } }; class Rect extends Shape { getName () { return \"rect\"; } }; let obj = new Rect(); console.log(obj.getName()); // \"rect\" get/set 方法 如果在属性中定义了 get/set，那么在访问属性的时候，就能触发预定义的 get/set 方法。 get 在属性中定义 get 方法： @property get num() { return this._num; } @property private _num = 0; get 方法可以返回任意类型的值。 定义了 get 方法的属性可以显示在 属性检查器 中，可以在代码中直接访问。 class Sprite { @property get width() { return this._width; } @property private _width = 0; print(){ console.log(this.width); } }; 注意： 属性定义了 get 方法之后就不能被序列化，也就是 serializable 参数不可用。例如下面的写法，width 属性既不会在编辑器上显示，也不会序列化。 get width() { return this._width; } @property({ type: CCInteger, tooltip: \"The width of sprite\" }) private _width = 0; 定义了 get 方法的属性如果需要在编辑器中显示，需要定义 property。例如下面的写法，width 属性如果去掉 @property 就不会在编辑器上呈现，_width 属性会序列化。 @property get width() { return this._width; } @property({ type: CCInteger, tooltip: \"The width of sprite\" }) private _width = 0; 定义了 get 方法的属性本身是只读的，但返回的对象并不是只读的。开发者依然可以通过代码修改对象内部的属性，例如： get num() { return this._num; } @property private _num = 0; start() { console.log(this.num); } set 在属性中定义 set 方法： set width(value) { this._width = value } private _width = 0; start() { this.width = 20; console.log(this.width); } set 方法接收一个传入参数，这个参数可以是任意类型。set 方法一般和 get 方法一起使用： @property get width() { return this._width; } set width(value) { this._width = value; } @property private _width = 0; 注意：set 方法不定义属性。 "},"engine/event/":{"url":"engine/event/","title":"事件系统","keywords":"","body":"事件系统 事件系统是游戏开发过程中需要涉及到交互常用的功能。使用事件系统不仅可以将输入行为（例如：键盘、鼠标、触摸）以事件的形式发送到应用程序，也可以将游戏过程中的发生的，需要其他对象关注的事情通过事件的形式回应。例如：游戏胜利后需要打开结算或者奖励界面。 事件使用 事件需要通过注册获取监听。Cocos Creator 内置事件监听的方式包括： 节点系统事件 全局系统事件 "},"engine/event/event-emit.html":{"url":"engine/event/event-emit.html","title":"发射和监听事件","keywords":"","body":"监听和发射事件 监听事件 事件处理大多数是在节点（Node）中完成的。对于组件，可以通过访问节点 this.node 来注册和监听事件。监听事件可以通过 this.node.on() 函数来注册，方法如下： // 该事件监听每次都会触发，需要手动取消注册 xxx.on(type, func, target?); 其中 type 为事件注册字符串，func 为执行事件监听的回调，target 为事件接收对象。如果 target 没有设置，则回调里的 this 指向的就是当前执行回调的对象。 值得一提的是，事件监听函数 on 第三个参数 target，主要是绑定响应函数的调用者。以下两种调用方式，效果上是相同的 // 使用函数绑定 this.node.on(Node.EventType.MOUSE_DOWN, function ( event ) { this.enabled = false; }.bind(this)); // 使用第三个参数 this.node.on(Node.EventType.MOUSE_DOWN, (event) => { this.enabled = false; }, this); 除了使用 on 监听，我们还可以使用 once 方法。once 监听在监听函数响应后就会关闭监听事件。 事件取消 当我们不再关心某个事件时，我们可以使用 off 方法关闭对应的监听事件。 off 方法的使用方式有两种： // 取消对象身上所有注册的该类型的事件 xxx.off(type); // 取消对象身上该类型指定回调指定目标的事件 xxx.off(type, func, target); 需要注意的是，off 方法的参数必须和 on 方法的参数一一对应，才能完成关闭。 我们推荐的书写方法如下： import { _decorator, Component, Node } from 'cc'; const { ccclass } = _decorator; @ccclass(\"Example\") export class Example extends Component { onEnable () { this.node.on('foobar', this._sayHello, this); } onDisable () { this.node.off('foobar', this._sayHello, this); } _sayHello () { console.log('Hello World'); } } 事件派发 触发事件有两种方式：emit 和 dispatchEvent。两者的区别在于，后者可以做事件传递。我们先通过一个简单的例子来了解 emit 事件 // 事件派发的时候可以指定派发参数，参数最多只支持 5 个事件参数 xxx.emit(type, ...args); 事件参数说明 在触发事件时，我们可以在 emit 函数的第二个参数开始传递我们的事件参数。同时，在 on 注册的回调里，可以获取到对应的事件参数。 import { _decorator, Component, Node } from 'cc'; const { ccclass } = _decorator; @ccclass(\"Example\") export class Example extends Component { onLoad () { this.node.on('foo', (arg1, arg2, arg3) => { console.log(arg1, arg2, arg3); // print 1, 2, 3 }); } start () { let arg1 = 1, arg2 = 2, arg3 = 3; // At most 5 args could be emit. this.node.emit('foo', arg1, arg2, arg3); } } 需要说明的是，出于底层事件派发的性能考虑，这里最多只支持传递 5 个事件参数。所以在传参时需要注意控制参数的传递个数。 派发事件 上文提到了 dispatchEvent 方法，通过该方法派发的事件，会进入事件派发阶段。在 Cocos Creator 的事件派发系统中，我们采用冒泡派发的方式。冒泡派发会将事件从事件发起节点，不断地向上传递给它的父级节点，直到到达根节点或者在某个节点的响应函数中做了中断处理 event.propagationStopped = true。 在 v3.0 中，我们移除了 Event.EventCustom 类，如果要派发自定义事件，需要先实现一个自定义的事件类，该类继承自 Event 类，例如： // Event 由 cc 模块导入 import { Event } from 'cc'; class MyEvent extends Event { constructor(name: string, bubbles?: boolean, detail?: any) { super(name, bubbles); this.detail = detail; } public detail: any = null; // 自定义的属性 } 以上图为例，当我们从节点 c 发送事件 “foobar”，倘若节点 a，b 均做了 “foobar” 事件的监听，则事件会经由 c 依次传递给 b，a 节点。如： // 节点 c 的组件脚本中 this.node.dispatchEvent( new MyEvent('foobar', true, 'detail info') ); 如果我们希望在 b 节点截获事件后就不再传递事件，我们可以通过调用 event.propagationStopped = true 函数来完成。具体方法如下： // 节点 b 的组件脚本中 this.node.on('foobar', (event: MyEvent) => { event.propagationStopped = true; }); 注意：在发送用户自定义事件的时候，请不要直接创建 cc 内的 Event 对象，因为它是一个抽象类。 事件对象 在事件监听回调中，开发者会接收到一个 Event 类型的事件对象 event，propagationStopped 就是 Event 的标准 API，其它重要的 API 包含： API 名 类型 意义 type String 事件的类型（事件名）。 target Node 接收到事件的原始对象。 currentTarget Node 接收到事件的当前对象，事件在冒泡阶段当前对象可能与原始对象不同。 getType Function 获取事件的类型。 propagationStopped Boolean 是否停止传递当前事件。 propagationImmediateStopped Boolean 是否立即停止当前事件的传递，事件甚至不会被分派到所连接的当前目标。 系统内置事件 以上是通用的事件监听和发射规则，在 Cocos Creator 中，我们默认支持了一些系统内置事件，可以参考我们后续的文档来查看如何使用： 鼠标、触摸：可参考 系统与节点事件文档 键盘、重力感应：可参考 全局系统事件文档 "},"engine/event/event-builtin.html":{"url":"engine/event/event-builtin.html","title":"节点系统事件","keywords":"","body":"节点系统事件 如上一篇文档所述，Node 有一套完整的 事件监听和分发机制。在这套机制之上，我们提供了一些基础的节点相关的系统事件，这篇文档将介绍这些事件的使用方式。 Cocos Creator 支持的系统事件包含鼠标、触摸、键盘和重力传感四种，它们被称为 全局事件。本章节重点介绍与 UI 节点树相关联的鼠标和触摸事件，这些事件是被直接触发在 UI 相关节点上的，所以被称为节点事件。 节点事件遵守通用的注册方式，开发者既可以使用枚举类型也可以直接使用事件名来注册事件的监听器，在这里建议使用枚举的方式来注册事件，避免事件因为书写问题导致注册失败。 // 使用枚举类型来注册 node.on(Node.EventType.MOUSE_DOWN, (event) => { console.log('Mouse down'); }, this); // 使用事件名来注册 node.on('mouse-down', (event) => { console.log('Mouse down'); }, this); 鼠标事件类型和事件对象 鼠标事件在桌面平台才会触发，系统提供的事件类型如下： 举对象定义性 对应的事件名 事件触发的时机 Node.EventType.MOUSE_DOWN mouse-down 当鼠标在目标节点区域按下时触发一次。 Node.EventType.MOUSE_ENTER mouse-enter 当鼠标移入目标节点区域时，不论是否按下。 Node.EventType.MOUSE_MOVE mouse-move 当鼠标在目标节点区域中移动时，不论是否按下。 Node.EventType.MOUSE_LEAVE mouse-leave 当鼠标移出目标节点区域时，不论是否按下。 Node.EventType.MOUSE_UP mouse-up 当鼠标从按下状态松开时触发一次。 Node.EventType.MOUSE_WHEEL mouse-wheel 当鼠标滚轮滚动时。 鼠标事件（Event.EventMouse）的重要 API 请参考 鼠标事件 API（Event 标准事件 API 除外）。 触摸事件类型和事件对象 触摸事件在移动平台和桌面平台都会触发，开发者可以更好的在桌面平台调试，只需要监听触摸事件即可同时响应移动平台的触摸事件和桌面端的鼠标事件。系统提供的触摸事件类型如下： 枚举对象定义 对应的事件名 事件触发的时机 Node.EventType.TOUCH_START touch-start 当手指触点落在目标节点区域内时。 Node.EventType.TOUCH_MOVE touch-move 当手指在屏幕上移动时。 Node.EventType.TOUCH_END touch-end 当手指在目标节点区域内离开屏幕时。 Node.EventType.TOUCH_CANCEL touch-cancel 当手指在目标节点区域外离开屏幕时。 触摸事件（Event.EventTouch）的重要 API 请参考 触摸事件 API（Event 标准事件 API 除外）。 需要注意的是，触摸事件支持多点触摸，每个触点都会发送一次事件给事件监听器。 触摸事件的传递 触摸事件冒泡 触摸事件支持节点树的事件冒泡，以下图为例： 在图中的场景里，假设 A 节点拥有一个子节点 B，B 拥有一个子节点 C。开发者对 A、B、C 都监听了触摸事件（以下的举例都默认节点监听了触摸事件）。 当鼠标或手指在 C 节点区域内按下时，事件将首先在 C 节点触发，C 节点监听器接收到事件。接着 C 节点会将事件向其父节点传递这个事件，B 节点的监听器将会接收到事件。同理 B 节点会将事件传递给 A 父节点。这就是最基本的事件冒泡过程。需要强调的是，在触摸事件冒泡的过程中不会有触摸检测，这意味着即使触点不在 A B 节点区域内，A B 节点也会通过触摸事件冒泡的机制接收到这个事件。 触摸事件的冒泡过程与普通事件的冒泡过程并没有区别。所以，调用 event.propagationStopped = true; 可以主动停止冒泡过程。 同级节点间的触点归属问题 假设上图中 B、C 为同级节点，C 节点部分覆盖在 B 节点之上。这时候如果 C 节点接收到触摸事件后，就宣布了触点归属于 C 节点，这意味着同级节点的 B 就不会再接收到触摸事件了，即使触点同时也在 B 节点内。同级节点间，触点归属于处于顶层的节点。 此时如果 C 节点还存在父节点，则还可以通过事件冒泡的机制传递触摸事件给父节点。 不同 Canvas 的触点归属问题 不同 Canvas 之间的触点拦截是根据优先级决定的。在下图中的场景里，节点树里的 Canvas 1-5 对应图片显示的 priority 1-5。可以看出，即使 Canvas 节点 3、4、5 之间是按乱序排的，但是根据 Canvas 上的优先级（priority）关系，触点的响应先后顺序仍然是 Canvas5 -> Canvas4 -> Canvas3 -> Canvas2 -> Canvas1。只有在优先级相同的情况下，Canvas 之间的排序是按节点树的先后顺序进行。 将触摸或鼠标事件注册在捕获阶段 有时候我们需要父节点的触摸或鼠标事件先于它的任何子节点派发，比如 ScrollView 组件就是这样设计的。这时候事件冒泡已经不能满足我们的需求了，需要将父节点的事件注册在捕获阶段。 要实现这个需求，可以在给 node 注册触摸或鼠标事件时，传入第四个参数 true，表示 useCapture。例如： this.node.on(Node.EventType.TOUCH_START, this.onTouchStartCallback, this, true); 当节点触发 touch-start 事件时，会先将 touch-start 事件派发给所有注册在捕获阶段的父节点监听器，然后派发给节点自身的监听器，最后才到了事件冒泡阶段。 只有触摸或鼠标事件可以注册在捕获阶段，其他事件不能注册在捕获阶段。 事件拦截 正常的事件是会按照以上说明的方式去派发。但是如果节点身上带有 Button、Toggle 或者 BlockInputEvents 这几个组件的话，是会停止事件冒泡。还是看下图。图中有两个按钮，Canvas0 下的 priority 1 和 Canvas1 下的 priority 2。如果点击两个按钮的交汇处，也就是图中蓝色区域，会出现按钮 priority 2 成功接收到了触点事件，而按钮 priority 1 则没有。那是因为按上述的事件接收规则，按钮 priority 2 优先接收到了触点事件，并且对事件进行了拦截（event.propagationStopped = true），防止事件穿透。如果是非按钮节点，也可以通过添加 BlockInputEvents 组件来对事件进行拦截，防止穿透。 触摸事件举例 以下图举例，总结下触摸事件的传递机制。图中有 A、B、C、D 四个节点，其中 A、B 为同级节点。具体层级关系如下： 若触点在 A、B 的重叠区域内，此时 B 接收不到触摸事件，事件的传递顺序是 A -> C -> D 若触点在 B 节点内（可见的绿色区域），则事件的传递顺序是 B -> C -> D 若触点在 C 节点内，则事件的传递顺序是 C -> D 若以第 2 种情况为前提，同时 C D 节点的触摸事件注册在捕获阶段，则事件的传递顺序是 D -> C -> B Node 的其它事件 所有的 node 内置事件都可以通过 Node.EventType 获取事件名。 3D 节点事件 枚举对象定义 对应的事件名 事件触发的时机 TRANSFORM_CHANGED transform-changed 当变换属性修改时，会派发一个枚举值 TransformBit，根据枚举值定义修改的变换。 变换枚举值定义： 枚举值含义 对应的变换 TransformBit.NONE 属性无改变。 TransformBit.POSITION 节点位置改变。 TransformBit.ROTATION 节点旋转改变。 TransformBit.SCALE 节点缩放改变。 TransformBit.RS 节点旋转及缩放改变。 TransformBit.TRS 节点平移，旋转及缩放都改变。 2D 节点事件 枚举对象定义 对应的事件名 事件触发的时机 SIZE_CHANGED size-changed 当宽高属性修改时。宽高属性位于 UITransform 组件上。 ANCHOR_CHANGED anchor-changed 当锚点属性修改时。锚点属性位于 UITransform 组件上。 COLOR_CHANGED color-changed 当颜色属性修改时。颜色属性位于 UI 渲染组件上。 多点触摸事件 引擎有多点触摸事件的屏蔽开关，多点触摸事件默认为开启状态。对于不需要多点触摸的项目，可以通过以下代码关闭多点触摸。 macro.ENABLE_MULTI_TOUCH = false; 或者也可以通过 项目设置/Macro Config 进行配置。 暂停或恢复节点系统事件 暂停节点系统事件 // 暂停当前节点上注册的所有节点系统事件，节点系统事件包含触摸和鼠标事件。 // 如果传递参数 true，那么这个 API 将暂停本节点和它的所有子节点上的节点系统事件。 // example this.node.pauseSystemEvents(); 恢复节点系统事件 // 恢复当前节点上注册的所有节点系统事件，节点系统事件包含触摸和鼠标事件。 // 如果传递参数 true，那么这个 API 将恢复本节点和它的所有子节点上的节点系统事件。 // example this.node.resumeSystemEvents(); "},"engine/event/event-input.html":{"url":"engine/event/event-input.html","title":"全局系统事件","keywords":"","body":"全局系统事件 本篇教程，我们将介绍 Cocos Creator 的全局系统事件。 全局系统事件是指与节点树不相关的各种全局事件，由 systemEvent 来统一派发，目前支持了以下几种事件： 鼠标事件 触摸事件 键盘事件 设备重力传感事件 其中，鼠标事件与触摸事件同节点系统事件类似，只是在于作用的区域不同。接下来会围绕这几个事件做个说明。 节点事件和全局鼠标/触摸事件的区别 在开始这部分内容之前，希望大家先提前阅读一下 多分辨率适配方案，了解屏幕区域和 UI 显示区域。当监听全局鼠标/触摸事件的时候，所获取到的触点是基于屏幕区域（设备显示分辨率）左下角计算的。而 UI 节点监听获取到的触点，是将全局事件获取到的触点，转换到适配后的 UI 可视区域左下角计算出的点，这两个点是不一样的。全局触点比较适用于直接点击屏幕去操控 3D 节点的行为，而不需要为场景添加 UI 节点去做鼠标/触摸事件的监听。 如何定义输入事件 键盘、设备重力传感器此类全局事件是通过函数 systemEvent.on(type, callback, target) 注册的。 可选的 type 类型有: SystemEventType.KEY_DOWN（键盘按下） SystemEventType.KEY_UP（键盘释放） SystemEventType.DEVICEMOTION（设备重力传感） 键盘事件 事件监听器类型：SystemEventType.KEY_DOWN 和 SystemEventType.KEY_UP 事件触发后的回调函数： 自定义回调函数：callback(event); 回调参数： KeyCode：API 传送门 Event：API 传送门 import { _decorator, Component, Node, systemEvent, SystemEventType, EventKeyboard, macro } from 'cc'; const { ccclass } = _decorator; @ccclass(\"Example\") export class Example extends Component { onLoad () { systemEvent.on(SystemEventType.KEY_DOWN, this.onKeyDown, this); systemEvent.on(SystemEventType.KEY_UP, this.onKeyUp, this); } onDestroy () { systemEvent.off(SystemEventType.KEY_DOWN, this.onKeyDown, this); systemEvent.off(SystemEventType.KEY_UP, this.onKeyUp, this); } onKeyDown (event: EventKeyboard) { switch(event.keyCode) { case macro.KEY.a: console.log('Press a key'); break; } } onKeyUp (event: EventKeyboard) { switch(event.keyCode) { case macro.KEY.a: console.log('Release a key'); break; } } } 设备重力传感事件 事件监听器类型：SystemEventType.DEVICEMOTION 事件触发后的回调函数： 自定义回调函数：callback(event); 回调参数： Event：API 传送门 import { _decorator, Component, Node, systemEvent, SystemEventType, log } from 'cc'; const { ccclass } = _decorator; @ccclass(\"Example\") export class Example extends Component { onLoad () { systemEvent.setAccelerometerEnabled(true); systemEvent.on(SystemEventType.DEVICEMOTION, this.onDeviceMotionEvent, this); } onDestroy () { systemEvent.off(SystemEventType.DEVICEMOTION, this.onDeviceMotionEvent, this); } onDeviceMotionEvent (event: EventAcceleration) { log(event.acc.x + \" \" + event.acc.y); } } 具体使用方法可参考范例 event（GitHub | Gitee），包含了键盘、重力感应、单点触摸、多点触摸等功能的实现。 "},"engine/event/event-api.html":{"url":"engine/event/event-api.html","title":"事件 API","keywords":"","body":"全局与节点触摸和鼠标事件 API 鼠标事件 API 函数名 返回值类型 意义 getScrollY Number 获取滚轮滚动的 Y 轴距离，只有滚动时才有效。 getButton Number Event.EventMouse.BUTTON_LEFT 或 Event.EventMouse.BUTTON_RIGHT 或 Event.EventMouse.BUTTON_MIDDLE。 ｜ 全局鼠标事件 API 函数名 返回值类型 意义 getLocation Vec2 获取鼠标位置对象，对象包含 x 和 y 属性。 getLocationX Number 获取鼠标的 X 轴位置。 getLocationY Number 获取鼠标的 Y 轴位置。 getPreviousLocation Vec2 获取鼠标事件上次触发时的位置对象，对象包含 x 和 y 属性。 getDelta Vec2 获取鼠标距离上一次事件移动相对于左下角的距离对象，对象包含 x 和 y 属性。 getDeltaX Number 获取当前鼠标距离上一次鼠标移动相对于左下角的 X 轴距离。 getDeltaY Number 获取当前鼠标距离上一次鼠标移动相对于左下角的 Y 轴距离。 节点鼠标事件 API 函数名 返回值类型 意义 getUILocation Vec2 获取当前鼠标在 UI 窗口内相对于左下角的坐标位置，对象包含 x 和 y 属性。 getUILocationX Number 获取当前鼠标在 UI 窗口内相对于左下角的 X 轴位置。 getUILocationY Number 获取当前鼠标在 UI 窗口内相对于左下角的 Y 轴位置。 getUIPreviousLocation Vec2 获取上一次鼠标在 UI 窗口内相对于左下角的坐标位置，对象包含 x 和 y 属性。 getUIDelta Vec2 获取鼠标距离上一次事件移动在 UI 坐标系下的距离对象，对象包含 x 和 y 属性。 getUIDeltaX Number 获取当前鼠标距离上一次鼠标移动在 UI 窗口内相对于左下角的 X 轴距离。 getUIDeltaY Number 获取当前鼠标距离上一次鼠标移动在 UI 窗口内相对于左下角的 Y 轴距离。 触摸事件 API API 名 类型 意义 touch Touch 与当前事件关联的触点对象。 getID Number 获取触点的 ID，用于多点触摸的逻辑判断。 全局触摸事件 API 函数名 返回值类型 意义 getLocation Vec2 获取触点位置对象，对象包含 x 和 y 属性。 getLocationX Number 获取触点的 X 轴位置。 getLocationY Number 获取触点的 Y 轴位置。 getStartLocation Vec2 获取触点初始时的位置对象，对象包含 x 和 y 属性。 getPreviousLocation Vec2 获取触点事件上次触发时的位置对象，对象包含 x 和 y 属性。 getDelta Vec2 获取触点距离上一次事件移动的距离对象，对象包含 x 和 y 属性。 getDeltaX Number 获取触点距离上一次事件移动的 X 轴距离。 getDeltaY Number 获取触点距离上一次事件移动的 Y 轴距离。 节点触摸事件 API 函数名 返回值类型 意义 getUILocation Vec2 获取当前触点在 UI 窗口内相对于左下角的坐标位置，对象包含 x 和 y 属性。 getUILocationX Number 获取当前触点在 UI 窗口内相对于左下角的 X 轴位置。 getUILocationY Number 获取当前触点在 UI 窗口内相对于左下角的 Y 轴位置。 getUIStartLocation Vec2 获取初始触点在 UI 窗口内相对于左下角的位置对象，对象包含 x 和 y 属性。 getUIPreviousLocation Vec2 获取上一次触点在 UI 窗口内相对于左下角的坐标位置，对象包含 x 和 y 属性。 getUIDelta Vec2 获取当前触点距离上一次触点移动在 UI 窗口内相对于左下角的距离对象，对象包含 x 和 y 属性。 getUIDeltaX Number 获取当前触点距离上一次触点移动在 UI 窗口内相对于左下角的 X 轴距离。 getUIDeltaY Number 获取当前触点距离上一次触点移动在 UI 窗口内相对于左下角的 Y 轴距离。 "},"scripting/modules/":{"url":"scripting/modules/","title":"模块规范与示例","keywords":"","body":"模块规范与示例 所有的代码文件可以大致分为 插件脚本 和 模块 两种，该部分内容主要介绍模块相关。 模块 是 TypeScript/JavaScript 代码的一种组织方式，按照模块组织的代码一般又被非正式地称为 脚本/项目脚本。在 Cocos Creator 中，除 插件脚本 外所有代码都以模块的形式组织，根据来源的不同，大致分为： 项目中创建的代码，包括 组件脚本 和 项目类（非组件）脚本； 引擎提供的功能，详情请参考 引擎模块； 第三方模块，例如 npm 模块。详情请参考 外部模块使用案例。 Cocos Creator 原生支持并推荐使用 ECMAScript 模块格式（简称 ESM 模块格式）。为了支持对外部模块的使用，Cocos Creator 也在某种限度上支持了 CommonJS 模块格式。关于 Creator 中模块的格式及使用，详情请参考 模块规范。 模块加载顺序 模块加载顺序如下： 首次导入 Cocos Creator 3.x 的 引擎模块 \"cc\"。 插件脚本：所有插件脚本将按照指定的插件脚本依赖关系顺序执行，不存在依赖关系的插件脚本之间是无序的。详情可参考 插件脚本。 普通脚本：所有普通脚本将被并发导入。导入时将严格遵循由 import 确定的引用关系和执行顺序。 "},"scripting/modules/engine.html":{"url":"scripting/modules/engine.html","title":"引擎模块","keywords":"","body":"引擎模块 引擎通过模块向开发者暴露功能接口，模块以 ECMAScript 模块形式存在。 ⚠️ 注意，从 3.0 开始，将不能通过全局变量 cc 访问引擎功能！ 功能 模块 'cc' 提供了所有引擎功能的访问。模块 'cc' 的内容是动态的，其内容和 项目设置 中的 功能裁剪 设置有关。 引擎日志输出 示例： import { log } from 'cc'; log('Hello world!'); 构建时常量 引擎模块 'cc/env' 暴露了一些构建时的 常量，这些常量代表执行环境、调试级别或平台标识等。 由于这些常量都以 const 声明，提供了很好的代码优化机会。 执行环境 名称（类型都为 boolean） 说明 BUILD 是否正在构建后的环境中运行 PREVIEW 是否正在预览环境中运行 EDITOR 是否正在编辑器环境中运行 调试级别 名称（类型都为 boolean） 说明 DEBUG 是否处于调试模式。仅当构建时未勾选调试选项的情况下为 false，其它情况下都为 true DEV 等价于 DEBUG/EDITOR/PREVIEW 平台标识 下表列出的常量表示是否正在 某一个 或 某一类 平台上运行，常量的类型都是 boolean。 名称 代表平台 MINIGAME “小游戏” RUNTIME_BASED 基于 Cocos Runtime SUPPORT_JIT 支持 JIT HTML5 Web ❌ ❌ ❌ NATIVE 原生平台 ❌ ❌ ❌ ALIPAY 支付宝小游戏 ✔️ ❌ ✔️ BAIDU 百度小游戏 ✔️ ❌ ✔️ BYTEDANCE 字节跳动小游戏 ✔️ ❌ ✔️ WECHAT 微信小游戏 ✔️ ❌ ✔️ XIAOMI 小米快游戏 ✔️ ❌ ✔️ COCOSPLAY Cocos Play ❌ ✔️ ✔️ HUAWEI 华为快游戏 ❌ ✔️ ✔️ OPPO OPPO 小游戏 ❌ ✔️ ✔️ VIVO vivo 小游戏 ❌ ✔️ ✔️ 调试模式下的输出 示例如下： import { log } from 'cc'; import { DEV } from 'cc/env'; if (DEV) { log('I am in development mode!'); } "},"scripting/modules/example.html":{"url":"scripting/modules/example.html","title":"外部模块使用案例","keywords":"","body":"示例：外部模块使用案例 本章节通过案例讲解如何在 Cocos Creator 项目中使用 npm 模块，如果不知道 npm 该如何获取，请参考 获取 npm 包。 ESM 与 CJS 交互规则 Cocos Creator 3.x 如何使用 npm，最大的问题在于 ESM 与 CJS 模块交互。如果还不了解这两个模块在 Cocos Creator 里是如何定义的，请查看 模块 一节。其实，ESM 和 CJS 模块的交互方式在 Node.js 官方文档 就有提到。在这里我简单的概括以下几点： CommonJS 模块由 module.exports 导出，在导入 CommonJS 模块时，可以使用 ES 模块默认的导入方式或其对应的 sugar 语法形式导入。 import { default as cjs } from 'cjs'; // 语法糖形式 import cjsSugar from 'cjs'; console.log(cjs); // console.log(cjs === cjsSugar); // true ESM 模块的 default 导出指向 CJS 模块的 module.exports。 非 default 部分的导出，Node.js 通过静态分析将其作为独立的 ES 模块提供。 接下来看一个代码片段： // foo.js module.exports = { a: 1, b: 2, } module.exports.c = 3; // test.mjs // default 指向 module.exports import foo from './foo.js'; // 等价于 import { default as foo } from './foo.js' console.log(JSON.stringify(foo)); // {\"a\":1,\"b\":2,\"c\":3} // 导入 foo 模块的所有导出 import * as module_foo from './foo.js' console.log(JSON.stringify(module_foo)); // {\"c\":3,\"default\":{\"a\":1,\"b\":2,\"c\":3}} import { a } from './foo.js' console.log(a); // Error: a is not defined // 根据上方第三点，c 有独立导出 import { c } from './foo.js' console.log(c); // 3 npm 模块使用案例 案例一：protobufjs 使用 首先，需要获取到 protobufjs 包。在项目目录下打开终端，执行 npm i protobufjs。如果这个项目属于多人协作，甚至可以把 protobufjs 这个包作为依赖写入 package.json，通过在上述命名行里加入 npm install --save protobufjs 即可利用命令行自动写入到 package.json 中。执行完之后，就可以在项目录下的 node_module 文件夹里查找到 protobufjs 相关文件夹。 有了 protobufjs 模块包之后。其次，判断模块格式。 查看 package.json 文件里的 main 字段，判定入口文件 index.js； 查看 package.json 文件里的 type 字段，观察到没有 type 字段； 鉴别模块格式，可以推断出，这是一个 CJS 模块。顺便一提，在包里是能看到每一个 js 文件都对应一个 .d.ts 文件，说明 protobufjs 包里自带了 TypeScript 声明文件，方便导入 protobufjs 模块后可以通过代码提示获取内部接口。 接着，在 index.js 可以看到它导出写法。 \"use strict\"; module.exports = require(\"./src/index\"); 确定了模块格式和导出方式。接下来，就是脚本资源里如何使用 protobufjs 这个模块了。 首先，在 assets 下创建一个 test.ts 脚本。接着，在脚本的头部写入下列代码： // 大部分 npm 模块都可以通过直接导入模块名的方式来使用。 import protobufjs from 'protobufjs'; console.log(protobufjs); 在 Chrome 运行后，控制台输出如下： 可能有部分同学，在书写 import protobufjs from 'protobufjs' 时就已经报红，提示模块没有默认导出（has no default export），这是因为 CJS 没有 default 导出，而 ESM 和 CJS 交互的时候是将 module.exports 视为 export default，并不是代表 CJS 模块具备真实默认导出。因此，如果要保持原来的写法，可以对 TypeScript 进行配置，具体请查看 TypeScript 配置。 接下来，就可以直接使用 protobufjs 提供的所有模块了。当然，如果只需要特定子模块功能，例如 light 和 minimal，可以直接导入包中的子路径。 // 使用 light 版本 import protobuf from 'protobufjs/light.js'; // 使用 minimal 版本 import protobuf from 'protobufjs/minimal.js'; 注意：就 protobufjs 和许多经典的 npm 包而言，当导入包中的子路径时，后缀是需要的。详情请参考 Cocos Creator 模块规范。 TypeScript 配置 当在 TypeScript 里导入没有默认导出的模块时，通常会出现 Module '\"/${project_path}/protobufjs\"' has no default export.。这是因为目前 protobufjs 仅提供了 CommonJS 模块，而 Cocos Creator 是通过 “默认导入” 来访问 CommonJS 模块的，但是 CommonJS 模块确实没有 “默认导出” 这种说法。此时，可以通过编辑项目目录中的 tsconfig.json 文件，将 \"compilerOptions\" 字段中的 \"allowSyntheticDefaultImports\" 选项设置为 true。如果没有该字段，可以自行补上。 { /* Base configuration. Do not edit this field. */ \"extends\": \"./temp/tsconfig.cocos.json\", \"compilerOptions\": { \"allowSyntheticDefaultImports\": true, // 需要开启 } } 案例二：将 protobuf 中的 proto 文件编译成 JavaScript 文件 本节主要讲述如何将 proto 文件编译成 JavaScript 文件。其实在翻阅 protobufjs 文档的时候，可以发现它自身有提供 命令行工具 转换静态模块以及 ts 声明文件。本次以新建一个 3.0 的空项目 example 为例，演示整个流程。 首先，通过 npm 安装 protobufjs 并将它写入项目目录下的 package.json 的依赖项。 其次，在项目目录下新建 Proto 目录并定义几个 proto 文件。 // pkg1.proto package pkg1; syntax = \"proto2\"; message Bar { required int32 bar = 1; } // pkg2.proto package pkg2; syntax = \"proto2\"; message Baz { required int32 baz = 1; } // unpkg.proto 不属于任何的包 syntax = \"proto2\"; message Foo { required int32 foo = 1; } 接着，在 package.json 中定义。 \"scripts\": { \"build-proto:pbjs\": \"pbjs --dependency protobufjs/minimal.js --target static-module --wrap commonjs --out ./Proto.js/proto.js ./Proto/*.proto\", \"build-proto:pbts\": \"pbts --main --out ./Proto.js/proto.d.ts ./Proto.js/*.js\" }, 其中，第一段指令 build-proto:pbjs 的大致意思是将 proto 文件编译成 js。--dependency protobufjs/minimal.js 这一块参数其实是因为执行时 require 到了 protobufjs，但是我们需要用的只是它的子模块 minimal.js。然后，将 js 生成到 Proto.js 文件夹中（注意：如果没有 Proto.js 文件夹，需手动创建）。第二段指令 build-proto:pbts 则是根据第一段的输出来生成类型声明文件。 根据以上步骤则成功完成了 proto 文件转换成 js 文件的过程。接着，可以在项目 assets 下脚本里引入 js 文件。 import proto from '../Proto.js/proto.js'; console.log(proto.pkg1.Bar); 此处还是要声明一下，如果有同学在导入的时候出现报红现象，提示 proto 没有默认导出，解决方案有两种。 通过向 tsconfig.json 增加允许对包含默认导出的模块使用默认导入字段来解决 \"compilerOptions\": { \"allowSyntheticDefaultImports\": true, } 增加默认导出 在项目目录下创建一个 Tools/wrap-pbts-result.js 文件，脚本代码如下： const fs = require('fs'); const ps = require('path'); const file = ps.join(__dirname, '..', 'Proto.js', 'proto.d.ts'); const original = fs.readFileSync(file, { encoding: 'utf8' }); fs.writeFileSync(file, ` namespace proto { ${original} } export default proto; `); 将原来的 build-proto:pbts 命令改为： \"build-proto:pbts\": \"pbts --main --out ./Proto.js/proto.d.ts ./Proto.js/*.js && node ./Tools/wrap-pbts-result.js\" 最终，就可以直接运行了。完整项目内容请参考：npm-case。 注意：打包出来的 js 文件即可以放在项目 assets 目录下，也可以放在项目其它位置。assets 目录下的 js 文件不再需要勾选导出为插件，请各位悉知。 案例三：lodash-es 使用 同 案例一：protobufjs 使用 方法类似，安装 lodash-es 包。得知入口文件是 lodash.js，入口文件里也自动帮忙将其下所有子模块以 ESM 模块格式导出，再根据 type 也印证了当前是 ESM 模块。因此，可以直接导入任何模块。还是以 assets 下的 test.ts 脚本资源为例，引入 lodash 内的子模块。 import { array, add } from 'lodash-es'; 此时，会发现代码层面会报错，但是实际却能够运行。这是因为，两者在语言类型上就有明显区分，JavaScript 是动态类型，TypeScript 是静态类型，因此，在使用 js 脚本的时候，是无法获知导出模块的具体类型的，此时最好的办法就是声明一份类型定义文件 .d.ts。幸运的是，但我们将鼠标移到报错处的时候，有提示可以通过执行 npm i --save-dev @types/lodash-es 来安装 lodash 模块的类型声明文件。安装完之后，重启 VS Code 就会发现报错消失了，同时还有了代码提示。 案例四：web3 使用 根据上述 protobufjs 案例，以同样的方式安装 web3 包。利用相同检测方法，判定 web3 为 CJS 模块。根据同样方式导入： import web3 from 'web3'; 回到编辑器后发现，还是出现了如下一大堆报错： 这是因为该包是专门为 Node 定制的，内部引用了 Node.js 的内置模块，这些模块是无法在 Creator 里使用导致了报错。通常这些包也会兼顾 Web 用户。当我们直接导入该包的时候，包的入口直接指向的是 Node 版本，而把 Web 版本放在包下的 dist/**.js 或者 dist/**.min.js 文件里。针对这种情况就需要对症下药，导入包里提供的 Web 定制版本： import web3 from 'web3/dist/web3.min.js'; 这时候发现编辑器不报错了，但是代码提示：Could not find a declaration file for module 'web3/dist/web3.min.js'. '/${project_path}/node_modules/web3/dist/web3.min.js' implicitly has an 'any' type.。 这是因为即使这些包有类型说明，也是为那个入口的 Node 版本而做的类型说明。一般情况下，两个版本的接口定义是一样的，因此我们只要 “借用” Node 版本的类型说明就好了。就是任意新建个 .d.ts 到项目里，写： // 为模块 \"/dist/**.js\" 补充类型说明 declare module \"/dist/**.js\" { export * from \"\"; // “偷” 主入口的类型说明 } 注意：是不是每用一个包都得确认它是为谁而做？目前确实是的。这种情况正在改善，因为在新版的 Node 里，package.json 有加入一个很好的机制来告诉用户什么情况应该使用哪个版本。 特殊案例：firebase 使用 这个案例是一个较为特殊的案例，接着，了解一下这个案例的特殊性。根据上述方式安装好 firebase 包，根据 package.json 文件对包进行分析，可以得出这个包采用是 CJS 格式。根据入口文件，可以推断为此包是为 Node 定制的（这个可以根据 案例四：web3 使用 方式测试），因此，得选用 Web 定制版本 index.esm.js。神奇的地方就在这里，index.esm.js 是一个 ESM 模块，Creator 里将这个包识别为 CJS 模块，但是它又是 ESM 模块，自然会导致出错。 针对这样的案例，目前还没有处理，建议的解决方案是用户自行通过 rollup 等打包工具，打包成一个独立的 js 文件作为 非 npm 模块使用。 "},"scripting/modules/spec.html":{"url":"scripting/modules/spec.html","title":"模块规范","keywords":"","body":"模块规范 模块格式 本节介绍了 Cocos Creator 如何决定一个模块的格式。 Cocos Creator 引擎提供的所有功能都以 ESM 模块的形式存在，见 引擎模块。 项目资源目录下以 .ts 作为后缀的文件。例如 assets/scripts/foo.ts。 对于任何其它模块格式，Cocos Creator 选择与 Node.js 类似的规则来 鉴别。具体地，以下文件将被视为 ESM 格式： 以 .mjs 为后缀的文件； 以 .js 为后缀的文件，并且与其最相近的父级 package.json 文件中包含一个顶级的 \"type\" 字段，其值为 \"module\"。 其余的文件将被视为 CommonJS 模块格式，这包括： 以 .cjs 为后缀的文件； 以 .js 为后缀的文件，并且与其最相近的父级 package.json 文件中包含一个顶级的 \"type\" 字段，其值为 \"commonjs\"。 不在上述条件下的以 .js 为后缀的文件。 模块说明符与模块解析 在 ESM 模块中，通过标准的导入导出语句与目标模块进行交互，例如： import { Foo } from './foo'; export { Bar } from './bar'; 导入导出语句中关键字 from 后的字符串称为 模块说明符。模块说明符也可作为参数出现在动态导入表达式 import() 中。 模块说明符用于指定目标模块，从模块说明符中解析出目标模块 URL 的过程称为 模块解析。 Cocos Creator 支持三种模块说明符： 相对说明符 像 './foo'、'../bar' 这样以 './' 和 '../' 开头的说明符。 绝对说明符 指定了一个 URL 的说明符。例如：foo:/bar。 裸说明符（Bare specifier）像 foo、foo/bar 这样既不是 URL 又不是相对说明符的说明符。 相对说明符 相对说明符以当前模块的 URL 为基础 URL，以相对说明符为输入来解析目标模块的 URL。 例如，对于模块 项目路径/assets/scripts/utils/foo 来说，'./bar' 将解析为同目录下的 项目路径/assets/scripts/utils/bar；'../baz' 将解析为上层目录中的 项目路径/assets/scripts/baz。 绝对说明符 绝对说明符直接指定了目标模块的 URL。 Cocos Creator 目前仅支持文件协议的 URL。但由于文件 URL 中指定的文件路径是绝对路径，因此很少使用。 值得注意的是，在 Node.js 中，一种访问 Node.js 内置模块的方法是通过 node: 协议的 URL，例如：node:fs。Cocos Creator 会将所有对 Node.js 内置模块的访问请求解析为 node: URL 请求，例如 import fs from 'fs' 中的 'fs' 将解析为 node:fs。但 Cocos Creator 并不支持 Node.js 内置模块，也就是说并不支持 node: 协议。因此会产生加载错误。当使用 npm 中的模块时，可能会遇到该错误。 裸说明符 目前为止，对于裸说明符，Cocos Creator 将应用 Node.js 模块解析算法。 这就包括了对 npm 模块的解析。 一般来说，裸说明符具有以下两种形式： 'foo' 解析为 npm 包 foo 的入口模块。 'foo/bar' 将解析为 npm 包 foo 中子路径 ./bar 下的模块。 裸说明符的具体解析规则可参考 Node.js 模块解析算法。 在后续，Cocos Creator 可能将支持导入映射（import maps），见 导入映射。 后缀与目录导入 Cocos Creator 对模块说明符中模块的后缀要求更偏向于 Web —— 必须指定后缀并且不支持 Node.js 式的目录导入。然而，基于历史原因和现行的一些限制，TypeScript 模块不允许给出后缀并支持 Node.js 式的目录导入。具体来说： 当目标模块文件的后缀是 .js、.mjs 时，模块说明符中 必须指定 后缀： import './foo.mjs'; // 正确 import './foo'; // 错误：无法找到指定模块 Node.js 式的目录导入是不支持的： import './foo/index.mjs'; // 正确 import './foo'; // 错误：无法找到模块。 这种后缀要求与对目录导入的限制同时应用到了相对说明符和绝对说明符。对于在裸说明符中的要求可参考 Node.js 模块解析算法。 但当目标模块文件的后缀是 .ts 时，模块说明符中 不允许指定 后缀： import './foo'; // 正确：解析为同目录下的 `foo.ts` 模块 import './foo.ts'; // 错误：无法找到指定模块 另一方面，支持 Node.js 式的目录导入： import './foo'; // 正确：解析为 `foo/index.ts` 模块 Cocos Creator 支持 Web 平台。在 Web 平台上实现 Node.js 那样复杂的模块解析算法成本是昂贵的，客户端和服务端之间无法通过频繁的通讯来尝试不同的后缀和文件路径。 即使通过一些后处理工具可以实现在构建阶段完成这样的复杂解析，但会造成静态导入解析（通过 import 语句）和动态导入解析（通过 import() 表达式）算法的不一致。因此在模块解析算法的选择上，我们更偏向于在代码中指定完整的文件路径。 但我们却无法完全限制这一点，因为就目前来说，TypeScript 中不允许在说明符中指定后缀为 .ts。并且 TypeScript 尚且不支持自动补全特定的目标后缀。在这些限制下，我们很难做到两全其美，但我们仍在观测这些条件在未来是否有好转。 未支持 browser 字段 有些 npm 包的清单文件 package.json 中记录了 browser 字段，例如 JSZip。browser 字段用于指定当该包在非 Node.js 环境下特有的模块解析方法，它可使得包中的某些专用于 Node.js 的模块被替换为能够在 Web 中使用的模块。虽然 Cocos Creator 不支持该字段，但如果对 npm 包有编辑的能力，Cocos Creator 推荐使用 条件化导出 和 子路径导入 来代替 browser 字段。 否则，可以以非 npm 的方式使用目标库。例如，将目标库中专为非 Node.js 环境制定的模块复制至项目中，再通过相对路径来导入。 CommonJS 模块解析 在 CommonJS 模块中，Cocos Creator 应用的是 Node.js CommonJS 模块解析算法。 模块格式交互 Cocos Creator 允许在 ESM 模块中导入 CommonJS 模块。 当从 ESM 模块中导入 CommonJS 模块时，CommonJS 模块的 module.exports 对象将作为 ESM 模块的默认导出： import { log } from 'cc'; import { default as cjs } from 'cjs'; // 上面导入语句的另一种写法： import cjsSugar from 'cjs'; log(cjs); log(cjs === cjsSugar); // 打印： // // true CommonJS 模块的 ECMAScript 模块命名空间 表示，是含有一个 default 导出的命名空间，其中的 default 导出就指向了 CommonJS 模块的 module.exports 的值。 该 模块命名空间外来对象 可以通过 import * as m from 'cjs' 来观察： import * as m from 'cjs'; console.log(m); // 打印： // [Module] { default: } Cocos Creator ESM 解析算法公示 Cocos Creator 用于解析 ESM 模块说明符的算法由以下的 CREATOR_ESM_RESOLVE 方法给出。它返回从当前 URL 解析模块说明符得到的 URL 结果。 在解析算法规范中，引用了外部的算法。 解析算法规范 CREATOR_ESM_RESOLVE(specifier, parentURL) Let resolved be the result of ESM_RESOLVE(specifier, parentURL). If both parentURL and resolved are under project assets directory, then Let extensionLessResolved be the result of TRY_EXTENSION_LESS_RESOLVE(resolved). If extensionLessResolved is not undefined, return extensionLessResolved. Return resolved. TRY_EXTENSION_LESS_RESOLVE(url) If the file at url exists, then Return url. Let baseName be the portion after the last \"/\" in pathname of url, or whole pathname if it does not contain a \"/\". If baseName is empty, then Return undefined. Let resolved be the result URL resolution of \"./\" concatenated with baseName and .ts, relative to parentURL. If the file at resolved exists, then Return resolved. Let resolved be the result URL resolution of \"./\" concatenated with baseName and /index.ts, relative to parentURL. If the file at resolved exists, then Return resolved. Return undefined. "},"scripting/external-scripts.html":{"url":"scripting/external-scripts.html","title":"插件脚本","keywords":"","body":"外部代码支持 注意：从 v3.0 开始，推荐使用 模块 代替插件脚本的使用！ 插件脚本 当脚本资源导入到 资源管理器 后，在 属性检查器 中设置了 导入为插件，此脚本资源便称为 插件脚本。插件脚本通常用于引入第三方库。目前仅支持 JavaScript 插件脚本。 与项目中的其它脚本不同，Creator 不会修改插件脚本的内容，但可能会插入一些代码以适配 Creator。特别地，Creator 将屏蔽全局变量 module、exports、define。 导入选项 许多第三方 JavaScript 库以全局变量的方式提供库的功能，这些库往往会写入全局变量 window、global、self 和 this 中，但这些全局变量不一定是跨平台的。为了方便，Creator 在导入插件脚本时，提供了 模拟全局变量 选项，开启后，Creator 将插入必要的代码以模拟这些全局变量，其效果类似于： (function() { const window = globalThis; const global = globalThis; const self = globalThis; (function() { /* 原始代码 */ }).call(this); }).call(this); 执行时机 开发者可以控制插件脚本在某些环境下是否执行。 选项 影响平台 备注 允许 Web 平台加载 浏览器、网页预览、编辑器 默认启用，禁用时会连带 允许编辑器加载 一起禁用 允许编辑器加载 编辑器 默认禁用，如果编辑器中的其它普通脚本加载过程中会依赖当前脚本，则需要 手动开启 这个选项。开启后，脚本内不在任何函数内声明的局部变量 不会 暴露成全局变量，所以全局变量需要用 window.abc = 0 的方式定义才能生效。 允许 Native 平台加载 原生平台、模拟器预览 默认启用 在导入检查器中，开发者可以指定依赖关系以确保脚本的执行顺序。 可用性与跨平台 插件脚本几乎会原封不动地拷贝到构建目录，因此插件脚本的可用性与跨平台性不受 Creator 保障。例如，当插件脚本使用了某些平台不支持的语言特性时将导致错误： 目标平台不提供原生 node.js 支持 例如很多 npm 模块都直接或间接依赖于 node.js，这样的话发布到原生或网页平台后是不能用的。 依赖 DOM API 的插件将无法发布到原生平台 网页中可以使用大量的前端插件，例如 jQuery，不过它们有可能依赖于浏览器的 DOM API。依赖这些 API 的插件不能用于原生平台中。 交互 插件脚本与非插件脚本无法以导入形式交互。举例来说，即使开发者知道其目标平台实际支持 CommonJS，也不能在非插件脚本中强行通过 require 相对路径进行使用。 因此，插件脚本一般以全局变量的方式（又称 IIFE 模块格式）来通讯，但需要注意以下几点： 谨慎使用全局变量，当开发者要用全局变量时，应该清楚自己在做什么，我们并不推荐滥用全局变量，即使要用也最好保证全局变量为 只读 状态。 添加全局变量时，请小心不要和系统已有的全局变量重名。 开发者可以在插件脚本中自由封装或者扩展 Cocos Creator 引擎，但这会提高团队沟通成本，导致脚本难以复用。 "},"editor/publish/":{"url":"editor/publish/","title":"跨平台发布","keywords":"","body":"跨平台发布游戏 Cocos Creator 目前支持发布游戏到 Web、iOS、Android、Windows、Mac，以及各类小游戏平台，真正实现一次开发，全平台运行。 准备工作 在项目正常开发，预览效果达到要求的情况下，可以将游戏发布到多个平台。在发布之前需要做的准备工作包括： 熟悉构建发布面板 了解通用构建选项 发布平台 目前 Cocos Creator 支持发布到 Web、原生和小游戏平台，详情请参考： 发布到 Web 平台 发布到原生平台 发布到小游戏平台 开发者还可以通过命令行发布项目，详情请参考 命令行发布项目。 进阶 如果对构建流程有了一定程度上的熟悉和了解，就可以自定义构建模板、扩展构建流程等。详情可参考以下文档： 构建流程简介与常见错误处理 定制项目的构建模版 扩展构建流程 "},"editor/publish/build-panel.html":{"url":"editor/publish/build-panel.html","title":"熟悉构建发布面板","keywords":"","body":"构建发布面板详解 点击编辑器主菜单中的 项目 -> 构建发布 或者使用快捷键 Ctrl/Cmd + Shift + B 即可打开 构建发布 面板： 若已经构建过某一平台，则打开 构建发布 面板会进入 构建任务 页面。v3.0 各个平台的构建是以构建任务的形式进行，类似于下载任务： 构建发布面板 在 构建发布 面板选择需要构建的平台，然后配置 构建选项。配置完成后，点击右下角的 构建 按钮即可跳转到 构建任务 页面执行构建流程。或者点击右上角的 关闭（X） 按钮也可以进入 构建任务 页面。 构建发布 面板上方有三个功能按钮： ：点击该按钮即可跳转到当前平台的官方手册文档。 Import：点击该按钮即可导入保存了构建选项配置的 json 文件。 Export：点击该按钮可将当前平台的构建选项配置导出为 json 文件，用于 命令行构建，也可以在项目成员之间共享构建选项配置。导出的配置是按照平台区分的，使用命令行构建时，将构建参数 configPath 的文件路径指定为导出的 json 配置文件路径即可。 仅导出构建面板参数：仅导出当前平台在 构建发布 面板的配置。 包括参与构建的当前项目设置：导出 构建发布 面板的配置以及主菜单 项目 -> 项目设置 中参与构建流程的配置。 注意： 构建没有场景的项目是没有意义的，所以如果当前打开的项目没有场景，则打开 构建发布 面板时会提示请先创建场景： 在构建之前，请确保当前的场景已经保存，否则点击 构建 按钮时将会弹框提示，可以选择 保存、忽略 或者 取消构建。选择 保存 和 忽略 都会继续执行构建流程。 构建任务页面 在 构建任务 页面可以查看当前平台的构建进度及构建结果。 正在构建中：进度条显示为 蓝色。 构建成功：进度条到达 100%，输出实际构建时间并显示为 绿色。 构建失败：进度条到达 100%，提示构建失败原因或者报错信息，并显示为 红色。 该页面上方有三个按钮，包括 新建构建任务、打开构建调试工具 和 清空构建缓存： 新建构建任务：点击该按钮即可返回 构建发布 面板，选择新的平台进行构建。 ：打开构建调试工具，点击该按钮即可打开构建调试工具，查看在构建过程中产生的全部日志信息包括调用栈。 ：清空构建缓存。为了复用可被重复利用的构建结果，以便重新构建时加快构建速度、降低内存占用等，构建过程中的很多处理都添加了缓存管理机制，例如压缩纹理、自动图集生成、引擎编译、资源序列化 JSON 等。正常情况下这部分缓存数据是不需要手动清理的，但如果是在特殊情况下需要避免缓存干扰，可以点击该按钮来清空缓存数据。 项目相关的资源缓存会存储在项目目录下，引擎编译相关的缓存则存储在全局目录下，开发者可根据自己的需要选择清空项目缓存、全局缓存，或者全部清空。 平台构建任务 各个平台的构建是以构建任务的形式进行，类似于下载任务。平台构建任务的名称取决于 构建发布 面板中的 发布路径 选项，具体可查看 构建选项 文档。 每个构建任务都配置了相应的功能按钮方便使用。 构建任务右上方的移除（X）按钮 用于移除当前构建任务，可选择 仅移除构建记录 或者 删除源文件。删除源文件 即删除对应平台构建后生成在 build 目录下的项目发布包。 构建任务左下方的按钮包括： ：点击该按钮即可打开对应平台构建后生成的项目发布包（默认在 build 目录下）。 ：点击该按钮即可返回 构建发布 面板，修改对应平台上一次构建时配置的构建选项，然后点击右下方的 构建 按钮重新构建。详情请参考下方 修改构建选项 部分的内容。 ：点击该按钮即可返回 构建发布 面板，查看对应平台上次构建时配置的构建选项。 ：点击该按钮即可打开对应平台在构建过程中产生的日志文件。更多内容请参考下方 构建日志信息查看 部分的内容。 构建任务右下方的按钮，主要用于各个平台在构建完成后根据平台要求执行生成、运行、上传等发布流程。Build 按钮则是用于重新构建。 各个平台完成构建后，与构建相关的构建选项配置信息都会保存在项目目录下的 profiles/v2/packages/builder.json 文件中，只要没有在 构建任务 页面删除对应平台的构建任务或者删除 build 目录下的项目发布包，就可以在重新打开编辑器后查看上次构建时的构建选项配置，以及继续运行预览等。 各个平台具体的发布流程，可参考： 发布到原生平台 发布到小游戏平台 修改构建选项 点击构建任务左下方的编辑按钮，即可返回 构建发布 面板修改上次构建时配置的构建选项，以便重新构建。因为只能修改当前平台上一次构建时的构建选项配置，所以页面中的 发布平台 项为置灰状态，不可修改。 当前平台上一次构建时的构建选项配置可点击编辑按钮右侧的 按钮查看。 修改完成后点击 构建 按钮就会清空上次构建后生成的项目发布包并重新构建。或者点击 构建发布 面板右上方的 X 按钮返回 构建任务 页面，再点击平台构建任务右下方的 构建 按钮也可以重新构建。 注意：原生平台为了避免误删除已定制的内容，在重新构建时仅更新项目资源，不会覆盖原有的原生工程内容。因此在返回 构建发布 面板修改之前配置的构建选项时，原生平台相关的构建选项为 禁用 状态。如果需要重新生成工程请新建构建任务。 如果修改配置后没有点击 构建 按钮重新构建，修改的配置也会被保存起来。若当前 构建发布 面板中的配置与上次构建后生成的 build 目录下的项目发布包中的配置不一致，构建发布 面板的上方会显示黄色的 * 号键。 构建日志信息查看 由于构建过程会产生非常多的日志信息，默认情况下只有错误信息才会打印到编辑器的 控制台 面板中。 如果需要查看所有的日志信息有以下几种操作方式： 打开构建调试工具 通过点击主菜单中的 开发者 -> 打开构建调试工具 或者点击 构建任务 页面右上方的 按钮，即可查看在构建过程中打印出的全部日志信息包括调用栈。 调整日志等级 点击主菜单中的 Cocos Creator -> 偏好设置 -> 构建发布，即可根据需要调整输出的日志等级。 打开构建日志记录文件 每次构建过程中产生的报错信息都会被记录存储在项目目录下的 temp/builder/log 文件夹中。点击构建任务左下方的 按钮即可查看。在反馈构建相关问题时，可直接附上该文件以便定位问题。 "},"editor/publish/build-options.html":{"url":"editor/publish/build-options.html","title":"通用构建选项介绍","keywords":"","body":"构建选项介绍 通用构建选项 构建发布 面板中的通用构建参数如下： 发布路径 发布路径中包含两个输入框： 第一个输入框用于指定项目的发布路径，可直接输入路径或者通过旁边的放大镜按钮选择路径。默认的发布路径为项目目录的 build 文件夹下，如果您使用 git、svn 等版本控制系统，可以将 build 文件夹在版本控制中忽略。 注意：发布路径中不允许包含空格、非法字符以及中文。 第二个输入框用于指定项目构建时的构建任务名称以及构建后生成的发布包名称。默认为当前构建平台名称，同个平台每多构建一次，便会在原来的基础上加上 -001 的后缀，以此类推。构建完成后可直接点击输入框后面的文件夹图标打开项目发布包所在目录。 初始场景 设置打开游戏后进入的第一个场景。可以在 参与构建的场景 列表中搜索所需的场景，将鼠标移动到所需场景栏，然后点击右侧出现的按钮，即可将其设置为初始场景。 参与构建场景 在构建过程中，除了项目目录下的 resources 文件夹以及 bundle 中的资源和脚本会全部打包外，其他资源都是根据参与构建的场景以及 bundle 中的资源引用情况来按需打包的。因而去除勾选不需要发布的场景，可以减少构建后生成的项目发布包包体体积。 MD5 缓存 为构建后的所有资源文件名加上 MD5 信息，可以解决 CDN 或者浏览器资源缓存问题。 启用后，如果出现资源加载不了的情况，说明找不到重命名后的新文件。这通常是因为有些第三方资源没通过 assetManager 加载引起的。这时可以在加载前先用以下方法转换 URL，转换后的路径就能正确加载。 const uuid = assetManager.utils.getUuidFromURL(url); url = assetManager.utils.getUrlWithUuid(uuid); 注意：原生平台启用 MD5 Cache 后，如果出现资源加载不了的情况，通常是因为有些 C++ 中用到的第三方资源没通过 assetManager 加载引起的。也可以通过以下代码转换 URL 来解决： auto cx = ScriptingCore::getInstance()->getGlobalContext(); JS::RootedValue returnParam(cx); ScriptingCore::getInstance()->evalString(\"cc.assetManager.utils.getUrlWithUuid(cc.assetManager.utils.getUuidFromURL('url'))\", &returnParam); string url; jsval_to_string(cx, returnParam, &url); 主包压缩类型 设置主包的压缩类型，具体内容可参考文档 Asset Bundle — 压缩类型。 配置主包为远程包 该项为可选项，需要与 资源服务器地址 选项配合使用。 勾选后，主包会配置为远程包，并且与其相关依赖资源一起被构建到发布包目录 remote 下的 内置 Asset Bundle — main 中。开发者需要将整个 remote 文件夹上传到远程服务器。 调试模式 若不勾选该项，则处于发布（release）模式，会对资源的 UUID、构建出来的引擎脚本和项目脚本进行压缩和混淆，并且对同类资源的 json 做分包处理，减少资源加载的次数。 若勾选该项，则处于调试模式，同时也可以配合勾选 Source Maps 选项，对项目进行调试，更方便定位问题。 Source Maps 如果需要生成 sourcemap，请勾选该项。构建时便会默认压缩引擎文件和项目脚本。 由于 JavaScript 脚本正变得越来越复杂，大部分源码（开发代码）都要经过编译转换才能投入生产环境，这就使实际运行的代码不同于源码，导致调试时无法定位到源代码。而 Source Map 可以将已转换的代码映射到源码，也就是将转换后的代码对应到转换前的源码的位置。这样在出现问题时，便可以直接查看和调试源码，定位问题更容易。详情可参考 使用 source map。 替换插屏 鼠标移动到该选项时便会出现 编辑图标 的按钮，点击该按钮打开插屏设置面板，数据编辑后将会实时保存。 压缩纹理 若项目中的图片资源设置了 压缩纹理 并勾选了该项，那么构建时便会根据压缩纹理设置生成对应的图像资源。如果不勾选该项，即便配置了压缩纹理也不会在构建时生效。 自动图集 若当前项目配置了 自动图集资源 并勾选了该项，那么构建时便会根据图集配置进行合图处理，生成图集到项目中。如果不勾选该项，即便配置了自动合图也不会在构建时生效。 注意：如果在 resources 文件夹中配置了自动图集，将会同时打包出大图和小图的图片资源以及对应的序列化信息，将会增大包体，如非必要请不要这样使用。 擦除模块结构（实验性质） 若勾选该项，脚本导入速度更快，但无法使用模块特性，例如 import.meta、import() 等。 Cocos Service 配置集 该项用于显示当前项目在 服务 面板所集成的所有服务。 Cocos Analytics 若勾选该项，可直接启用 服务 面板中的 Cocos Analytics 服务。 各平台相关构建选项 由于目前构建机制上的调整，不同平台的处理均以插件的形式注入 构建发布 面板。在 构建发布 面板的 发布平台 中选择要构建的平台后，将会看到对应平台的展开选项，展开选项的名称便是平台插件名，在编辑器主菜单的 扩展 -> 扩展管理器 -> 内置 中可以看到各平台插件。 各平台相关构建选项，详情请参考： 发布到原生平台 发布到小游戏平台 Creator 支持自定义构建扩展插件，处理方式与平台插件一致，详情可参考 扩展构建流程。 其他参与构建的参数配置 编辑器菜单栏 项目 -> 项目设置 中的配置都会影响到项目构建的结果，详情请参考 项目设置。 "},"editor/publish/publish-web.html":{"url":"editor/publish/publish-web.html","title":"发布到 Web 平台","keywords":"","body":"发布到 Web 平台 打开主菜单的 项目 -> 构建发布，打开 构建发布 面板。 Cocos Creator 提供了两种 Web 平台的页面模板，可以通过 发布平台 的下拉菜单选择 Web Mobile 或 Web Desktop，它们的区别主要在于： Web Mobile 会默认将游戏视图撑满整个浏览器窗口。 Web Desktop 允许在发布时指定一个游戏视图的分辨率，而且之后游戏视图也不会随着浏览器窗口大小变化而变化。 构建选项介绍 各平台通用的构建选项，详情请参考 通用构建参数介绍。接下来我们来看一下 Web 平台特有的构建选项。 Web Desktop 构建选项 说明 字段名（用于命令行发布） 资源服务器地址 用于下载远程资源的服务器地址，详情请参考下文 资源服务器地址 部分的内容。 remoteServerAddress 预览分辨率 游戏视图分辨率，默认为 (1280, 960) resolution Polyfills 构建支持一些脚本新特性的 polyfills，在打包脚本时会做对应处理，开发者可以根据实际需求选择需要的 polyfills。暂时只支持 异步函数，后续将会开放更多功能。 polyfills Web Mobile 构建选项 说明 字段名（用于命令行发布） 资源服务器地址 用于下载远程资源的服务器地址，详情请参考下文 资源服务器地址 部分的内容。 remoteServerAddress 设备方向 可选值包括 Auto、Landscape、Portrait orientation Polyfills 构建支持一些脚本新特性的 polyfills，在打包脚本时会做对应处理，目前包括 async Functions 和 coreJs 两种，开发者可以根据实际需求选择需要的 polyfills。 polyfills vConsole 插入 vConsole 调试插件，vConsole 类似 DevTools 的迷你版，用于辅助调试。 embedWebDebugger 预览二维码 用于扫描预览，详情可见下方介绍 - 预览 URL 用于预览的链接，详情可见下方介绍 - 资源服务器地址 该项为可选项，用于填写资源存放在服务器上的地址。 若 不填写 该项，则发布包目录下的 remote 文件夹会被打包到构建出来的游戏包中。 若 填写 该项，则不会打包到游戏包中，开发者需要在构建后手动将发布包目录下的 remote 文件夹上传到所填写的资源服务器地址上。详情请参考 上传资源到远程服务器。 预览 URL 构建支持同时预览多个 Web 项目，因而构建的预览 URL 不再是统一的而是每个构建任务都会有一个单独的预览 URL，互不干扰。点击 URL 即可自动打开浏览器进行预览，具体的预览 URL 拼接规则为 ${偏好设置中的预览 IP 地址}:${编辑器预览端口号}/${构建平台}/${构建任务名}/index.html。 构建和预览 配置好构建选项后，点击 构建 按钮，开始 Web 平台版本构建。面板上会出现一个进度条，当进度条显示“Build success”时，构建就完成了。 接下来可以点击 运行 按钮，在浏览器中打开构建后的游戏版本进行预览和调试。 上图所示就是 Web Mobile 平台的预览，可以看到游戏视图占满了整个浏览器窗口，而 Web Desktop 的游戏视图则是固定分辨率的，不会撑满屏幕。 浏览器兼容性 Cocos Creator 开发过程中测试的桌面浏览器包括：Chrome、Firefox（火狐） 和 QQ 浏览器，其他浏览器只要内核版本够高也可以正常使用，对部分浏览器来说请勿开启 IE 兼容模式。 移动设备上测试的浏览器包括：Safari（iOS）、Chrome（Android）、QQ 浏览器（Android） 和 UC 浏览器（Android）。 Retina 设置 可以在脚本中通过 view.enableRetina(true) 设置是否使用高分辨率，构建到 Web 平台时默认会开启 Retina 显示。详情可参考 API enableRetina。 发布到 Web 服务器 如果要在互联网上发布或分享游戏，只要点击 构建任务 左下方的 文件夹图标 按钮，打开发布路径之后，按照当前构建任务名称，将构建出的对应文件夹里的内容整个复制到 Web 服务器上，就可以通过相应的地址访问了。 关于 Web 服务器的架设，可以自行搜索 Apache、Nginx、IIS、Express 等相关解决方案。 "},"editor/publish/native-options.html":{"url":"editor/publish/native-options.html","title":"发布到原生平台","keywords":"","body":"打包发布到原生平台 点击菜单栏的 项目 -> 构建发布，打开构建发布面板。 目前可以选择的原生平台包括 Android、iOS、Mac、Windows 四个，其中发布到 iOS、Mac 和 Windows 的选项只能在相应的操作系统中才会出现。 环境配置 发布到原生平台需要安装配置一些必要的环境，详情请参考 安装配置原生开发环境。 构建选项 各平台通用的构建选项，详情请参考 通用构建选项。 原生平台通用构建选项 由于目前构建机制上的调整，不同平台的处理均以插件的形式注入 构建发布 面板。 在 构建发布 面板的 发布平台 中选择要构建的原生平台后，将会看到除了具体原生平台的展开选项外还有一个 Native 的展开选项。Native 中的构建选项在各个原生平台上都是一致的。 选择源码模板（Template） 从 Cocos Creator 3.0 开始，为了体验一致，模板 (Template) 中可使用的引擎模板为 Link，移除了原先的 Default 模板。 Link 模板不会拷贝 Cocos2d-x 源码到构建目录下，而是使用共享的 Cocos2d-x 源码。这样可以有效减少构建目录占用的空间，并且对 Cocos2d-x 源码的修改也可以得到共享。 关于源码引擎 Cocos2d-x 引擎中包括了源码引擎，它们适用的范围是： 源码引擎初次构建和编译某个工程时需要很长的时间编译 C++ 代码，视电脑配置而定，这个时间可能在 5~20 分钟。对于同一个项目，已经编译过一次之后，下次再编译需要的时间会大大缩短。 源码引擎构建出的工程，使用原生开发环境编译和运行（如 Android Studio、Xcode 等 IDE），是可以进行调试和错误捕获的。 目前 Cocos Creator 安装目录下的 resources\\3d\\cocos2d-x-lite 文件夹中已经包含了自带的 Cocos2d-x 源码引擎。若需要自定义引擎，详情请参考 引擎定制工作流程。 资源服务器地址 当包体过大时，可将资源上传到资源服务器，通过网络请求下载。该项用于填写资源存放在远程服务器上的地址，开发者需要在构建后手动将发布包目录下的 remote 文件夹上传到所填写的资源服务器地址上。详情可参考 上传资源到远程服务器 Polyfills 该项是脚本系统支持的一些新特性的 polyfills 选项，目前仅支持 异步函数。勾选后生成的项目会带上对应的 polyfills，也就是会增大包体，开发者可以根据实际需求选择是否使用。 构建后立即生成 若勾选该项，构建完成后会自动执行 生成 步骤，不需要再手动操作。 加密脚本 该项用于加密发布后的脚本。会在构建后的 assets 目录下生成 jsc 文件，这个文件是加密过的。而 js 文件会备份在 script-backup 目录下以便调试，打包时不会进入 APP 中。 脚本加密密钥：在 Native 平台上会使用这个值作为加密 js 文件的密钥。项目新建时会随机生成。 Zip 压缩：勾选上的话可以减小脚本体积。 Android 平台构建选项 Android 平台的构建选项如下： 渲染后端 目前支持 VULKAN、GLES3 和 GLES2 三种，默认勾选 GLES3。在同时勾选多个的情况下，运行时将会根据设备实际支持情况选择使用的渲染后端。 应用 ID 名称 应用 ID 名称（Game Package Name）通常以产品网站 URL 倒序排列，如 com.mycompany.myproduct。 注意：包名中只能包含数字、字母和下划线，此外包名最后一部分必须以字母开头，不能以下划线或数字开头。 Target API Level 设置编译 Android 平台时所需的 Target API Level。点击旁边的 Set Android SDK 按钮即可快速跳转到配置页，具体配置规则请参考 配置原生发布环境路径。 APP ABI 设置 Android 需要支持的 CPU 类型，可以选择一个或多个选项，目前包括 armeabi-v7a、arm64-v8a、x86 三种类型。 注意： 当你选择一个 ABI 构建完成之后，在不 Clean 的情况下，构建另外一个 ABI，此时两个 ABI 的 so 都会被打包到 apk 中，这个是 Android Studio 默认的行为。若用 Android Studio 导入工程，选择一个 ABI 构建完成之后，先执行一下 Build -> Clean Project 再构建另外一个 ABI，此时只有后面那个 ABI 会被打包到 apk 中。 项目工程用 Android Studio 导入后，是一个独立的存在，不依赖于构建发布面板。如果需要修改 ABI，直接修改 gradle.properties 文件中的 PROP_APP_ABI 属性即可。 使用调试密钥库 Android 要求所有 APK 必须先使用证书进行数字签署，然后才能安装。Cocos Creator 提供了默认的密钥库，勾选 使用调试密钥库 就是使用默认密钥库。若开发者需要自定义密钥库可去掉 使用调试密钥库 勾选，详情请参考 官方文档。 屏幕方向 屏幕方向目前包括 Portrait、Landscape Left、Landscape Right 三种。 Portrait：屏幕直立，Home 键在下 Landscape Left：屏幕横置，Home 键在屏幕左侧 Landscape Right：屏幕横置，Home 键在屏幕右侧 Google Play Instant 勾选该项即可将游戏打包发布到 Google Play Instant。Google Play Instant 依赖于 Google Play，并不是一个新的分发渠道，而是更接近一种游戏微端方案。它能够实现游戏的免安装即开即玩，有利于游戏的试玩、分享和转化。 使用时需要注意以下几点： Android Studio 的版本要在 4.0 及以上 Android Phone 6.0 及以上。Android SDK 版本在 6.0 到 7.0 之间的设备需要安装 Google 服务框架，SDK 版本在 8.0 以上的则不需要，可直接安装使用。 首次编译的话需要用 Android Studio 打开构建后的工程以下载 Google Play Instant Development SDK（windows） 或 Instant Apps Development SDK（Mac） 支持包。如果下载不成功的话建议设置一下 Android Studio 的 HTTP 代理。 生成 App Bundle（Google Play） 勾选该项即可将游戏打包成 App Bundle 格式用于上传到 Google Play 商店。具体请参考 官方文档。 Windows 平台构建选项 Windows 平台的构建选项目前只有一个 渲染后端，包括 VULKAN、GLES3 和 GLES2 三种类型，默认勾选 GLES3。在同时勾选多个的情况下，运行时将会根据设备实际支持情况来选择使用的渲染后端。 iOS 平台构建选项 iOS 平台的构建选项包括 Bundle Identifier、屏幕方向 和 渲染后端，其中 屏幕方向 的设置与 Android 平台一致。 Bundle Identifier 包名，通常以产品网站 URL 倒序排列，如 com.mycompany.myproduct。 注意：包名中只能包含数字 (0~9)、字母 (A~Z、a~z)、中划线（-）和点（.），此外包名最后一部分必须以字母开头，不能以下划线或数字开头。详情请参考 包的唯一标识符。 渲染后端 渲染后端 目前支持 METAL。 Mac 平台构建选项 Mac 平台的构建选项包括 Bundle Identifier 和 渲染后端，设置方法与 iOS 平台一致。 构建 构建选项设置完成后，就可以开始构建了，点击 构建发布 面板右下角的 构建 按钮，开始构建流程。 编译脚本和打包资源时会在 构建发布 面板的 构建任务 页面显示蓝色的进度条，构建成功的话进度条到达 100% 并显示为绿色： 构建目录 构建结束后，我们得到的是一个标准的 Cocos2d-x 工程，和使用 Cocos Console 新建的工程有同样的结构。以 Windows 平台为例，导出的原生工程包 windows 的目录结构为： assets：存放项目资源 proj：存放当前构建的原生平台工程，可用于对应平台的 IDE 执行编译任务，详情请参考下文介绍 cocos.compile.config.json：本次构建的编译选项配置 因为原生平台（例如 Android、Windows）构建后生成的底层 C++ 代码是完全一致的，所以在 v3.0，我们将底层 C++ 代码单独提取出来放在项目目录下共享的 native/engine/common 文件夹中。这样在构建原生平台时，如果检测到已经存在该文件夹，这部分内容便不会再进行处理，加快构建速度。 更多关于目录结构的说明，请参考 构建目录差异 — 原生平台 二次开发 v3.0 做了代码和配置的分离，将一部分代码和配置放入源码管理，位于项目目录下的 native\\engine\\当前构建的平台名称 文件夹中（例如 native\\engine\\win32、native\\engine\\android）。 开发者可以在这里集成 SDK 或者做二次开发，删除构建后生成的发布包目录（例如 build\\windows）不会影响已经集成的 SDK，但前提是需要在目录中添加代码引用： 若集成的是各原生平台通用的 SDK，需要在项目目录下的 native\\engine\\common\\CMakeLists.txt 中添加引用。 若是基于 iOS、Mac、Windows 平台做二次开发，需要在项目目录下的 native\\engine\\当前构建的平台名称\\CMakeLists.txt 中添加引用（例如 native\\engine\\ios\\CMakeLists.txt） 若是基于 Android 平台做二次开发： C++：需要在项目目录下的 native\\engine\\android\\CMakeLists.txt 中添加引用。 Java：需要在项目发布包 build\\android\\proj\\build.gradle 中添加引用。 更多关于 CMake 的使用，详情可参考 CMake 使用简介。 生成和运行 Cocos Creator 支持通过编辑器或各平台对应的 IDE（如 Xcode、Android Studio、Visual Studio）执行进一步的预览、调试和发布。 通过编辑器 构建完成后，继续点击旁边的 生成 按钮，成功后会提示： make package YourProjectBuildPath success! 注意：首次生成 Android 平台或者版本升级后，建议通过 Android Studio 打开工程，根据提示下载缺失的工具，再进行编译运行。 生成 过程完成后，继续点击旁边的 运行 按钮，可能还会继续进行一部分编译工作，请耐心等待或通过日志文件查看进展。各平台的运行结果为： Mac/Windows 平台会直接在桌面运行预览 Android 平台必须通过 USB 连接真机，并且在真机上开启 USB 调试后才可以运行预览 iOS 平台会调用模拟器运行预览，但建议通过 Xcode 连接真机执行 生成 和 运行，可参考下文介绍。 通过 IDE 点击 构建任务 左下角的 文件夹图标 按钮，就会在操作系统的文件管理器中打开构建发布路径，这个路径中 build 目录下的 proj 里就包含了当前构建的原生平台工程。 接下来使用原生平台对应的 IDE（如 Xcode、Android Studio、Visual Studio）打开这些工程，就可以进一步地编译和发布预览了。 Android Windows iOS 和 Mac 注意：请不要在这些原生平台工程中进行二次开发，否则重新构建时会被覆盖掉。 关于原生平台 IDE 的使用请搜索相关信息，这里就不再赘述了。若要了解如何在原生平台上调试，请参考 原生平台 JavaScript 调试。 注意事项 在 MIUI 10 系统上运行 debug 模式构建的工程可能会弹出 “Detected problems with API compatibility” 的提示框，这是 MIUI 10 系统自身引入的问题，使用 release 模式构建即可。 打包 iOS 平台时，如果开发者在项目中未使用到 WebView 相关功能，请确保在 项目 -> 项目设置 -> 功能裁剪 中剔除 WebView 模块，以提高 iOS 的 App Store 机审成功率。如果开发者确实需要使用 WebView（或者添加的第三方 SDK 自带了 WebView），并因此 iOS 的 App Store 机审不通过，仍可尝试通过邮件进行申诉。 Android 平台通过编辑器和 Android Studio 编译后的结果有些区别： 通过编辑器执行 生成 步骤后，会在发布路径下生成 build 目录，.apk 生成在 build 目录的 app\\build\\outputs\\apk 目录下。 通过 Android Studio 编译后，.apk 则生成在 proj\\app\\build\\outputs\\apk 目录下。 在 Cocos Creator 3.0 中，Android 与 Android Instant 使用同一个构建模板，构建生成的工程都是在 build\\android\\proj 目录中。针对该目录请注意： 如果是 Android 平台单独使用的代码请放入 app\\src 目录，单独使用的第三方库请放入 app\\libs 目录（若没有这两个目录可自行创建）。 如果是 Android Instant 单独使用的代码和第三方库请分别放入 instantapp\\src 和 instantapp\\libs 目录（若没有这两个目录可自行创建）。 如果是 Android 和 Android Instant 共用的代码和第三方库，请分别放入 src 和 libs 目录（若没有这两个目录可自行创建）。 通过在 构建发布 面板点击 生成 按钮来编译 Android 时，会默认执行 assembleRelease/Debug，编译 Android Instant 时会默认执行 instantapp:assembleRelease/Debug。 "},"editor/publish/setup-native-development.html":{"url":"editor/publish/setup-native-development.html","title":"安装配置原生环境","keywords":"","body":"安装配置原生开发环境 除了内置的 Web 版游戏发布功能外，Cocos Creator 使用基于 Cocos2d-x 引擎的 JSB 技术实现跨平台发布原生应用。在使用 Cocos Creator 打包发布到原生平台之前，我们需要先配置好 Cocos2d-x 相关的开发环境。 Android 平台相关依赖 要发布到 Android 平台，需要安装以下全部开发环境依赖。如果不需要发布到 Android 平台或者操作系统上已经有完整的 Android 开发环境，可以跳过这部分内容。 下载 Java SDK（JDK） 编译 Android 工程需要本地电脑上有完整的 Java SDK 工具，请到以下地址下载： Java SE Development Kit 8 Downloads 下载时注意选择和本机匹配的操作系统和架构，下载完成后运行安装程序即可。 安装后请检查 JAVA 环境，在 Mac 终端或者 Windows 命令行工具中输入下面代码来查看： java -version 显示为 JAVA SE 则没有问题，如果系统中使用的是 JRE，则需要安装 JAVA SE 运行环境。 如果是 Windows 系统，请确认你的环境变量中包含 JAVA_HOME。可以通过右键点击我的电脑，选择属性，打开高级选项卡中来查看和修改环境变量。修改完成后 Windows 平台可能需要重启电脑才会生效。参考 如何设置或更改 JAVA 系统环境变量 下载安装 Android Studio Cocos Creator 3.0 不支持 Eclipse 的 ANT 构建，需要使用 Android Studio 4.1 及以上版本 作为安卓平台的构建工具，并在 Android Studio 中下载所需的 SDK 和 NDK 包。首先请 安装 Android Studio。 下载发布 Android 平台所需的 SDK 和 NDK 安装 Android Studio 完成后，参考官方文档，打开 SDK Manager：SDK Manager 使用说明。 在 SDK Platforms 分页栏，勾选你希望安装的 API Level，也就是支持安卓系统的版本，推荐选择主流 API Level 26（8.0）、API Level 28（9.0）等。 在 SDK Tools 分页栏，首先勾选右下角的 Show Package Details，显示分版本的工具选择。 在 Android SDK Build-Tools 里，选择最新的 build tools 版本。 勾选 Android SDK Platform-Tools 和 CMake，如需安装 Android 支持库，请参考 官方文档 — 支持库设置。 勾选 NDK，推荐使用版本为 r18~21。需要注意的是目前暂时不支持 NDK-r22。 记住窗口上方所示的 Android SDK Location 指示的目录，稍后我们需要在 Cocos Creator 编辑器中填写这个 SDK 所在位置。 点击 OK，根据提示完成安装。 安装 C++ 编译环境 请安装以下运行环境： Windows 下需要安装 Visual Studio 2017/2019 社区版。在安装 Visual Studio 时，请勾选 使用 C++ 的桌面开发 和 使用 C++ 的游戏开发 两个模块。 注意：在 使用 C++ 的游戏开发 模块中有一个 Cocos 选项，请勿勾选。 Mac 下需要安装 Xcode 和命令行工具，下载页。 注意：从 v3.0.1 开始，要求使用的 Xcode 版本为 11.5 及以上。 配置原生发布环境路径 下载安装好开发环境依赖后，回到 Cocos Creator 中配置构建发布原生平台的环境路径。在主菜单中选择 Cocos Creator -> 偏好设置，打开 偏好设置 面板，我们需要在 外部程序 栏中配置以下两个路径： Android NDK：选择刚才在 Android Studio 中的 Android SDK Location 路径下的 ndk-bundle 文件夹（NDK 是其根目录），不需要编译 Android 平台的话这里可以跳过。 注意：新版本 Android Studio 的 NDK 可下载多版本，之前的 ndk-bundle 文件名更改为 ndk，可在 ndk 目录下根据需要选择具体版本的 NDK。 Android SDK：选择刚才在 Android Studio 的 SDK Manager 中记下的 Android SDK Location 路径（Android SDK 的目录下应该包含 build-tools、platforms 等文件夹），不需要编译 Android 平台的话这里可以跳过。 配置完成后会自动保存。 注意：这里的配置会在编译 原生工程 的时候生效。如果没有生效（一些 Mac 机器有可能出现这个情况），可能需要您尝试到 系统环境变量 设置这些值：NDK_ROOT、ANDROID_SDK_ROOT。 注意事项 在之前的版本中收到了很多原生打包的问题反馈，这里补充一些可能的问题原因。 包名问题 检查 构建发布 面板中的包名，具体命名规范请参考相应原生平台中的 构建选项说明。 Android 编译成功，但运行时提示 dlopen failed: cannot locate symbol \"xxxx\" referenced by \"libcocos2djs.so\"... 请检查 NDK 和 Android SDK 的架构和版本是否和测试用的 Android 系统相对应，另外可以尝试使用本文所用的 NDK 和 Android SDK 版本来测试。 最后，如果依然打包失败，请附上详细的复现步骤及报错信息通过 论坛 反馈给我们。 "},"editor/publish/debug-jsb.html":{"url":"editor/publish/debug-jsb.html","title":"原生平台 JavaScript 调试","keywords":"","body":"原生平台 JavaScript 调试 游戏发布到原生平台后，由于运行环境不同，可能会出现在浏览器预览时无法重现的 Bug，这时我们就必须直接在原生平台下进行调试。Cocos Creator 可以很方便地对原生平台中的 JavaScript 进行远程调试。 iOS 和 Android 真机调试 如果游戏只有在真机上才能运行，那就必须用真机对打包后的游戏进行调试。调试步骤如下： 确保 Android/iOS 设备与 Windows 或者 Mac 在同一个局域网中。注意在调试过程中请勿开启代理，否则可能导致无法正常调试。 在 Creator 的 构建发布 面板选择 Android/iOS 平台、Debug 模式，构建编译运行工程（iOS 平台建议通过 Xcode 连接真机进行编译运行）。 用 Chrome 浏览器打开地址：devtools://devtools/bundled/js_app.html?v8only=true&ws=设备的本地 IP:6086/00010002-0003-4004-8005-000600070008 即可进行调试。 Windows 平台及 Mac 平台调试 在 Windows 平台及 Mac 平台下调试游戏，步骤与真机调试类似，将工程用 IDE 编译运行之后，此时便可进行调试。步骤如下： 用 IDE 将打包好的工程编译并运行（Windows 平台请使用 Visual Studio，Mac 平台请使用 Xcode） 在游戏运行时打开 Chrome 浏览器，输入地址：devtools://devtools/bundled/js_app.html?v8only=true&ws=127.0.0.1:6086/00010002-0003-4004-8005-000600070008 即可进行调试。 使用 lldb 查看当前的 JS 调用栈 通过在 C++ 中断点我们能很便捷地看到 C++ 的调用栈，但并不能同时看到 JS 的调用栈，这个割裂的过程常常会破坏调试的体验。而 lldb 提供的功能支持在调试过程中进行很多的操作，包括查看调用栈。 Xcode 和 Android Studio 都默认使用 lldb 作为调试器。详情可参考文档 LLDB 指南。 lldb 的全局配置 lldb 在启动的时候会加载 ~/.lldbinit，例如下面的配置： ~ % cat ~/.lldbinit target stop-hook add expr -- cocos2d::log(\".lldbinit ---- \\n%s\\n\", se::ScriptEngine::getInstance()->getCurrentStackTrace().c_str()) DONE 设置了 每次断点 后的行为，执行以下代码输出 JS 调用栈的信息： cocos2d::log(\".lldbinit ---- \\n%s\\n\", se::ScriptEngine::getInstance()->getCurrentStackTrace().c_str()) 关于 target stop-hook 的用法，详情可参考文档：https://lldb.llvm.org/use/map.html#examining-variables 但这种方法也存在着明显的缺陷：会对 所有项目 生效，若其他项目不存在相应符号，就会导致出现报错。 在 Xcode 配置 lldb Xcode 在断点中编辑 action（只对具体的断点触发） 在 Debugger Command 中输入命令： expr -- cocos2d::log(\".lldbinit ---- \\n%s\\n\", se::ScriptEngine::getInstance()->getCurrentStackTrace().c_str()) 关于 target stop-hook 的用法，详情可参考文档：https://lldb.llvm.org/use/map.html#evaluating-expressions 设置 stop hook 断点触发后，需要在 lldb console 中增加回调。可以针对具体的断点进行更多的调用： 同上，也可以执行以下代码查看调用栈： expr -- cocos2d::log(\".lldbinit ---- \\n%s\\n\", se::ScriptEngine::getInstance()->getCurrentStackTrace().c_str()) 在 Android Studio 配置 lldb 在 Android Studio 的 Run -> Debug Configuration -> Debugger 界面进行类似的配置： Android Studio 也提供了和 Xcode 类似的 lldb console。 进阶调试指南 如果需要在 Release 模式下调试，或者需要调试定制后的原生引擎，可参考更详细的 JSB 2.0 使用指南：远程调试与 Profile。 "},"editor/publish/publish-mini-game.html":{"url":"editor/publish/publish-mini-game.html","title":"发布到小游戏平台","keywords":"","body":"发布到小游戏平台 发布到 HUAWEI AppGallery Connect 发布到支付宝小游戏 发布到字节跳动小游戏 发布到 Cocos Play 发布到华为快游戏 发布到 OPPO 小游戏 发布到 vivo 小游戏 发布到小米快游戏 发布到百度小游戏 发布到微信小游戏 启用微信小游戏引擎插件 接入微信 PC 小游戏 开放数据域 小游戏分包 "},"editor/publish/publish-huawei-agc.html":{"url":"editor/publish/publish-huawei-agc.html","title":"发布到 HUAWEI AppGallery Connect","keywords":"","body":"发布到 HUAWEI AppGallery Connect Cocos Creator 支持将游戏发布到 HUAWEI AppGallery Connect，帮助开发者接入到华为的应用市场。 准备工作 进入 AppGallery Connect 后台 并登录，需要先完成 开发者注册，然后再 创建应用。创建应用时，软件包类型 选择 APK。 通过 Cocos Service 面板接入所需的 HUAWEI AppGallery Connect 相关服务。目前 SDK 仅支持 Android 平台，具体的操作步骤可参考文档 HUAWEI HMS Core。 发布流程 使用 Cocos Creator 打开需要发布的项目工程，从 菜单栏 -> 项目 中打开 构建发布 面板，发布平台 项选择 HUAWEI AppGallery Connect。 通用构建选项的设置请参考 构建选项，需要注意的是请确保 包名 与华为后台设置的包名一致。 agconnect-services 配置：用于配置华为参数文件 agconnect-services.json，具体的配置方法请参考 配置华为参数文件。 Cocos SDKHub 配置集：在 Cocos Service 服务面板开通 Cocos SDKHub 服务之后，构建发布 面板中就会出现该选项，用于帮助游戏快速集成渠道。 构建编译 构建发布 面板的相关参数项设置完成后，点击 构建。 构建完成后点击 构建任务 左下角的文件夹图标按钮打开构建发布包，可以看到在默认发布路径 build 目录下生成了 huawei-agc 目录，其中已经自动集成了 HUAWEI AppGallery Connect 相关服务。 然后点击 生成，或者使用 Android Studio 打开项目进行编译，编译完成后在发布包目录下会生成 HUAWEI AppGallery Connect 的 APK。 上传 APK 到 AppGallery Connect 有以下两种方式可以将 APK 上传到 AppGallery Connect。 1. 通过构建发布面板上传 Creator 支持直接将构建编译生成的 APK 上传到 AppGallery Connect 后台。 点击 构建任务 右下角的 上传 按钮，即可打开 上传 面板，然后填写相关信息。 APP ID：填写应用的 APP ID。登录 AppGallery Connect 后台，选择 我的应用 -> 应用信息，即可获取应用的 APP ID。 版本号：根据需要填写。 APK 路径：选择之前构建编译生成的 APK。 登录方式：包括 OAuth 和 API 客户端 两种。 OAuth OAuth 登录方式只需要在点击 确认上传 的时候，根据提示登录 HUAWEI 账号（账号需要有足够的 权限），然后勾选对应权限的允许框，窗口会自动关闭并自动上传 APK。 API 客户端 若首次使用 API 客户端 登录方式，需要登录 AppGallery Connect 后台获取相关配置信息。 选择 用户与访问 -> Connect API -> 创建，创建一个 API 客户端，并根据需要选择 权限，然后点击 确认。 将 API 客户端的 客户端 ID 和 密钥 填入 Creator 上传 面板中的对应输入框。 配置完成后点击 确认上传 即可。 两种登录方式的详细说明可参考文档 AppGallery Connect 使用入门。 2. 通过 AppGallery Connect 后台上传 在 AppGallery Connect 后台进入 我的应用，选择应用，切换到 分发 栏。然后点击左侧的 版本信息 -> 准备提交，找到软件版本，点击 软件包管理，然后点击 上传。 提交审核 在 AppGallery Connect 后台进入 我的应用，选择应用，切换到 分发 栏。然后点击左侧的 版本信息 -> 准备提交，找到软件版本，点击 软件包管理，选中刚刚上传的 APK，然后点击 选取。 其他的配置信息填写可参考文档 发布应用。填写完成确认各个信息没有问题后，便可以直接点击页面右上方的 提交审核 按钮。华为应用市场将在 3~5 个工作日内完成审核。 相关参考链接 AppGallery Connect 后台 AppGallery Connect 操作指南 "},"editor/publish/publish-alipay-mini-game.html":{"url":"editor/publish/publish-alipay-mini-game.html","title":"发布到支付宝小游戏","keywords":"","body":"发布到支付宝小游戏 环境配置 桌面端下载 支付宝小程序开发者工具 并安装。 下载 支付宝，并安装到手机设备上。 支付宝客户端在 Android 上支持的最低版本为 10.1.75，在 iOS 为 10.1.78。 发布流程 使用 Cocos Creator 打开需要发布的项目工程，在 构建发布 面板的 发布平台 中选择 支付宝小游戏，然后点击 构建。 通用构建选项的设置请参考 构建选项。支付宝小游戏相关的构建选项填写规则如下： 构建选项 说明 字段名（用于命令行发布） 初始场景分包 勾选后，首场景及其相关的依赖资源会被构建到发布包目录 assets 下的内置 Asset Bundle — start-scene 中，提高初始场景的资源加载速度。 startSceneAssetBundle 设备方向 可选值包括 landscape 和 portrait。 deviceOrientation 资源服务器地址 用于填写资源存放在远程服务器上的地址。开发者需要在构建后手动将发布包目录下的 remote 文件夹上传到所填写的资源服务器地址上。详情可参考 上传资源到远程服务器 remoteUrl polyfills 构建支持一些新特性的 polyfills，主要是在打包脚本时会做相应的处理。目前仅支持 异步函数，后续将会开放更多功能。 polyfills 构建完成后点击 构建任务 左下角的文件夹图标按钮，可以看到在项目的 build 目录下生成了支付宝小游戏工程文件夹 alipay-mini-game，其中已经包含了支付宝小游戏环境的配置文件 game.json。 使用 支付宝开发者工具 打开构建生成的 alipay-mini-game 文件夹，即可打开支付宝小游戏项目以及预览调试游戏内容。 支付宝小游戏环境的资源管理 支付宝小游戏与微信小游戏类似，都存在着包体限制，超过 4MB 的额外资源，必须通过网络请求下载。当包体过大时，可在 构建发布 面板配置 资源服务器地址 选项，将资源上传到远程服务器，详情请参考 上传资源到远程服务器。 我们建议用户只保存脚本文件在小游戏包内，其他资源都从远程服务器下载。Cocos Creator 已经帮用户做好了远程资源的下载、缓存和版本管理，详情请参考 缓存管理器。 支付宝小游戏的限制 我们对支付宝小游戏的适配工作还未完全结束，目前已知在低端机上文本渲染效果可能不太理想。并且仍不支持以下模块： WebView VideoPlayer 分包加载 自定义字体 以上功能预计在以后的更新中会逐步支持，我们也将持续与支付宝小游戏的工程师们紧密沟通，不断优化适配效果。 文档相关 由于支付宝小游戏相关的文档目前只对内开放，开发者如果有需要的话可直接联系： 联系人 Email 李智 lz98684@alibaba-inc.com 黄娇 huangjiao.hj@alibaba-inc.com "},"editor/publish/publish-bytedance-mini-game.html":{"url":"editor/publish/publish-bytedance-mini-game.html","title":"发布到字节跳动小游戏","keywords":"","body":"发布到字节跳动小游戏 字节小游戏是基于字节跳动全产品矩阵开发，不需用户下载，点开即玩的全新游戏类型。 小游戏的游戏提交，审核和发布流程等，需要遵守字节官方团队的要求和标准流程，具体信息可以参考 字节跳动小游戏接入指南。 准备工作 下载 字节跳动开发者工具 并安装。 参考 字节跳动小游戏接入指南，在 字节跳动开发者平台 完成账号注册、登录以及申请小游戏。 小游戏申请通过后，在开发者平台的 开发管理 -> 开发设置 中找到 AppID。 发布流程 使用 Cocos Creator 打开需要发布的项目工程，从 菜单栏 -> 项目 中打开 构建发布 面板。在 构建发布 面板的 发布平台 中选择 字节跳动小游戏。 通用构建选项的设置请参考 通用构建选项，字节跳动小游戏特有的构建选项如下，具体说明请参考下文 构建选项 部分的内容。 构建发布 面板的构建选项设置完成后，点击 构建。 构建完成后点击 构建任务 左下角的文件夹图标按钮打开项目发布包，可以看到在默认发布路径 build 目录下生成了 bytedance-mini-game（以具体的构建任务名为准）文件夹，其中已经包含了字节跳动小游戏环境的配置文件 game.json 和 project.config.json。 使用 字节跳动开发者工具 打开构建生成的 bytedance-mini-game 文件夹，即可打开字节跳动小游戏项目及预览调试游戏内容。开发者工具的具体使用方式请参考 字节跳动开发者工具介绍。 构建选项介绍 构建选项 说明 字段名（用于命令行发布） 初始场景分包 勾选后，首场景及其相关的依赖资源会被构建到发布包目录 assets 下的内置 Asset Bundle — start-scene 中，提高初始场景的资源加载速度。 startSceneAssetBundle 设备方向 可选值包括 Portrait 和 Landscape。构建时会写入到发布包目录下的 game.json 文件中 orientation AppID 必填项，字节跳动小游戏的 AppID，构建时会写入到发布包目录下的 project.config.json 文件中。 appid 资源服务器地址 用于填写资源存放在远程服务器上的地址。开发者需要在构建后手动将发布包目录下的 remote 文件夹上传到所填写的资源服务器地址上。详情请参考 上传资源到远程服务器 remoteServerAddress 生成开放数据域工程模板 用于接入开放数据域，详情请参考 开放数据域 buildOpenDataContextTemplate 分包加载 分包加载，即把游戏内容按一定规则拆分在几个包里，在首次启动的时候只下载必要的包，这个必要的包称为 主包，开发者可以在主包内触发下载其他子包，这样可以有效降低首次启动的消耗时间。若要使用该功能需要在 Creator 中设置 小游戏分包，设置完成后在构建时就会自动分包。 字节跳动小游戏需要特定的版本才能支持分包功能，字节产品的版本要求如下： 产品 Android iOS 抖音 v13.6.0 v13.7.0 头条 v7.9.9 v7.9.8 字节开发者工具使用的版本请大于等于 2.0.6，小于 3.0.0。调试基础库则要求在 1.88.0 及以上。 注意：若产品的版本不支持分包加载，则引擎会将分包作为一个普通的 Asset Bundle 加载。 目前小游戏分包大小有以下限制： 整个小游戏的所有分包大小不超过 16 M 单个分包/主包的大小不能超过 4 M 具体可参考 字节跳动小游戏分包加载官方文档 小游戏环境的资源管理 字节跳动小游戏与微信小游戏类似，都存在着包体限制，超过 4MB 的额外资源，必须通过网络请求下载。当包体过大时，可在 构建发布 面板配置 资源服务器地址 选项，将资源上传到远程服务器，详情请参考 上传资源到远程服务器。 我们建议用户只保存脚本文件在小游戏包内，其他资源都从远程服务器下载。Cocos Creator 已经帮用户做好了远程资源的下载、缓存和版本管理，详情可参考 缓存管理器。 参考链接 字节跳动小游戏开发接入指南 字节跳动开发者平台 字节跳动小游戏 API 文档 字节跳动开发者工具下载 字节跳动开发者工具文档 "},"editor/publish/publish-cocos-play.html":{"url":"editor/publish/publish-cocos-play.html","title":"发布到 Cocos Play","keywords":"","body":"发布到 Cocos Play 从 v2.2.2 开始，即刻玩 更名为 Cocos Play。 环境配置 下载 游戏自测工具 并安装到 Android 设备（建议 Android Phone 6.0 或以上版本）。 发布流程 使用 Cocos Creator 打开需要发布的项目工程，从 菜单栏 -> 项目 中打开 构建发布 面板。在 构建发布 面板的 发布平台 中选择 Cocos Play。 通用构建选项的设置请参考请参考 通用构建选项，Cocos Play 特有的构建选项如下： 构建选项 说明 字段名（用于命令行发布） 设备方向 可选值包括 landscape 和 portrait。构建时将会写入到发布包目录下的 game.config.json 中。 deviceOrientation 初始场景分包 若勾选该项，首场景及其相关的依赖资源会被构建到发布包目录 assets 下的内置 Asset Bundle — start-scene 中，提高初始场景的资源加载速度。 startSceneAssetBundle 资源服务器地址 该项用于填写资源存放在服务器上的地址。若 不填写 该项，则发布包目录下的 remote 文件夹将会被打包到构建后生成的 cpk 包中。若 填写，则不会打包进 cpk。开发者需要在构建后手动将发布包目录下的 remote 文件夹上传到所填写的资源服务器地址上，详情请参考 上传资源到远程服务器。服务器地址会在构建时写入到发布包目录下的 application.js 中。 tinyPackageServer 构建 构建发布 面板的构建选项设置完成后，点击 构建并生成 按钮。 构建完成后点击 构建任务 左下角的文件夹图标按钮打开项目发布包，可以看到在默认发布路径 build 目录下生成了 cocos-play（以具体的构建任务名为准）文件夹，该文件夹就是导出的 Cocos Play 工程目录和 cpk，cpk 包在 build/cocos-play/dist 目录下。 若需要修改生成的 cpk 包，在修改完成后点击 构建任务 右下角的 生成 按钮，即可在不重新构建的情况下重新生成 cpk 包。 接入测试 开发者必须使用自测工具测试接入没有问题之后，才可以打包提交到平台审核。自测工具可以启动游戏并提供游戏登录、支付等功能。通过读取游戏配置参数，确定启动的游戏类型，以及游戏启动方式。自测时没有要求包的大小，但如果是要提交审核的话，包的大小不能超过 10M。具体可参考 自测工具。 打开之前已经安装完成的游戏自测工具，然后点击自测工具左上方的 配置游戏 按钮进入游戏配置页面。根据需求配置参数并保存。 参数配置 属性 功能说明 gameId 游戏 ID，可由后台获取 gameKey 游戏 Key，可由后台获取 gameSecret 游戏密钥，可由后台获取 gameType 游戏类型，可根据开发者的需求选择 对战 或者 非对战 gameMode 游戏模式，选择 Runtime lodeType 游戏加载类型，即游戏启动方式。包括 File 和 Url 两种。具体使用方式可查看下方 启动游戏 部分的介绍 path 游戏加载地址，配合 lodeType 使用。具体使用方式可查看下方 启动游戏 部分的介绍 启动游戏 游戏自测工具可以通过以下两种方法启动游戏。 方法一：以文件方式从指定位置加载游戏包（游戏加载类型为 File） 将构建生成的小游戏 cpk 文件（位于 build/cocos-play/dist 目录下）拷贝到手机目录下。如果是拷贝到手机内部存储下，则需要在内部存储目录中新建一个文件夹（命名为 cocosplay），然后将 cpk 文件拷贝到 cocosplay 文件夹中。 游戏自测工具参数配置页面中的 lodeType 选择 File。 path 填写刚才拷贝 cpk 文件放置的新建文件夹，如：cocosplay/game.cpk。 配置完成后点击 保存，然后点击 启动游戏，即可打开游戏。 方法二：以网页方式从指定网址打开游戏（游戏加载类型为 Url） 将 cpk 文件上传到服务器。 游戏自测工具参数配置页面中的 lodeType 选择 Url。 填写 path，如：http://192.168.0.1:8080/game.cpk。 配置完成后点击 保存，然后点击 启动游戏，即可打开游戏。 小游戏环境的资源管理 Cocos Play 与微信小游戏类似，都存在着包体限制，不过 Cocos Play 的主包包体限制是 10MB，超出的部分必须通过网络请求下载。当包体过大时，可在 构建发布 面板配置 资源服务器地址 选项，将资源上传到远程服务器，详情请参考 上传资源到远程服务器。 我们建议用户只保存脚本文件在小游戏包内，其他资源都从远程服务器下载。Cocos Creator 已经帮用户做好了远程资源的下载、缓存和版本管理，详情请参考 缓存管理器。 相关参考链接 Cocos Play 中心 Cocos Play 文档中心 Cocos Play API 文档 Cocos Play 自测工具 Cocos Play 自测工具下载 "},"editor/publish/publish-huawei-quick-game.html":{"url":"editor/publish/publish-huawei-quick-game.html","title":"发布到华为快游戏","keywords":"","body":"发布到华为快游戏 环境配置 下载 华为快应用加载器，并安装到华为手机上（建议 Android Phone 6.0 或以上版本） PC 端全局安装 nodejs-8.1.4 或以上版本 发布流程 使用 Cocos Creator 打开需要发布的项目工程，从 菜单栏 -> 项目 中打开 构建发布 面板。在 构建发布 面板的 发布平台 中选择 华为快游戏。 通用构建选项的设置请参考 通用构建选项，华为快游戏特有的构建选项如下： 构建选项 可选 说明 字段名（用于命令行发布） 初始场景分包 可选项 勾选后，首场景及其相关的依赖资源会被构建到发布包目录 assets 下的内置 Asset Bundle — start-scene 中，提高初始场景的资源加载速度。 startSceneAssetBundle 资源服务器地址 可选项 若 不填写 该项，则发布包目录下的 remote 文件夹将会被打包到构建后生成的 rpk 包中。若 填写，则不会打包进 rpk。开发者需要在构建后手动将发布包目录下的 remote 文件夹上传到所填写的资源服务器地址上，详情请参考 上传资源到远程服务器。 remoteServerAddress 游戏包名 必填项 确保与原生应用的包名不一致，由 数字、字母、. 组成。必须以字母开头，以数字或字母结尾，同时必须包含 .，长度不能超过 255 字节。例如 com.example.demo package 桌面图标 必填项 点击输入框后面的放大镜图标按钮选择所需的图标。构建时，图标将会被构建到华为快游戏的 rpk 中。桌面图标建议使用 png 图片。 icon 游戏版本名称 必填项 游戏版本名称是真实的版本，如：1.0.0 versionName 游戏版本号 必填项 游戏版本号 与 游戏版本名称 不同，游戏版本号 主要用于区别版本更新。每次提交审核时游戏版本号都要比上次提交审核的值至少 +1，一定不能等于或者小于上次提交审核的值，建议每次提交审核时游戏版本号递归 +1注意：游戏版本号 必须为正整数。 versionCode 支持的最小平台版本号 必填项 用于兼容性检查，避免上线后在低版本平台运行导致不兼容。根据华为快游戏的要求目前这个值必须大于或等于 1035。 minPlatformVersion 自定义 manifest 文件路径 可选项 华为快游戏扩展功能。使用时需要选择 json 文件，文件中的数据类型要求为 json 格式。注意：当 json 数据的 key 值为 package、appType、name、versionName、versionCode、icon、minPlatformVersion、config、display 时不可用。否则在构建时会被 应用包名、应用名称、应用图标、应用版本号、应用版本名称 等数据覆盖。 manifestPath 屏幕方向 可选项 可选值包括 landscape 和 portrait。构建后会写入到发布包目录下的 manifest.json 中。 deviceOrientation 是否全屏 可选项 若勾选，则应用运行后处于全屏模式，全屏模式下状态栏也会被覆盖。 fullScreen logLevel 可选项 日志等级 logLevel 密钥库 可选项 若勾选该项，表示构建 rpk 包时默认使用的是 Creator 自带的证书，仅用于 调试 时使用。若 rpk 包要用于提交审核，则构建时不要勾选该项。 若不勾选该项，则需要手动配置签名证书。 useDebugKey certificate.pem 路径private.pem 路径 可选项 如果不勾选 密钥库，则需要配置签名文件 certificate.pem 路径 和 private.pem 路径，此时构建后生成的是可以 直接发布 的 rpk 包。可通过输入框右边的放大镜图标按钮来选择对应的签名文件，或者也可以参考下方的 生成签名文件。注意：这两个签名文件建议不要放在发布包 build/huawei-quick-game 目录下，否则每次构建时都会清空该目录，导致文件丢失。 privatePemPath、certificatePemPath 生成签名文件 有以下两种方式可以生成签名文件： 通过 构建发布 面板 certificate.pem 路径 后的 新建 按钮生成 通过命令行生成 release 签名 用户需要通过 openssl 命令等工具生成签名文件 private.pem、certificate.pem。 # 通过 openssl 命令工具生成签名文件 openssl req -newkey rsa:2048 -nodes -keyout private.pem -x509 -days 3650 -out certificate.pem 注意：openssl 工具在 linux 或 Mac 环境下可在终端直接打开。而在 Windows 环境下则需要安装 openssl 工具并且配置系统环境变量，配置完成后需重启 Creator。 构建 构建发布 面板的构建选项设置完成后，点击 构建并生成 按钮。 完成后点击 构建任务 左下角的文件夹图标按钮打开项目发布包，可以看到在默认发布路径 build 目录下生成了 huawei-quick-game（以具体的构建任务名为准）文件夹，该文件夹就是导出的华为快游戏工程目录和 rpk，rpk 包在 build/huawei-quick-game/dist 目录下。 若需要修改生成的 rpk 包，在修改完成后点击 构建任务 右下角的 生成 按钮，即可在不重新构建的情况下重新生成 rpk 包。 将打包出来的 rpk 运行到手机上 将打包出来的 rpk 运行到手机上有以下两种方式： 点击 构建任务 右下角的 调试 按钮，会弹出一个 快游戏调试工具 面板。在 手机列表 栏目选择手机（如果连接了多台手机），然后在 快游戏调试工具 栏点击 运行 按钮。 这时 rpk 会被推送到之前在手机上已安装完成的 华为快应用加载器 上（如有读写等权限弹出请允许），即可在手机上打开 rpk。 将构建生成的 rpk 包拷贝到手机内部存储目录下。然后在手机上打开 华为快应用加载器 后，点击手机的返回键会弹出一个列表，选择第一个选项 本地安装，选择路径为放置 rpk 的路径，即可将 rpk 运行到手机上。 分包 rpk 分包加载，即把游戏内容按一定规则拆分在几个包里，在首次启动的时候动的消耗时间。 若要使用该功能需要在 Creator 编辑器中配置 小游戏分包，设置完成后在构建时就会自动分包。构建完成后，会在 build/huawei-quick-game/dist 目录下生成 .rpk 文件。 注意：目前华为快游戏不支持同时下载多个分包，需只下载必要的包，这个必要的包称为 主包，开发者可以在主包内触发下载其他子包，这样可以有效降低首次启要下载多个分包时请按顺序下载。 华为快游戏环境的资源管理 华为快游戏与微信小游戏类似，都存在着包体限制, 华为快游戏允许上传的代码包总大小为 10MB，超过的部分必须通过网络请求下载。当包体过大时，可在 构建发布 面板配置 资源服务器地址 选项，将资源上传到远程服务器，详情请参考 上传资源到远程服务器。 我们建议用户只保存脚本文件在小游戏包内，其他资源都从远程服务器下载。Cocos Creator 已经帮用户做好了远程资源的下载、缓存和版本管理，详情请参考 缓存管理器。 相关参考链接 华为快游戏开发文档 "},"editor/publish/publish-oppo-mini-game.html":{"url":"editor/publish/publish-oppo-mini-game.html","title":"发布到 OPPO 小游戏","keywords":"","body":"发布到 OPPO 小游戏 环境配置 下载 OPPO 小游戏调试器，并安装到 OPPO 手机上（建议 Android Phone 6.0 或以上版本） 全局安装 nodejs-8.1.4 或以上版本 发布流程 使用 Cocos Creator 打开需要发布的项目工程，从 菜单栏 -> 项目 中打开 构建发布 面板，发布平台 选择 OPPO 小游戏。 通用构建选项的设置请参考 通用构建选项，OPPO 小游戏特有的构建选项如下： 构建选项 可选 说明 字段名（用于命令行发布） 初始场景分包 可选项 勾选后，首场景及其相关的依赖资源会被构建到发布包目录 assets 下的内置 Asset Bundle — start-scene 中，提高初始场景的资源加载速度。 startSceneAssetBundle 资源服务器地址 可选项 该项用于填写资源存放在服务器上的地址。若 不填写 该项，则发布包目录下的 remote 文件夹会被打包到构建出来的 rpk 包中。若 填写 该项，则不会打包到 rpk 包中，开发者需要在构建后手动将发布包目录下的 remote 文件夹上传到所填写的资源服务器地址上。详情请参考 上传资源到远程服务器。 remoteServerAddress 游戏包名 必填项 游戏包名，根据开发者的需求进行填写，例如 com.example.demo。 package 桌面图标 必填项 点击输入框后面的放大镜图标按钮选择所需的图标。构建时，图标将会被构建到 OPPO 小游戏的工程中。桌面图标建议使用 png 图片。 icon 游戏版本名称 必填项 游戏版本名称是真实的版本，如：1.0.0 versionName 游戏版本号 必填项 游戏版本号 与 游戏版本名称 不同，游戏版本号 主要用于区别版本更新。每次提交审核时游戏版本号都要比上次提交审核的值至少 +1，一定不能等于或者小于上次提交审核的值，建议每次提交审核时游戏版本号递归 +1。注意：游戏版本号 必须为正整数。 versionCode 支持的最小平台版本号 必填项 推荐使用 1060。该项用于兼容性检查，避免游戏上线后在低版本平台运行不兼容。具体内容可点击 使用说明 查看。 minPlatformVersion 屏幕方向 必填项 设备方向，可选值包括 landscape 和 portrait。构建时会写入到发布包目录下的 manifest.json 中。 deviceOrientation 密钥库 - 若勾选该项，表示构建 rpk 包时默认使用的是 Creator 自带的证书，仅用于 调试 时使用。若 rpk 包要用于提交审核，则构建时不要勾选该项。 若不勾选该项，则需要手动配置签名证书。 useDebugKey certificate.pem 路径private.pem 路径 - 如果不勾选 密钥库，则需要配置签名文件 certificate.pem 路径 和 private.pem 路径，此时构建后生成的是可以 直接发布 的 rpk 包。开发者可通过输入框右边的放大镜图标按钮来配置两个签名文件，或者也可以参考下方的 生成签名文件。注意：这两个签名文件建议不要放在发布包 build/oppo-mini-game 目录下，否则每次构建时都会清空该目录，导致文件丢失。 privatePemPath、certificatePemPath 生成签名文件 有以下两种方式可以生成签名文件： 通过 构建发布 面板 certificate.pem 路径 后的 新建 按钮生成 通过命令行生成 release 签名 开发者需要通过 openssl 命令等工具生成签名文件 private.pem、certificate.pem。 # 通过 openssl 命令工具生成签名文件 openssl req -newkey rsa:2048 -nodes -keyout private.pem -x509 -days 3650 -out certificate.pem 注意：openssl 工具在 linux 或 Mac 环境下可在终端直接打开。而在 Windows 环境下则需要安装 openssl 工具并且配置系统环境变量，配置完成后需重启 Creator。 构建 构建发布 面板的构建选项设置完成后，点击 构建并生成 按钮。 完成后点击 构建任务 左下角的文件夹图标按钮打开项目发布包，可以看到在默认发布路径 build 目录下生成了 oppo-mini-game（以具体的构建任务名为准）文件夹，该文件夹就是导出的 OPPO 小游戏工程目录和 rpk，rpk 包在 build/oppo-mini-game/dist 目录下。 若需要修改生成的 rpk 包，在修改完成后点击 构建任务 右下角的 生成 按钮，即可在不重新构建的情况下重新生成 rpk 包。 将构建出来的 rpk 运行到手机上 将构建生成的小游戏 rpk 包（dist 目录中）拷贝到手机的 /内部存储/games 目录。 在 OPPO 手机上打开之前已经安装完成的 OPPO 小游戏调试器，点击 OPPO 小游戏 栏目，然后找到填写游戏名相对应的图标即可，如果没有发现，可点击右上角的 更多 -> 刷新 按钮进行刷新。 注意： OPPO 小游戏调试器为 v3.2.0 及以上的需要将准备好的 rpk 拷贝到手机的 /内部存储/Android/data/com.nearme.instant.platform/files/games 中，如果没有 games 目录则需新建。具体内容可点击 使用说明 — 新建目录 查看。 若使用了分包加载，则分包 rpk 需要拷贝到手机的 /内部存储/subPkg 目录下。同样的，若使用的 OPPO 小游戏调试器为 v3.2.0 及以上的，则需要将分包 rpk 拷贝到手机的 /内部存储/Android/data/com.nearme.instant.platform/files/subPkg 中。详情请参考下文 分包加载 部分的内容。 分包加载 分包加载，即把游戏内容按一定规则拆分成几个包，在首次启动的时候只下载必要的包，这个必要的包称为 主包，开发者可以在主包内触发下载其他子包，这样可以有效降低首次启动的消耗时间。若要使用该功能需要在 Creator 中设置 小游戏分包，设置完成后构建时就会自动分包。 构建完成后，分包的目录在 build/oppo-mini-game/dist 目录下。 这时需要在 OPPO 手机的内部存储目录下新建一个 subPkg 目录，然后把 build/oppo-mini-game/dist 目录下的 .rpk 文件拷贝到 subPkg 目录中。 然后切换到 OPPO 小游戏调试器 的 分包加载 栏目，点击右上方的刷新即可看到分包的游戏名称，点击 秒开 即可跟正常打包的 rpk 一样使用。 分包 rpk 需要拷贝到 OPPO 手机的 /内部存储/subPkg 目录，未分包的 rpk 需要拷贝到 OPPO 手机的 /内部存储/games 目录，两者不可混用。 注意：OPPO 小游戏调试器为 v3.2.0 及以上的，需要将分包 rpk 拷贝到手机的 /内部存储/Android/data/com.nearme.instant.platform/files/subPkg 目录，如果没有 subPkg 目录则需新建。而未分包的 rpk 则是拷贝到手机的 /内部存储/Android/data/com.nearme.instant.platform/files/games 目录，两者同样不可混用。 更多内容请参考 OPPO 小游戏 — 分包加载。 OPPO 小游戏环境的资源管理 OPPO 小游戏与微信小游戏类似，都存在着包体限制。OPPO 小游戏的主包包体限制是 4MB，超过的部分必须通过网络请求下载。当包体过大时，可在 构建发布 面板配置 资源服务器地址 选项，将资源上传到远程服务器，详情请参考 上传资源到远程服务器。 我们建议用户只保存脚本文件在小游戏包内，其他资源都从远程服务器下载。Cocos Creator 已经帮用户做好了远程资源的下载、缓存和版本管理，详情请参考 缓存管理器。 相关参考链接 OPPO 开放平台 OPPO 小游戏教程 OPPO 小游戏 API 文档 OPPO 小游戏工具下载 OPPO 小游戏使用说明 — 新建目录 "},"editor/publish/publish-vivo-mini-game.html":{"url":"editor/publish/publish-vivo-mini-game.html","title":"发布到 vivo 小游戏","keywords":"","body":"发布到 vivo 小游戏 环境配置 下载 快应用 & vivo 小游戏调试器 和 vivo 小游戏引擎，并安装到 Android 设备上（建议 Android Phone 6.0 或以上版本） 全局安装 nodejs-8.9.0 或以上版本 注意：安装 nodejs 后，需要注意 npm 源地址是否为 https://registry.npmjs.org/ # 查看当前 npm 源地址 npm config get registry # 若不是，重新设置 npm 源地址 npm config set registry https://registry.npmjs.org/ 全局安装 vivo-minigame/cli。确定 npm 源地址后，安装 vivo-minigame/cli： npm install -g @vivo-minigame/cli 若 vivo-minigame/cli 安装失败，可能是因为 nodejs 版本过低导致的，请检查 node 版本并升级。 发布流程 使用 Cocos Creator 打开需要发布的项目工程，从 菜单栏 -> 项目 中打开 构建发布 面板，发布平台 选择 vivo 小游戏。 通用构建选项的设置请参考 通用构建选项，vivo 小游戏特有的构建选项如下： 构建选项 可选 说明 字段名（用于命令行发布） 初始场景分包 可选项 勾选后，首场景及其相关的依赖资源会被构建到发布包目录 assets 下的内置 Asset Bundle — start-scene 中，提高初始场景的资源加载速度。 startSceneAssetBundle 资源服务器地址 可选项 该项用于填写资源存放在服务器上的地址。若 不填写 该项，则发布包目录下的 remote 文件夹会被打包到构建出来的 rpk 包中。若 填写 该项，则不会打包到 rpk 包中，开发者需要在构建后手动将发布包目录下的 remote 文件夹上传到所填写的资源服务器地址上。详情请参考 上传资源到远程服务器。 remoteServerAddress 游戏包名 必填项 游戏包名，根据开发者的需求进行填写，例如 com.example.demo。 package 桌面图标 必填项 点击输入框后面的放大镜图标按钮选择所需的图标。构建时，图标将会被构建到 vivo 小游戏的工程中。桌面图标建议使用 png 图片。 icon 游戏版本名称 必填项 游戏版本名称是真实的版本，如：1.0.0 versionName 游戏版本号 必填项 游戏版本号 与 游戏版本名称 不同，游戏版本号 主要用于区别版本更新。每次提交审核时游戏版本号都要比上次提交审核的值至少 +1，一定不能等于或者小于上次提交审核的值，建议每次提交审核时游戏版本号递归 +1。注意：游戏版本号 必须为正整数。 versionCode 支持的最小平台版本号 必填项 用于兼容性检查，避免上线后在低版本平台运行导致不兼容。具体填写的值可通过点击 更新记录 来查看最新的 vivo 引擎版本号。 minPlatformVersion 屏幕方向 必填项 设备方向，可选值包括 landscape 和 portrait。构建时会写入到发布包目录下的 manifest.json 中。 deviceOrientation 允许分离引擎 选填项 vivo 从平台版本号 1063 开始新增了 游戏引擎插件 功能。此插件内置了 Cocos Creator 引擎的官方版本，若玩家首次体验的游戏中启用了此插件，则所有同样启用此插件的游戏，都无需再次下载 Cocos Creator 引擎，只需直接使用公共插件库中的相同版本引擎，或者增量更新引擎即可。使用时勾选 允许分离引擎，然后正常构建发布即可，无需其它人工操作。详情请参考 启用微信小游戏引擎插件 separateEngine 使用调试密钥库 - 若勾选该项，表示构建 rpk 包时默认使用的是 Creator 自带的证书，仅用于 调试 时使用。若 rpk 包要用于提交审核，则构建时不要勾选该项。 若不勾选该项，则需要手动配置签名证书。 useDebugKey certificate.pem 路径private.pem 路径 - 如果不勾选 密钥库，则需要配置签名文件 certificate.pem 路径 和 private.pem 路径，此时构建后生成的是可以 直接发布 的 rpk 包。开发者可通过输入框右边的放大镜图标按钮来配置两个签名文件，或者也可以参考下方的 生成签名文件。 privatePemPath、certificatePemPath 生成签名文件 有以下两种方式可以生成签名文件： 通过 构建发布 面板 certificate.pem 路径 后的 新建 按钮生成 通过命令行生成 release 签名 用户需要通过 openssl 命令等工具生成签名文件 private.pem、certificate.pem。 # 通过 openssl 命令工具生成签名文件 openssl req -newkey rsa:2048 -nodes -keyout private.pem -x509 -days 3650 -out certificate.pem 注意：openssl 工具在 linux 或 Mac 环境下可在终端直接打开。而在 Windows 环境下则需要安装 openssl 工具并且配置系统环境变量，配置完成后需重启 Creator。 构建 构建发布 面板的构建选项设置完成后，点击 构建并生成 按钮。 完成后点击 构建任务 左下角的文件夹图标按钮打开项目发布包，可以看到在默认发布路径 build 目录下生成了 vivo-mini-game（以具体的构建任务名为准）文件夹，该文件夹就是导出的 vivo 快游戏工程目录和 rpk，rpk 包在 build/vivo-mini-game/dist 目录下。 若需要修改生成的 rpk 包，在修改完成后点击 构建任务 右下角的 生成 按钮，即可在不重新构建的情况下重新生成 rpk 包。 运行 rpk 有以下三种方式可将 rpk 运行到手机上： 方法一： 在 构建发布 面板点击 运行 按钮，等待二维码界面生成 然后在 Android 设备上打开之前已经安装完成的 快应用 & vivo 小游戏调试器，点击 扫码安装 按钮直接扫描二维码即可打开 rpk。 方法二： 将构建生成的小游戏 rpk 文件（位于打包出的小游戏工程目录下的 dist 目录中）拷贝到手机的内部存储目录下。 在 Android 设备上打开之前已经安装完成的 快应用 & vivo 小游戏调试器，点击 本地安装，然后从手机内部存储目录中找到 rpk 文件，选择打开即可。 方法三： 利用 vivo 小游戏打包工具命令生成网址和二维码： # 先把命令行指定到编辑器安装目录下的 resources/tools/vivo-pack-tools 目录下 cd ${CocosCreator}/resources/tools/vivo-pack-tools # 生成网址和二维码 npm run server 然后在 Android 设备上打开之前已经安装完成的 快应用 & vivo 小游戏调试器。 最后点击 扫码安装 按钮，将第一步中生成的网址拷贝到浏览器，然后直接扫描网页上的二维码即可打开 rpk。 分包加载 vivo 小游戏的分包加载，详情请参考 小游戏分包。 vivo 小游戏环境的资源管理 vivo 小游戏与微信小游戏类似，都存在着包体限制。vivo 小游戏的主包包体限制是 4MB，超过的部分必须通过网络请求下载。当包体过大时，可在 构建发布 面板配置 资源服务器地址 选项，将资源上传到远程服务器，详情请参考 上传资源到远程服务器。 我们建议用户只保存脚本文件在小游戏包内，其他资源都从远程服务器下载。Cocos Creator 已经帮用户做好了远程资源的下载、缓存和版本管理，详情请参考 缓存管理器。 参考链接 vivo 小游戏开发文档 vivo 小游戏 API 文档 快应用 & vivo 小游戏调试器下载 "},"editor/publish/publish-xiaomi-quick-game.html":{"url":"editor/publish/publish-xiaomi-quick-game.html","title":"发布到小米快游戏","keywords":"","body":"发布到小米快游戏 环境配置 桌面端全局安装 Node.js 8.1.4 或以上版本。 确保 Node.js 所带的 npm 版本最低是 5.2.0。升级 npm 命令如下： # 查看 npm 版本 npm -v # 若 npm 版本在 5.2.0 以下，可使用以下升级命令升级 npm npm install npm@latest -g 下载 小米快游戏调试器和小米快游戏运行环境，并安装到小米手机上（MIUI 8.5.0 或以上版本）。 发布流程 使用 Cocos Creator 打开需要发布的项目工程，从 菜单栏 -> 项目 中打开 构建发布 面板，发布平台 选择 小米快游戏。 通用构建选项的设置请参考 通用构建选项，小米快游戏特有的构建选项如下： 构建选项 可选 说明 字段名（用于命令行发布） 初始场景分包 可选项 勾选后，首场景及其相关的依赖资源会被构建到发布包目录 assets 下的内置 Asset Bundle — start-scene 中，提高初始场景的资源加载速度。 startSceneAssetBundle 资源服务器地址 可选项 该项用于填写资源存放在服务器上的地址。若 不填写 该项，则发布包目录下的 remote 文件夹会被打包到构建出来的 rpk 包中。若 填写 该项，则不会打包到 rpk 包中，开发者需要在构建后手动将发布包目录下的 remote 文件夹上传到所填写的资源服务器地址上。详情请参考 上传资源到远程服务器。 remoteServerAddress 应用包名 必填项 根据开发者的需求进行填写，例如 com.example.demo。 package 桌面图标 必填项 点击输入框后面的放大镜图标按钮选择所需的图标。构建时，图标将会被构建到 vivo 快游戏的工程中。桌面图标建议使用 png 图片。 icon 应用版本名称 必填项 应用版本名称是真实的版本，如：1.0.0 versionName 应用版本号 必填项 应用版本号 与 应用版本名称 不同，应用版本号 主要用于区别版本更新。每次提交审核时应用版本号都要比上次提交审核的值至少 +1，一定不能等于或者小于上次提交审核的值，建议每次提交审核时应用版本号递归 +1。注意：应用版本号 必须为正整数。 versionCode 支持的最小平台版本号 必填项 该项用于兼容性检查，避免上线后在低版本平台运行导致不兼容。根据小米快游戏的要求目前这个值必须大于或等于 1050。 minPlatformVersion 屏幕方向 可选项 设备方向，可选值包括 landscape 和 portrait。构建时会写入到发布包目录下的 manifest.json 中。 deviceOrientation 构建后立即生成 rpk 可选项 在构建完成后自动生成 rpk，无需手动点击 生成 按钮 - 密钥库 可选项 若勾选该项，表示构建 rpk 包时默认使用的是 Creator 自带的证书，仅用于 调试 时使用。若 rpk 包要用于提交审核，则构建时不要勾选该项。 若不勾选该项，则需要手动配置签名证书。 useDebugKey certificate.pem 路径private.pem 路径 可选项 如果不勾选 密钥库，则需要配置签名文件 certificate.pem 路径 和 private.pem 路径，此时构建后生成的是可以 直接发布 的 rpk 包。开发者可通过输入框右边的放大镜图标按钮来配置两个签名文件，或者也可以参考下方的 生成签名文件。 privatePemPath、certificatePemPath 生成签名文件 有以下两种方式可以生成签名文件： 通过 构建发布 面板 certificate.pem 路径 后的 新建 按钮生成 通过命令行生成 release 签名 用户需要通过 openssl 命令等工具生成签名文件 private.pem、certificate.pem。 # 通过 openssl 命令工具生成签名文件 openssl req -newkey rsa:2048 -nodes -keyout private.pem -x509 -days 3650 -out certificate.pem 注意：openssl 工具在 linux 或 Mac 环境下可在终端直接打开。而在 Windows 环境下则需要安装 openssl 工具并且配置系统环境变量，配置完成后需重启 Creator。 构建 构建发布 面板的构建选项设置完成后，点击 构建 按钮。 完成后点击 构建任务 左下角的文件夹图标按钮打开项目发布包，可以看到在默认发布路径 build 目录下生成了 xiaomi-quick-game（以具体的构建任务名为准）文件夹，该文件夹就是导出的小米快游戏工程目录和 rpk 包。 若构建时勾选了 构建后立即生成 rpk 选项，则 rpk 包会生成在 build/xiaomi-quick-game/dist 目录下。 若构建时没有勾选 构建后立即生成 rpk 选项，那么在构建完成后需要点击 构建任务 右下角的 生成 rpk 按钮，来生成 rpk 包。 启动游戏 启动游戏，有以下两种方式： 方法一： 点击 构建任务 右下角的 运行 按钮，等待二维码界面生成。 然后在小米手机上打开之前已经安装完成的 快应用调试器，点击 扫码安装 按钮，直接扫描二维码即可打开 rpk。 方法二： 首先在小米手机上打开 设置-> 更多设置-> 开发者选项，开启开发者选项以及 USB 调试。 使用 USB 数据线将桌面端电脑与手机相连。 将构建生成的快游戏 rpk 文件（位于发布包 build/xiaomi-quick-game/dist 目录下）拷贝到小米手机的内部存储目录中。 在小米手机上打开之前已经安装完成的 快应用调试器，点击 本地安装，然后从手机内部存储目录中找到 rpk 文件，选择打开即可。 调试 调试必须基于真机进行调试，并且必须严格按照先运行游戏再启动调试功能的先后顺序。 启动游戏后，让小米手机处于打开游戏运行的界面。然后使用 USB 数据线将桌面端电脑与小米手机相连，并且小米手机需要开启开发者选项以及 USB 调试。 目前可以通过命令行来启动调试： 指定到编辑器安装目录 resources\\tools\\xiaomi-pack-tools 目录下，执行命令：npm run debug，就会在 Chrome 浏览器中 自动 启动调试界面。 如果想要 手动 打开调试界面，那么执行命令：npm run debug -- --print-only，然后将运行后生成的 URL 地址拷贝到 Chrome 浏览器中打开即可启动调试界⾯。 # 指定到编辑器安装目录下的 resources/tools/xiaomi-pack-tools 目录下 cd ${CocosCreator}/tools/xiaomi-pack-tools # 自动在 Chrome 上打开调试界面 npm run debug # 手动在 Chrome 上打开调试页面 npm run debug -- --print-only 分包 rpk 分包加载，即把游戏内容按一定规则拆分在几个包里，在首次启动的时候只下载必要的包，这个必要的包称为 主包，开发者可以在主包内触发下载其他子包，这样可以有效降低首次启动的消耗时间。 若要使用该功能需要在 Creator 编辑器中配置 小游戏分包，设置完成后在构建时就会自动分包。 分包或者主包的包体大小限制，具体可参考 小米快游戏分包规则。 小米快游戏环境的资源管理 小米快游戏与微信小游戏类似，都存在着包体限制。小米的主包包体限制是 5MB，超过的部分必须通过网络请求下载。当包体过大时，可在 构建发布 面板配置 资源服务器地址 选项，将资源上传到远程服务器，详情请参考 上传资源到远程服务器。 Cocos Creator 已经帮开发者做好了远程资源的下载、缓存和版本管理，具体的实现逻辑请参考 资源管理。 相关参考链接 小米快游戏相关参考链接 "},"editor/publish/publish-baidu-mini-game.html":{"url":"editor/publish/publish-baidu-mini-game.html","title":"发布到百度小游戏","keywords":"","body":"发布到百度小游戏 注意：由于相关合约已到期，自 2022 年 11 月 30 日起，将不再支持百度小游戏的发布和构建。 百度小游戏是基于手机百度 app 上的智能小程序进行扩展的小游戏，它不仅提供了强大的游戏能力，还和智能小程序一样，提供了大量的原生接口，比如支付，文件系统，位置，分享等。相当于同时结合了 WEB 易于传播以及 Native 功能丰富的优势。 百度小游戏的运行环境和微信小游戏类似，基本思路也是封装必要的 WEB 接口提供给用户，尽可能追求和 WEB 同样的开发体验。百度小游戏在智能小程序环境的基础上提供了 WebGL 接口的封装，使得渲染能力和性能有了大幅度提升。不过由于这些接口都是百度团队通过自研的原生实现封装的，所以并不可以等同为浏览器环境。 作为引擎方，为了尽可能简化开发者的工作量，我们为用户完成的主要工作包括： 引擎框架适配百度小游戏 API，纯游戏逻辑层面，用户不需要任何额外的修改 Cocos Creator编辑器提供了快捷的打包流程，直接发布为百度小游戏 自动加载远程资源，缓存资源以及缓存资源版本控制 具体百度小游戏的申请入驻，开发准备，游戏提交，审核和发布流程可以参考 百度小游戏注册指导文档。 准备工作 下载 百度开发者工具 并安装。 在手机的应用商店中下载并安装百度应用 登录 智能小程序平台，找到 AppID。 发布流程 使用 Cocos Creator 打开需要发布的项目工程，从 菜单栏 -> 项目 中打开 构建发布 面板，发布平台 选择 百度小游戏。填入 AppID，然后点击 构建。 通用构建选项的设置请参考 通用构建选项，百度小游戏特有的构建选项如下： 构建选项 可选 说明 字段名（用于命令行发布） 初始场景分包 可选项 勾选后，首场景及其相关的依赖资源会被构建到发布包目录 assets 下的内置 Asset Bundle — start-scene 中，提高初始场景的资源加载速度。 startSceneAssetBundle 设备方向 必填项 可选值包括 landscape 和 portrait。构建时会写入到发布包目录下的 game.json 中。 orientation AppID 必填项 百度小游戏的 AppID，构建时会写入到发布包目录下的 project.swan.json 中。 appid 资源服务器地址 可选项 用于填写资源存放在远程服务器上的地址。开发者需要在构建后手动将发布包目录下的 remote 文件夹上传到所填写的资源服务器地址上。详情请参考 上传资源到远程服务器 remoteServerAddress 生成开放数据域工程模板 可选项 用于接入开放数据域，详情可以参考 开放数据域 buildOpenDataContextTemplate 运行预览 构建完成后点击 构建任务 左下角的文件夹图标按钮打开项目发布包，可以看到在默认发布路径 build 目录下生成了 baidu-mini-game（以具体的构建任务名为准）的百度小游戏工程文件夹，其中已经包含了百度小游戏环境的配置文件：game.json 和 project.swan.json 使用 百度开发者工具 打开构建生成的 baidu-mini-game 文件夹，即可打开百度小游戏项目及预览调试游戏内容。百度开发者工具 的使用方式请参考 百度开发者工具文档。 注意：预览调试时若出现了 当前版本的开发者工具无法发布小程序，请更新最新的开发者工具 的提示，说明填写的 AppID 是小程序的 AppID，不是小游戏的 AppID，请重新申请一个小游戏 AppID。 百度小游戏环境的资源管理 百度小游戏存在着包体限制，超过 4MB 的额外资源，必须通过网络请求下载。当包体过大时，可在 构建发布 面板配置 资源服务器地址 选项，将资源上传到远程服务器，详情请参考 上传资源到远程服务器。 我们建议用户只保存脚本文件在小游戏包内，其他资源都从远程服务器下载。Cocos Creator 已经帮用户做好了远程资源的下载、缓存和版本管理，详情请参考 缓存管理器。 注意：目前百度小游戏在真机上只支持通过 HTTPS 从远程服务器加载资源，所以必须将资源文件放在 HTTPS 服务器上，否则会出现资源加载失败的情况。 分包加载 百度小游戏的分包加载方式和微信小游戏类似，其包体限制如下： 所有包的总大小不超过 8MB 单个分包/主包大小不超过 4MB 具体的分包加载机制请参考 小游戏分包。 平台 SDK 接入 除了纯游戏内容以外，百度小游戏环境还提供了非常强大的原生 SDK 接口，这些接口都是仅存在于百度小游戏环境中的，等同于其他平台的第三方 SDK 接口。这类 SDK 接口的移植工作在现阶段还是需要开发者自己处理。下面列举一些百度小游戏所提供的强大 SDK 能力： 用户接口：登陆，授权，用户信息等 百度收银台支付 转发信息 文件上传下载 其他：图片、位置、广告、设备信息等等 接入百度小游戏的开放数据域 类似微信小游戏，百度小游戏为了保护其社交关系链数据，也实现了一个 开放数据域，可以获取到同玩且双向关注的好友信息。这是一个单独的游戏执行环境。开放数据域中的资源、引擎、程序，都和主游戏完全隔离，开发者只有在开放数据域中才能访问百度小游戏提供的 API swan.getUserInfo()、swan.getUserCloudStorage() 和 swan.getFriendCloudStorage()，用于获取相应的用户数据。 详细的百度小游戏开放域发布流程，请参考 接入开放数据域。 百度小游戏已知问题 目前 Cocos Creator 对百度小游戏的适配工作还未完全结束，暂时还不支持以下组件： VideoPlayer WebView 参考链接 百度小游戏注册指导文档 百度开发者工具文档 百度小游戏 API 文档 百度小游戏分包加载 "},"editor/publish/publish-wechatgame.html":{"url":"editor/publish/publish-wechatgame.html","title":"发布到微信小游戏","keywords":"","body":"发布到微信小游戏 微信小游戏的运行环境是微信小程序环境的扩展，在小程序环境的基础上提供了 WebGL 接口的封装，使得渲染能力和性能有了大幅度提升。不过由于这些接口都是微信团队通过自研的原生实现封装的，所以并不可以等同为浏览器环境。 作为引擎方，为了尽可能简化开发者的工作量，我们为用户完成的主要工作包括： 引擎框架适配微信小游戏 API，纯游戏逻辑层面，用户不需要任何额外的修改 Cocos Creator 编辑器提供了快捷的打包流程，直接发布为微信小游戏，并自动唤起小游戏的开发者工具 自动加载远程资源，缓存资源以及缓存资源版本控制 除此之外，小游戏的游戏提交、审核以及发布流程，和小程序是没有区别的，都需要遵守微信团队的要求和标准流程，具体信息可以参考 微信小游戏开发文档。 环境配置 在 微信官方文档 下载微信开发者工具。 在编辑器主菜单的 Cocos Creator -> 偏好设置 -> 外部程序 中设置微信开发者工具路径。 登录微信公众平台，找到 AppID。 发布流程 使用 Cocos Creator 打开需要发布的项目工程，从 菜单栏 -> 项目 中打开 构建发布 面板。在 构建发布 面板的 发布平台 中选择 微信小游戏。 通用构建选项的设置请参考 通用构建选项，微信小游戏特有的构建选项如下，具体说明请参考下文 构建选项 部分的内容。 构建发布 面板的构建选项设置完成后，点击 构建。 构建完成后点击 构建任务 左下角的文件夹图标按钮打开项目发布包，可以看到在默认发布路径 build 目录下生成了 wechatgame（以具体的构建任务名为准）文件夹，其中已经包含了微信小游戏环境的配置文件：game.json 和 project.config.json。 然后点击微信小游戏 构建任务 右下角的 运行 按钮，打开微信开发者工具。 注意：如果之前没有运行过微信开发者工具，可能会出现：Please ensure that the IDE has been properly installed 的报错，需要手动打开一次微信开发者工具，然后才能在 Cocos Creator 里直接点击 运行 调用。 构建选项 构建选项 说明 字段名（用于命令行发布） 初始场景分包 勾选后，首场景及其相关的依赖资源会被构建到发布包目录 assets 下的内置 Asset Bundle — start-scene 中，提高初始场景的资源加载速度。 startSceneAssetBundle 设备方向 可选值包括 Portrait 和 Landscape。构建时会写入到发布包目录下的 game.json 文件中。 orientation AppID 微信小游戏的 AppID，必填项，面板中默认的 wx6ac3f5090a6b99c5 仅用于测试。构建时会写入到发布包目录下的 project.config.json 文件中。 appid 资源服务器地址 用于填写资源存放在远程服务器上的地址。开发者需要在构建后手动将发布包目录下的 remote 文件夹上传到所填写的资源服务器地址上。详情可参考 上传资源到远程服务器 remoteServerAddress 生成开放数据域工程模板 用于接入开放数据域，详情请参考 开放数据域 buildOpenDataContextTemplate 分离引擎 是否使用微信小游戏引擎插件，详情请参考 启用微信小游戏引擎插件 separateEngine 物理 wasm 实验性功能 用于选择 bullet（ammo.js）物理的使用模式，目前包括 js、fallback、wasm 三种，详情请参考下文 WebAssembly 支持 部分的内容。 - 微信小游戏的资源管理 在微信小游戏环境中，资源管理是最特殊的部分，它和浏览器的不同包括以下几点： 小游戏的主包体积不能超过 4MB，包含所有代码和资源，额外的资源必须通过网络请求下载。当包体过大时，可在 构建发布 面板配置 资源服务器地址 选项，将资源上传到远程服务器，详情请参考 上传资源到远程服务器。 对于小游戏包内资源，小游戏环境内并不是按需加载的，而是一次性加载所有包内资源，然后再启动页面。 不可以从远程服务器下载脚本文件。 这里引出了两个关键的问题： 远程资源的下载、缓存及版本管理，这部分内容 Creator 已经帮开发者做好了，详情请参考 缓存管理器。 首场景的加载速度。当主包资源放到远程服务器上时，如果要提高初始场景的加载速度，可以在构建时勾选 构建发布 面板中的 初始场景分包 选项。 构建完成后，初始场景及其相关的依赖资源会被构建到发布包目录下的 assets/start-scene bundle 中。这个 bundle 不会放到远程服务器上，而是放在本地，引擎在启动阶段时就会自动从本地包内加载这个 bundle，从而加快初始场景的加载速度。 分包加载 微信小游戏的分包加载请参考 小游戏分包 平台 SDK 接入 除了纯游戏内容以外，其实微信小游戏环境还提供了非常强大的原生 SDK 接口，其中最重要的就是用户、社交、支付等，这些接口都是仅存在于微信小游戏环境中的，等同于其他平台的第三方 SDK 接口。这类 SDK 接口的移植工作在现阶段还是需要开发者自己处理。下面列举一些微信小游戏所提供的强大 SDK 能力： 用户接口：登陆，授权，用户信息等 微信支付 转发以及获得转发信息 文件上传下载 媒体：图片、录音、相机等 其他：位置、设备信息、扫码、NFC、等等 WebAssembly 支持 从 Cocos Creator 3.0 开始，微信小游戏的构建选项中新增了 物理 wasm 实验性功能 选项，当编辑器主菜单的 项目 -> 项目设置 -> 功能裁剪 -> 3D -> 物理系统 设置为 bullet（ammo.js） 时生效。目前包括以下几种使用模式： js：使用 js 模式，此模式与以往版本一致。 fallback：自动回退模式，在支持 wasm 的环境中使用 wasm，否则回退到 js。 wasm：使用 wasm 模式。 使用 fallback 模式时，编辑器会打包 wasm 和 js 模式的代码，两个模式对应的代码包体分别为 1.2MB 和 0.7MB，总共接近 2MB，这对主包 4MB 的限制影响很大。解决办法是通过配置子包来减轻主包的压力，这里以 ammo-82499473.js 文件为例，操作步骤如下： 修改 game.json，增加子包配置。 { //*, \"subpackages\": [{ \"name\": \"ammo\", \"root\": \"cocos-js/ammo-82499473.js\" }] } 修改 game.js 的 init 方法，提前加载子包。 // 大致在第 55 行左右 window.__globalAdapter.init(function() { fsUtils.loadSubpackage('ammo', null, (err) => { System.import('./cocos-js/ammo-82499473.js').then(() => { return System.import('./application.js').then(({ createApplication }) => { return createApplication({ loadJsListFile: (url) => require(url), loadAmmoJsWasmBinary, }); }).then((application) => { return onApplicationCreated(application); }).catch((err) => { console.error(err); }); }) }); }); 注意： 微信小游戏引擎插件目前仅支持 js 模式。 微信 WebAssembly 要求微信版本为 v7.0.17 及以上。 微信 WebAssembly 要求微信开发者工具的调试基础库为 v2.12.0 及以上。 推荐使用 fallback 模式以得到更全面的设备支持。 微信小游戏的限制 微信小游戏不支持 WebView。 参考链接 微信小游戏开发文档 微信公众平台 小游戏 API 文档 微信开发者工具下载 微信开发者工具文档 "},"editor/publish/wechatgame-plugin.html":{"url":"editor/publish/wechatgame-plugin.html","title":"启用微信小游戏引擎插件","keywords":"","body":"微信小游戏引擎插件使用说明 游戏引擎插件是微信 v7.0.7 新增的一项功能。此插件内置了 Cocos Creator 引擎的官方版本，若玩家首次体验的游戏中启用了此插件，则所有同样启用此插件的游戏，都无需再次下载 Cocos Creator 引擎，只需直接使用公共插件库中的相同版本引擎，或者增量更新引擎即可。 例如，当一个玩家玩过了由 Cocos Creator v2.2.0 开发的 A 游戏，里面已启用了此插件。然后他又玩了同样是 v2.2.0 开发的 B 游戏，如果 B 游戏也启用了此插件，那么就无需重新下载 Cocos Creator 引擎。即使 B 游戏使用的是 v2.2.1 的 Cocos Creator，微信也只需要增量更新引擎两个版本的差异部分。这样就可以大幅减少小游戏的下载量，提升小游戏启动速度 0.5 ~ 2s，获得更好的用户体验。 使用说明 Cocos Creator 只需在 构建发布 面板中，勾选 分离引擎 选项，然后正常构建发布即可，无需其它人工操作。（此功能仅在编辑器使用内置引擎并且构建时使用 非调试模式 时生效） Q&A Q：引擎插件功能是否支持自定义引擎？ A：不支持，构建时如果版本不匹配或者启用了自定义引擎，虽然编辑器在出现报错后会继续构建，但是构建生成的包实际上无法正常使用引擎插件。 Q：项目开启了引擎的模块裁剪，要使用引擎插件的话需要还原为完整版引擎吗？ A：无需修改，项目可以按原来的方式继续裁剪引擎。引擎插件提供的是完整版引擎，能兼容所有的裁剪设置，不会影响原有项目的包体。 Q：启用引擎插件后，是否仍然会把引擎代码算入首包包体中？ A：根据微信的规则，目前仍然会计算在内。 Q：开启引擎插件后，是否可以在编辑器主菜单中的 项目 -> 项目设置 -> 功能裁剪 中移除所有模块，减小包体？ A：不可以，因为微信从 7.0.7 开始才支持引擎插件，如随意裁剪引擎可能导致游戏无法在低版本微信上运行。 Q：启用引擎插件后，在微信开发工具中提示 “代码包解包失败” 或者 “..., 登录用户不是该小程序的开发者”，但真机预览正常？ A：构建面板中默认的 appid 为通用测试 id。根据微信的规则，如需测试引擎分离功能，需要开发者在构建面板中填入自己开通的 appid。 Q：启用引擎插件后，在微信开发工具中提示 “插件未授权使用 添加插件”？ A：点击提示中的 添加插件，选择添加 CocosCreator 插件后重新编译即可。若添加插件时出现“可添加的插件信息为空”的提示，可尝试在微信开发者工具中选择 清缓存 -> 全部清除 后重试。 参考链接 微信小游戏引擎插件官方说明 "},"editor/publish/publish-pc-wechatgame.html":{"url":"editor/publish/publish-pc-wechatgame.html","title":"接入微信 PC 小游戏","keywords":"","body":"接入微信 PC 小游戏 微信 PC 小游戏即支持在微信 PC 版打开微信小游戏。PC 小游戏将具备移动端的大部分能力，包括但不限于虚拟支付、开放数据域、触摸事件等（广告目前暂不支持）。同时 PC 小游戏还支持键盘、鼠标事件及自定义窗口等功能。 Cocos Creator 支持将游戏发布到微信 PC 小游戏，并完成了鼠标、键盘相关接口的适配工作。下面我们来看看，如何通过 Cocos Creator 将游戏发布到微信 PC 小游戏平台。 使用 Cocos Creator 接入微信 PC 小游戏 准备工作 下载并安装最新版本的 微信 PC 版，使用微信开发者工具绑定的微信号登录微信 PC 版。 发布流程 参考 发布到微信小游戏 的流程，将项目工程发布到微信小游戏。 在 微信开发者工具 中，点击上方工具栏中的 预览 按钮，选择 自动预览 选项卡，勾选 启动 PC 端自动预览，然后点击 编译并预览，即可在微信 PC 版预览并调试小游戏。 常见问题 Q：如何通过引擎接口区分微信的 移动端 与 PC 端？ A：可以通过 sys.isMobile 判断，PC 端返回 false，移动端返回 true。 注意：微信开发者工具中的模拟器，模拟的是移动端环境，所以这里返回的是 true。 Q：微信 PC 小游戏支持 Mac 系统吗？ A：暂时不可以。截至 2021-01-19，微信 PC 小游戏已经正式上线，暂时只支持 Windows 系统。后续我们也将积极配合微信 PC 小游戏的工程师们，第一时间适配 Mac 系统。 相关链接 微信 PC 小游戏接入指南 微信 PC 版下载 "},"editor/publish/build-open-data-context.html":{"url":"editor/publish/build-open-data-context.html","title":"开放数据域","keywords":"","body":"开放数据域 目前，微信、百度 和 字节跳动 小游戏这些平台为了保护其社交关系链数据，增加了 开放数据域 的概念，这是一个单独的游戏执行环境。开放数据域中的资源、引擎、程序，都和主游戏（主域）完全隔离，开发者只有在开放数据域中才能通过平台提供的开放接口来访问关系链数据，用于实现一些例如排行榜的功能。 开放数据域目前只支持 Canvas 渲染，在 Cocos Creator 3.0 中，我们废弃了之前的 Canvas Renderer 模块，使用微信团队基于 XML + CSS 设计研发的一个前端轻量级 Canvas 引擎来替代。并且将该引擎整合进了 Creator 3.0 内置的开放数据域工程模板中，开发者只需要掌握一些基本的前端技能，就能在该模板的基础上定制排行榜功能。 SubContextView 组件说明 由于开放数据域只能在离屏画布 sharedCanvas 上渲染，所以在项目中，需要有一个节点作为渲染开放数据域的容器，并在该节点上添加 SubContextView 组件，该组件会将 sharedCanvas 渲染到容器节点上。 SubContextView 组件主要包含 设计分辨率 和 FPS 两个属性。 设计分辨率 若将 SubContextView 组件的 设计分辨率 设置为 640 * 960，则在组件加载完成阶段，sharedCanvas 的尺寸会被设置为 640 * 960。意味着构建之后，开放数据域工程都是在一张 640 * 960 的离屏画布上做渲染的。那么，在定制开放数据域（参考下文）时，style.js 中标签的样式最大尺寸为 640 * 960，否则渲染的内容会超出画布。例如： // style.js export default { container: { width: 640, // max width height: 960, // max height }, } 同时为了避免数据耦合，标签的样式还支持设置宽高的百分比： // style.js export default { container: { width: '100%', height: '100%', }, } 在实际渲染过程中，引擎会采用 SHOW ALL 的适配策略将 sharedCanvas 渲染到 SubContextView 组件节点上，避免渲染时因拉伸导致的 UI 变形。例如在以下两张图片里，我们使用了不同尺寸的 SubContextView 组件节点，开放数据域的贴图都不会被拉伸： 设置 FPS FPS 属性主要用于设置主域更新 sharedCanvas 到 SubContextView 组件上的频率，避免因频繁更新开放数据域贴图造成的性能损耗。 发布流程 打开项目并双击场景，然后在需要渲染开放数据域的节点上添加 SubContextView 组件。 场景设置完成后保存场景，然后在 菜单栏 -> 项目 中打开 构建发布 面板，选择需要发布的 微信 / 百度 / 字节跳动小游戏 平台，勾选 生成开放数据域工程模版，然后点击 构建。 构建完成后点击 构建任务 左下角的文件夹图标按钮，可以看到在对应小游戏平台的发布包目录下生成了 openDataContext 文件夹（例如 build/wechatgame/openDataContext），该文件夹就是 Cocos Creator 内置的开放数据域工程模版。 开发者可以基于这个模板定制所需的开放数据域内容，定制方法参考下文 定制开放数据域工程 部分的内容。当再次构建时，如果发布包目录下存在 openDataContext 目录，则会直接跳过，开发者不用担心定制的开放数据域内容被覆盖掉。 使用对应平台方的开发者工具打开构建生成的发布包（例如 build/wechatgame），即可打开小游戏项目查看开放数据域内容，以及预览调试游戏。 注意：由于百度小游戏的开放数据域只支持加载百度返回的玩家头像，所以构建后生成的开放数据域模版工程可能会因此无法正常加载本地的头像贴图。 定制开放数据域工程 在定制开放数据域工程之前，开发者需要先了解一些基础信息： minigame-canvas-engine 快速入门 doT 模版引擎使用 对这些基础信息有了大致的了解之后，我们来看一下构建后默认生成的开放数据域模版，目录结构如下： render/dataDemo.js：模拟随机的排行榜数据，开发者可以在这里请求平台方的关系链数据，并传给 doT 模版引擎 生成相应的 XML 文本 render/style.js：记录 CSS 样式文本信息，可参考 样式文档 render/template.js：记录 XML 文本信息，默认使用 doT 模版引擎 生成 XML 文本。可参考 标签文档 render/avatar.png：开放数据域模板默认使用的头像贴图，可删除 engine.js：小游戏 Canvas 引擎源码 index.js：开放数据域工程入口文件，在该文件中通过将 XML 文本和 CSS 样式传递给 Canvas 引擎，即可渲染开放数据域 推荐做法 由于项目构建后生成的 build 目录默认会被 git 排除在版本控制外，所以如果开发者希望将定制后的开放数据域纳入版本控制，可以将 openDataContext 文件夹（例如 build/wechatgame/openDataContext）放入项目的 build-templates 目录中，具体可参考 定制项目构建流程 在开放数据域工程中，如果需要监听来自主域的消息，则需要先判断消息是否来自主域引擎，以微信接口为例： wx.onMessage(res => { if (!(res && res.type === 'engine')) { console.log('do something...'); } }); 当主域向开放数据域发送消息时，建议附带上 type 信息以避免处理错误的消息源。例如上述代码中的 res.type === 'engine' 表示消息来源于主域引擎。 参考链接 微信官方文档 — 小游戏 Canvas 引擎 小游戏 Canvas 引擎源码 doT 模版引擎 Cocos Creator 小游戏开放数据域范例工程：GitHub | Gitee "},"editor/publish/subpackage.html":{"url":"editor/publish/subpackage.html","title":"小游戏分包","keywords":"","body":"小游戏分包 部分小游戏平台支持分包功能以便对资源、脚本和场景进行划分，包括微信小游戏、百度小游戏、小米快游戏、字节跳动小游戏、华为快游戏、OPPO 小游戏和 vivo 小游戏。 Cocos Creator 从 v2.4 开始支持 Asset Bundle，开发者可以将需要分包的内容划分成多个 Asset Bundle，这些 Asset Bundle 会被构建成小游戏的分包。在启动游戏时只会下载必要的主包，不会加载这些分包，而是由开发者在游戏过程中手动加载分包，从而有效降低游戏启动的时间。 配置方法 Asset Bundle 是以 文件夹 为单位进行配置的。当我们在 资源管理器 中选中一个文件夹时，属性检查器 中就会出现一个 配置为 Bundle 的选项，勾选后会出现如下图的配置项： 除了通用的 Asset Bundle 配置 之外，小游戏分包主要需要关注的设置包括： 将 目标平台 设置成需要分包的小游戏平台，压缩类型 设置为 小游戏分包。 小游戏分包只能放在本地，不能配置为远程包，所以 配置为远程包 项为锁住状态，不可勾选。 配置完成后点击右上方的 打勾 按钮，这个文件夹就被配置成 Asset Bundle 了。 构建 在构建时，需要将 构建发布 面板中的 主包压缩类型 设置为 小游戏分包。具体说明可参考文档 Asset Bundle — 压缩类型。 项目构建完成后，这个 Asset Bundle 文件夹会被打包到小游戏平台发布包目录下的 subpackages 文件夹中。该文件夹中包含的每个文件夹都是一个 Asset Bundle。 例如：将 Hello World 工程中的 assets/scene 文件夹在微信小游戏平台配置为 Asset Bundle，那么项目构建后将会在微信小游戏发布包目录下生成 subpackages/scene 文件夹。scene 文件夹就是一个 Asset Bundle。 微信小游戏 在微信小游戏的构建中，Asset Bundle 的配置也会按照规则自动生成到微信小游戏发布包目录下的 game.json 配置文件中。 注意：微信小游戏需要特定的版本才能支持分包功能。微信 6.6.7 客户端，2.1.0 及以上基础库开始支持，请更新至最新客户端版本，开发者工具请使用 1.02.1806120 及以上版本。更新了开发者工具后不要忘记修改开发者工具中的 详情 -> 本地设置 -> 调试基础库 为 2.1.0 及以上： 分包加载包大小的限制 目前微信小游戏分包大小有以下限制： 整个微信小游戏所有分包大小不超过 20M 单个分包不限制大小 主包大小不能超过 4M 具体请参考 微信小游戏分包加载官方文档。 vivo 小游戏 在 vivo 小游戏的构建中，Asset Bundle 的配置也会按照规则自动生成到 vivo 小游戏发布包 vivo-mini-game/src 目录下的 manifest.json 配置文件中。以配置 scene 文件夹为例： 注意： 快应用 & vivo 小游戏调试器 从 1051 版本开始支持 vivo 小游戏分包加载。低于 1051 的版本虽然不支持分包加载，但是也做了兼容处理，如果使用了分包也不会影响游戏正常运行。具体可参考 vivo 分包加载-运行时兼容。 与其他小游戏平台不同的是，项目构建后 vivo 小游戏的 Asset Bundle 文件夹是生成在发布包 vivo-mini-game 目录下的 src 目录。 分包加载包的限制 目前 vivo 小游戏分包大小限制为 20M（主包限制 4M 及分包大小限制 16M）。 具体请参考 vivo 小游戏官方文档 — 分包加载。 "},"editor/publish/publish-in-command-line.html":{"url":"editor/publish/publish-in-command-line.html","title":"命令行发布项目","keywords":"","body":"命令行发布项目 命令行发布项目可以帮助开发者构建自己的自动化构建流程，通过修改命令行的参数来达到不同的构建需求。 命令行发布参考 例如：构建 web-desktop 平台、Debug 模式 Mac /Applications/CocosCreator/Creator/3.0.0/CocosCreator.app/Contents/MacOS/CocosCreator --project projectPath --build \"platform=web-desktop;debug=true\" Windows ...\\CocosCreator.exe --project projectPath --build \"platform=web-desktop;debug=true\" 目前命令行构建除了必填项外，如果不传递一律使用默认值来构建，具体参数默认值请参考下方描述以及平台的参数介绍。 进程退出码 332 构建失败 —— 构建参数不合法 334 构建失败 —— 构建过程出错失败，详情请参考构建日志 336 构建成功 构建参数 --project：必填，指定项目路径 --build：指定构建项目使用的参数 在 --build 后如果没有指定参数，则会使用 Cocos Creator 中 构建发布 面板当前的平台、模板等设置来作为默认参数。如果指定了其他参数设置，则会使用指定的参数来覆盖默认参数。可选择的参数有： configPath - 参数文件路径。如果定义了这个字段，那么构建时将会按照 json 文件格式来加载这个数据，并作为构建参数。这个参数可以自己修改也可以直接从构建面板导出，当配置和 configPath 内的配置冲突时，configPath 指定的配置将会被覆盖。 includedModules - 定制引擎打包功能模块，只打包需要的功能模块。具体有哪些功能模块可以参考引擎仓库根目录下 cc.config.json（GitHub | Gitee）文件中的 features 字段。 outputName - 构建后生成的发布包文件夹名称。 name - 游戏名称 platform - 必填，构建的平台，具体名称参考面板上对应插件名称即可 buildPath - 指定构建发布包生成的目录，默认为项目目录下的 build 目录。可使用绝对路径或者相对于项目的路径（例如 project://release）。目前暂不支持使用 ../ 这样的相对路径，预计会在 v3.4.2 支持。 startScene - 主场景的 UUID 值（参与构建的场景将使用上一次的编辑器中的构建设置），未指定时将使用参与构建场景的第一个 scenes - 参与构建的场景信息，未指定时默认为全部场景，具体格式为：{} debug - 是否为 debug 模式，默认关闭 packAutoAtlas - 是否开启自动图集，默认关闭 compressTexture - 是否开启压缩纹理，默认关闭 replaceSplashScreen - 是否替换插屏，默认关闭 md5Cache - 是否开启 md5 缓存，默认关闭 mainBundleCompressionType - 主包压缩类型，具体选项值可参考文档 Asset Bundle — 压缩类型。 mainBundleIsRemote - 配置主包为远程包 packages - 各个插件支持的构建配置参数，需要存放的是对于数据对象的序列化字符串，具体可以参考下文。 Cocos Creator 3.0 各个平台的构建会作为独立的插件嵌入到 构建发布 面板中，因而各个平台的构建参数位置也不同。各个平台的构建参数会配置在 packages 字段中，例如：为微信小游戏指定构建参数，配置大体如下： { taskName: 'wechatgame', packages: { wechatgame: { appid: '*****', } } } 之后在构建插件支持对外开放，其他插件的配置参数也会通过同样的方式嵌入到 构建发布 面板中。具体各个平台的参数字段 请参照各个平台文档中的参数介绍，最好是通过 构建发布 面板的 导出 功能来获取配置参数，更加方便快捷。目前依旧兼容旧版本的参数进行构建，但之后将会移除该兼容处理，请尽快升级配置参数。 在 Jenkins 上部署 Cocos Creator 命令行运行的时候也是需要 GUI 环境的。如果你的 Jenkins 无法使用 Cocos Creator 命令行运行，一个解决办法是：确保 Jenkins 运行在 agent 模式下，这样才能访问到 WindowServer。详情请参考 https://stackoverflow.com/questions/13966595/build-unity-project-with-jenkins-failed。 如果你的 Jenkins 在 Windows 下无法编译，请在 Windows 的 控制面板 -> 管理工具 -> 服务 中为 Jenkins 的服务指定一个本地用户，然后重启电脑就可以了。不必单独设置一个 master-slave 模式。 "},"editor/publish/build-guide.html":{"url":"editor/publish/build-guide.html","title":"构建流程简介与常见错误处理","keywords":"","body":"构建流程简介与常见问题指南 构建基础结构介绍 构建流程主要包括以下两部分内容： 通用构建处理 各平台构建处理 由于 v3.0 在构建机制上的调整，不同平台的构建处理均以 构建插件 的形式注入 构建发布 面板，以及参与构建流程。各平台特有的构建选项也会以展开选项的形式显示在 构建发布 面板，开发者可以通过 构建插件 将自定义的构建选项显示在 构建发布 面板上。 通用构建处理流程 Cocos Creator 的通用构建流程，主要包括以下内容： 构建选项初始化 构建数据整理 将构建后的资源写入文件系统 整理 settings.json/config.json 数据 config.json 中的 UUID 压缩与文件写入 构建选项初始化 这个步骤主要是将构建时传递给构建的 原始 options 初始化为 构建内部的 options，完成部分构建选项的格式转换、项目配置初始化、构建资源数据库的资源数据初始化、查询最新的资源信息并分类。 构建数据整理 构建时，编辑器会先整理出当前参与构建的场景以及所有 Bundle 文件夹中的资源，再通过引擎的反序列化查找出这些资源的依赖资源，层层递归查找出所有需要打包的资源列表。这份资源列表汇总完成后，便会根据 Bundle 配置对资源进行分类，并收集脚本编译任务、图片压缩任务和 json 分组信息等。 注意： 引擎在反序列化之前会先加载所有的用户脚本，脚本是否加载成功会直接影响到资源反序列化，所以如果脚本编写不合法，会直接构建失败。 如果资源整理过程中发现有依赖资源丢失会直接报错，通常情况下会继续进行构建。虽然允许继续构建成功，但并不意味着问题不需要解决，如果资源丢失不解决，很难保证构建后的游戏包允许没有问题。 将构建后的资源写入文件系统 构建后的资源会根据 Asset Bundle 的配置在构建完成后打包到对应平台发布包目录下的 assets/[Bundle 名称] 中，目录结构如下： 更多关于 Asset Bundle 的配置、构建、文件说明等内容，请参考 Asset Bundle 文档。 在整理完基本的构建任务后，构建将会循环所有的 Bundle，依次执行完每个 Bundle 需要处理的资源打包任务，生成这些 Bundle 资源包。 每个 Bundle 都会经过以下资源处理流程： 脚本构建：编辑器内的脚本分为 插件脚本 和 非插件脚本 两类，不同种类的处理规则不同。 插件脚本：直接将源文件按照原来的目录结构拷贝到构建后生成的发布包目录下的 src 目录中，所以插件脚本是不支持任何需要编译的脚本形式的，比如 TypeScript 或者是使用 ES6 写法的 JavaScript。插件脚本的资源信息会写进 settings.json 的 jsList 数组中。 非插件脚本：将会全部打包成 project.js，放在对应的 src 目录下。勾选 sourceMap 选项将会生成对应的 .map 文件，根据 debug 选项来影响脚本是否混淆压缩。 自动图集处理：查询项目内部的自动图集资源列表，根据自动图集资源的配置将图集下的 SpriteFrame 小图打包成大图、生成序列化文件等等。这一步骤也会修改 json 分组信息、asset 资源分组信息以及根据需要添加纹理压缩任务。 纹理压缩：根据整理好的图片压缩任务，进行图片资源的压缩处理并写入到构建文件夹内。 引擎脚本编译：根据顶部菜单栏中 项目设置 -> 功能裁剪 的配置，剔除没有使用到的引擎模块，打包到 cocos-js 目录下。勾选 sourceMap 选项将会生成对应的 .map 文件，根据 debug 选项来确定脚本是否混淆压缩。 引擎编译的主要步骤包括： 获取 项目设置里的引擎模块信息； 检查缓存 中的引擎编译选项与当前需要编译的选项是否一致，一致则直接使用缓存； 如需编译，则执行打包引擎的任务，之后拷贝编译后的 js 文件，并保存引擎的缓存判断信息文件； 编译引擎时，可以查看 输出的 log 信息： 关于引擎文件的复用规则，这里有必要阐述下： 打包好的引擎文件将会放置在编辑器全局的临时目录下 (在构建进程内使用 Build.globalTempDir 可查询到缓存地址)。缓存文件按照会影响引擎编译的参数生成的 hash 值作为名称存放。 global-temp-folder |--CocosCreator |--x.xx(3.0.0) |--builder |--engine |--1dc4a547f9...63a43bb8965.watch-files.json |--1dc4a547f9...63a43bb8965（引擎文件夹） |--1dc4a547f9...63a43bb8965.meta（文件夹） ... 只要任何相关的引擎构建参数发生更改，就会重新编译引擎，具体影响构建引擎缓存使用的有： debug：是否打开调试模式 includeModules：引擎模块设置 sourceMaps：是否开启 sourceMaps platform：构建平台 引擎修改时间 是否勾选分离引擎（仅微信小游戏平台） 使用引擎路径、引擎版本号 json 构建：序列化 json 时会根据 json 分组以及所属 Bundle 进行合并写入文件系统（assets/xxxBundle/import 文件夹内），如果是 release 模式还会对序列化 json 内的 UUID 进行压缩处理。 普通资源拷贝：一些原始资源（rawAssets）会直接从 library 拷贝到构建后的 assets/xxxBundle/native 文件夹内。 md5 处理：将 assets 文件夹内的资源、项目脚本、引擎文件全部加上 md5 后缀，并整理数据准备记录在 settings.json 内。 application.js 文件生成：根据用户选项动态生成 application.js 文件到构建后生成的发布包目录的 src 目录下。 整理 settings/config 配置 JSON 数据 主要是根据之前资源整理的数据，准备游戏启动必要的配置信息。 settings.json settings.json 记录了整个游戏包的基本配置信息，会直接影响到游戏包的运行初始化。 关于 settings.json 配置的说明如下： { debug: boolean; // 是否为调试模式，取自构建发布面板 designResolution: ISettingsDesignResolution; // Canvas 分辨率设置，取自项目设置中的数据 jsList: string[]; // 插件脚本信息 launchScene: string; // 初始场景 url moduleIds: string[]; // 所有用户脚本组件的信息 platform: string; renderPipeline: string;// renderPipeline 信息，取自项目设置 physics?: IPhysicsConfig;// 物理模块设置（仅在勾选了物理引擎模块时生成） BundleVers: Record; // Bundle 的 md5 值 subpackages: string[]; // 分包信息 remoteBundles: string[]; // 记录远程包 Bundle 的集合 server: string; // 记录远程服务器地址（注意：v3.4 之前该项存放在 `application.js` 文件中） hasResourcesBundle: boolean; // 是否含有 resources 内置 Bundle hasStartSceneBundle: boolean; // 是否含有初始场景内置 Bundle customJointTextureLayouts?: ICustomJointTextureLayout[]; macros?: Record; // 项目设置面板中的引擎宏配置值 } config.json 每个 Bundle 资源包都有一个 config.json，里面记录了整个 Bundle 的资源、脚本等基本信息，会直接影响到 Bundle 包的加载。 关于 config.json 配置的说明如下： { importBase: string; // Bundle 中 import 目录的名称，通常是 'import' nativeBase: string; // native 中 native 目录的名称，通常是 'native' name: string; // Bundle 的名称，可以通过 Bundle 名称加载 Bundle deps: string[]; // 该 Bundle 依赖的其他 Bundle 名称 scenes: Array; // Bundle 内包含的场景信息数组 rawAssets: { [index: string]: { [uuid: string]: string[] } }; // 存储 resources 下加载的资源 url 与类型 // 示例: \"bba00d3a-2f17-4511-b47c-0d584b21b763@6c48a\": [\"test/right/texture\", \"cc.Texture2D\", \"bba0...@6c48a\"] // \"bba0...@6c48a\": [\"test/right/texture\", 1, 1] packs: Record; // json 分组信息 versions: { import: Array; native: Array; }; // 勾选 md5Cache 后才有，数组部分以 [uuid_1, md5_1, uuid_2, md5_2, ...] 的格式存储，其中 uuid_1 如果是个简单数字说明存储的是 uuids 数组内的 uuid 索引 uuids: string[]; // uuid 数组，仅 release 模式下 types?: string[]; // 资源类型数组，仅 release 模式下 encrypted?: boolean; // 原生上使用，标记该 Bundle 中的脚本是否加密 isZip?: boolean; // 是否为 ZIP 模式 zipVersion?: string; // ZIP 包的 MD5 Hash 值 } 这里的结构仅列举了通用流程下 settings.json/config.json 的结构，实际上不同的平台构建后这些参数会有所差异。 压缩 config.json 在生成 config.json 之前会根据是否为 release 模式来压缩文件中的 UUID 信息，了解这个规则对查找资源构建后的文件位置会有帮助。 构建时会对 Bundle 内使用到的 UUID 进行整理，出现 两次及以上 的会存储到 uuids 数组中，并将之前使用到的 UUID 的位置替换为索引。 所有出现 两次及以上 的 types 也会存储到 types 数组中，并将之前使用到的位置替换为索引。 构建资源 该步骤是生成除了脚本以外的其他项目资源文件，因为脚本是作为特殊文件另外编译处理的。资源在打包过程中执行反序列化后会重新压缩序列化，以减小打包之后的包体。会根据之前数据整理的 JSON 分组信息将多个序列化 JSON 合并单个，例如 texture 资源的序列化文件会全部打包成一个 json 文件。 各平台构建处理 构建提供了构建生命周期的钩子函数，方便开发者在构建的不同处理时期参与构建流程，影响构建结果。同时构建也支持开发者添加自定义构建选项的配置，通过简单配置可以直接在 构建发布 面板显示对应的新增参数，详情请参考 扩展构建流程。构建插件注入的构建选项将会存放在 options.packages[pkgName] 内，因而目前通过命令行构建的选项参数也需要遵循此规则，对应参数的规则可通过点击 构建发布 面板右上方的 导出构建配置 进行参考。 各平台的编译/生成流程 自 Cocos Creator 3.0 起，所有需要支持单独编译、生成的平台的构建流程都已经拆分出来，可能会有部分开发者疑惑现今的小游戏平台为何新增了 生成 按钮，事实上之前这部分逻辑也一直存在，只不过合并在 构建 中，无法进行单独控制。 编辑器的 构建 类似于一个 导出对应平台游戏包 的功能，主要是完成引擎对各个平台的接口、以及游戏包基本格式兼容，并不代表完成全部工作。各个平台通常还会有自己的编译流程，例如微信小游戏平台自带的开发者工具的编译上传功能，以及各个原生平台相关 IDE 的编译运行调试功能。如果开发者需要针对特定平台进行定制化打包处理，就需要编辑器先支持流程上的拆分才能更好地接入。 常见问题指南 构建的整个进程是在一个单独的 worker 内的，所以如果想要查看构建过程的完整日志信息或者查看出现报错时完整的调用栈，可以点击主菜单的 开发者 -> 打开构建调试工具 查看。构建时其实会输出很多的日志信息，但是为了不干扰用户，默认只有错误、警告和一些重要的日志信息会被打印到编辑器的 控制台 面板。 注意：在构建之前 请先确保参与构建的场景是可以正常预览的。一些场景的资源丢失或者其他脚本问题，是在预览阶段便能暴露出来的。在保证预览正常的情况下构建能更好地节约时间以及排查问题。 资源加载 404 这种情况下，请复制报错资源丢失的日志中的 UUID 到 资源管理器 中查找对应的资源，查看该资源依赖的资源是否都正常。资源加载 404 通常有以下几种情况： 在脚本内动态加载了没有放在 Bundle 中的资源。 原因：通过上面的介绍，我们知道只有在 Bundle 目录下的资源及其依赖资源，以及参与构建场景的资源及其依赖资源才会被打包到最终的构建文件夹中，并且 只有直接放进 Bundle 文件夹中的资源 url 才会写入到 config.json。所以如果在脚本中使用了某个资源但这个资源没有放在任何 Bundle 目录下，加载的时候便会出现 404 了。 解决方案：将使用到的资源移动在 Bundle 文件夹下。 加载的资源导入有问题，未能正常生成数据到 library 中 原因：构建时所有的原始数据都是通过读取 library 中的资源文件获得的，如果导入失败将无法获取到正确对应的资源信息。 解决方案：通过 资源管理器 找到对应资源，点击右键，选择菜单中的 重新导入资源。 资源丢失 原因：在前面的构建流程中介绍过，资源的构建会经过反序列查找依赖资源，而最经常出现问题的就是所依赖的资源在项目迭代过程中被不小心删除而导致资源丢失。这些资源的丢失可能平时并没有注意到，但一旦执行构建便会暴露出来。 解决方案：通过代码编辑器查找该 UUID 被哪些资源所引用，修改对应资源。 脚本资源加载报错 在前面介绍的 构建数据整理 部分内容时有提到过，构建时需要配置脚本环境。如果报错信息与脚本相关，请参考报错内容对脚本进行修改。如果不清楚是哪个脚本的报错，可以在报错信息调用栈中找到对应脚本的 UUID，然后在 资源管理器 中查找定位。 如何查找到小图自动合图后的大图 自动图集在构建过程中会打印出原始小图与合成的大图的 UUID 信息，在构建调试工具中便可以查找到，然后用查找到的合成的大图的 UUID 在打包后生成的 XXXBundle/native 目录中查看即可。如果合图太多，可以打开构建 log 文件用搜索 UUID 的方式查找。 如何解压缩 UUID 在 release 模式下打包出来的资源 JSON 文件以及 config.json 中的 UUID 都是压缩后的，需要将其解压才能找到原项目中的对应资源。构建进程中内置了一些工具方法在全局变量 Build 上，直接点击主菜单中的 开发者 -> 构建调试工具，在控制台里输入以下命令即可查询到原始 UUID： Build.Utils.decompressUuid('425o80X19KipOK7J1f5hsN'); // 42e68f34-5f5f-4a8a-938a-ec9d5fe61b0d 引擎编译失败 如果引擎编译失败，请检查安装包是否完整、修改的内置引擎代码是否正确，以及若使用了自定义引擎，路径是否正确等等。 其他报错 如果遇到的错误无法自行解决，请附上 Creator 版本、构建选项配置、构建任务中的构建日志文件以及可复现问题的 Demo 到 论坛 反馈。 "},"editor/publish/custom-project-build-template.html":{"url":"editor/publish/custom-project-build-template.html","title":"定制项目的构建模版","keywords":"","body":"自定义构建模版 Cocos Creator 支持对每个项目分别定制构建模板，只需要在项目路径下添加一个 build-templates 目录，里面按照 平台插件名称 划分子目录。在构建结束后，build-templates 目录下所有的文件都会自动按照对应的目录结构复制到构建生成的工程中。具体的 平台插件名称 请参考最下方的 自定义构建模板平台支持表。 结构类似： project-folder |--assets |--build |--build-templates |--web-mobile // 需要添加的文件，如 index.html |--index.html 这样如果当前构建的平台是 Web Mobile 的话，那么 build-templates/web-mobile/index.html 就会在构建后被拷贝到 build/web-mobile（以平台插件名称为准）/index.html。 除此之外，目前构建模板支持的文件类型还包括 ejs 类型 和 json 类型。各平台的支持情况，详情请参考下文的 平台支持表。 ejs 类型 随着 Creator 版本的升级，可能会对构建模板做一些修改和更新，就会导致不同版本构建出来的包内容不完全一样，开发者需要手动同步更新项目中定制的构建模板。 因此为了优化这个问题，Creator 在主菜单的 项目 中新增了 创建项目构建模板 选项，用于生成对应平台支持的构建模板。 开发者只需要在生成的构建模板的 .ejs 中进行定制，构建时会自动将编辑器构建模板的更新同步到定制的构建模板中，经常改动的内容都会同步到该模板引用的子模板（.ejs）中，这样定制构建模板便可以不用频繁手动更新。 以创建 Web Mobile 构建模板为例，生成的构建模板目录结构如下： 注意：构建时，拷贝定制构建模板这一步骤是最后执行的，也就是说，假如该目录下同时存在 index.ejs 与 index.html，那么最终打包出来的是 index.html 文件而不是 index.ejs 文件。 json 类型的融合处理 许多小游戏平台都会有类似 game.json 之类的配置文件，若这些 json 文件在对应平台的定制构建模板中，构建时便不会直接将其拷贝并覆盖到对应的发布包目录下，而是会将编辑器最新构建模板的内容整合进来。 自定义构建模板平台支持表 各平台对构建模板的文件类型支持情况如下表所示： 平台 平台构建插件名 支持的文件类型 华为 AGC huawei-agc 暂不支持 支付宝小游戏 alipay-mini-game game.json 字节跳动小游戏 bytedance-mini-game game.ejs、game.json、project.config.json OPPO 小游戏 oppo-mini-game manifest.json 华为快游戏 huawei-quick-game 暂不支持 Cocos Play cocos-play game.config.json vivo 小游戏 vivo-mini-game project.config.json 小米快游戏 xiaomi-quick-game manifest.json 百度小游戏 baidu-mini-game game.json、project.swan.json 微信小游戏 wechatgame game.ejs、game.json、project.config.json Web Desktop web-desktop index.ejs Web Mobile web-mobile index.ejs 原生平台 native 暂不支持 "},"module-map/graphics.html":{"url":"module-map/graphics.html","title":"图形渲染","keywords":"","body":"图形渲染 Cocos Creator 提供了以下图形功能，用以丰富图形以及加强图形画面的真实性等： 渲染管线 相机 光照和阴影 网格 纹理 材质 粒子 特效 天空盒 全局雾 "},"render-pipeline/overview.html":{"url":"render-pipeline/overview.html","title":"渲染管线","keywords":"","body":"渲染管线 (Experimental) RenderPipeline 用于控制场景的渲染流程，包括光照管理、物体剔除、渲染物体排序、渲染目标切换等。由于每个阶段对于不同项目来说可以有不同的优化处理方式，所以用统一的方法来处理不同类型项目的渲染流程很难达到最优化的结果。可定制化的渲染管线用于对渲染场景中的每个阶段进行更灵活的控制，可以针对不同的项目做更深层次的优化方案。 在可定制化的渲染管线中，可以选择使用引擎内置的渲染管线，内置管线使用的是 前向渲染管线。详情请参考 内置渲染管线。 "},"render-pipeline/builtin-pipeline.html":{"url":"render-pipeline/builtin-pipeline.html","title":"内置管线","keywords":"","body":"内置渲染管线 Cocos Creator 的内置渲染管线目前使用的是 builtin-forward（前向渲染管线）。渲染管线可通过编辑器主菜单中的 项目 -> 项目设置 -> 项目数据 -> 渲染管线 进行设置，设置完成之后 重启编辑器 即可生效。 在内置渲染管线中，一个场景只会有一个平行光生效，每个物体只能接受 2 个球面光和 2 个聚光灯，如果超出范围，则会按距离对光源进行排序，取最近的两个光源。 前向渲染管线 前向渲染会依次渲染场景中的每个物体，在渲染每个物体时计算其光照。 前向渲染管线包含一个 ForwardFlow，ForwardFlow 中包含一个 ForwardStage。在 ForwardStage 里设置了以下两个 RenderQueue： 第一个 RenderQueue 用于渲染 不透明物体，按离摄像机 从近到远 排序 第二个 RenderQueue 用于渲染 半透明物体，按离摄像机 从远到近 排序。 前向渲染管线可用于控制场景的渲染流程，例如对于光照管理的应用请参考 基于多 Pass 的多光源支持。 "},"editor/components/camera-component.html":{"url":"editor/components/camera-component.html","title":"相机","keywords":"","body":"相机 游戏中的相机是用来捕捉场景画面的主要工具。我们通过调节相机相关参数来控制可视范围的大小，在 Cocos Creator 编辑器中相机呈如下表示： 相机的可视范围是通过 6 个平面组成一个 视锥体（Frustum） 构成，近裁剪面（Near Plane） 和 远裁剪面（Far Plane） 用于控制近处和远处的可视距离与范围，同时它们也构成了视口的大小。 相机组件接口请参考 Camera API。 相机组件 相机组件是我们用来呈现场景画面的重要功能组件。 属性名称 说明 Priority 相机的渲染优先级，值越小越优先渲染 Visibility 可见性掩码，声明在当前相机中可见的节点层级集合 ClearFlags 相机的缓冲清除标志位，指定帧缓冲的哪部分要每帧清除。包含：DONT_CLEAR：不清空；DEPTH_ONLY：只清空深度； SOLID_COLOR：清空颜色、深度与模板缓冲； SKYBOX：启用天空盒，只清空深度 ClearColor 指定清空颜色 ClearDepth 指定深度缓冲清空值 ClearStencil 指定模板缓冲清空值 Projection 相机投影模式。分为 透视投影（PERSPECTIVE） 和 正交投影（ORTHO） FovAxis 指定视角的固定轴向，在此轴上不会跟随屏幕长宽比例变化 Fov 相机的视角大小 OrthoHeight 正交模式下的视角 Near 相机的近裁剪距离，应在可接受范围内尽量取最大 Far 相机的远裁剪距离，应在可接受范围内尽量取最小 Aperture 相机光圈，影响相机的曝光参数 Shutter 相机快门，影响相机的曝光参数 Iso 相机感光度，影响相机的曝光参数 Rect 相机最终渲染到屏幕上的视口位置和大小 TargetTexture 指定相机的渲染输出目标贴图，默认为空，直接渲染到屏幕 相机分组渲染 分组渲染功能是通过相机组件的 Visibility 属性配合节点的 Layer 属性 共同决定的。用户可通过代码设置 Visibility 的值来完成分组渲染。所有节点默认都属于 DEFAULT 层，在所有相机都可见。 设置 Visibility 属性 Visibility 属性用于设置哪些层级（Layer）的节点应该被相机观察到，可同时选择多个 Layer。 注意：从 Cocos Creator 3.0 开始，2D 元素（例如 Sprite）的渲染也遵从 Layer 与 Visibility 的判断，开发者可以根据需要自行调整 Layer 与 Visibility。 当开发者在 Visibility 属性中勾选了多个 Layer 时，Visibility 属性值便是通过将多个 Layer 的属性值执行 | 操作计算得出。 例如，下图中相机的 Visibility 属性同时勾选了 UI_3D 和 DEFAULT 这两个 Layer，通过 查询 Layer 属性值 可以知道 UI_3D 的属性值是 1 ，DEFAULT 的属性值是 1 ，那么 Visibility 属性值便是 1 。 关于 Layer 的实现详情，请参考 层级 文档。 相机的可见性计算 Visibility 属性可以同时选择多个 Layer，同时 Node 上的 Layer 也有自身的值，因此相机的 Visibility 属性是一个 232 位的整数，每一种可见的 layer 占一位，采用位操作运算，最高支持 32 个不同的 Layer 标签（每一种 Layer 值占一位，即用 232 表示）。在相机 culling 时，每个节点的 layer 值会跟相机进行 & 操作运算，如果相机的 Visibility 属性包含这个 Layer，那么当前节点就会被相机所看见，反之则看不见。 "},"concepts/scene/light.html":{"url":"concepts/scene/light.html","title":"光照","keywords":"","body":"光照 本章主要介绍 Cocos Creator 中光照的工作方式和使用方式。 光照是指光的照射，Creator 中光照的实现模拟了光对真实世界的影响。在场景中添加光源可以使场景产生相应的光照和阴影效果，获得更好的视觉效果。 更多内容 基于物理的光照 光源类型 基于多 Pass 的多光源支持 阴影 光照贴图 Creator 提供了 lighting 范例（GitHub | Gitee），主要介绍一些光照常见的编辑操作方法以及代码范例，以供参考。 "},"concepts/scene/light/pbr-lighting.html":{"url":"concepts/scene/light/pbr-lighting.html","title":"基于物理的光照","keywords":"","body":"基于物理的光照 Cocos Creator 中采用光学度量单位来描述光源参数。基于光学度量单位，我们可以将光源的相关参数全部转化为真实世界中的物理值。这样，设计人员可根据相关灯光的工业参数以及真实环境的实际物理参数来调节光照强度、颜色、范围等信息，使整体光照效果更加符合真实的自然环境。 真实世界中的光源 基于物理的光照符合真实世界中的光源描述，在真实环境中，我们所见到的光源产品都具有自身的工业参数，我们先来看一个宜家的灯泡💡 从产品包装上，我们可以了解到这个灯泡的几个重要工业参数： 光通量 色温 尺寸 这三个重要参数影响真实世界中的光源表现效果，下面我们来重点讲解一下这三个参数的物理意义。 光学度量单位 光学度量单位（Photometric Unit） 是用来计算光的强弱（大小）和方向的一门科学： 光通量（Luminous Flux） 单位 流明（lm），单位时间内光源所发出或者被照物体所接收的总光能。改变光源大小不会影响场景照明效果。 亮度（Luminance） 单位 坎德拉每平方米（cd/m2），单位面积光源在给定方向上，在每单位面积内所发出的总光通量。改变光源大小会影响场景照明效果。 照度（Illuminance） 单位 勒克斯（lux 或 lx），每单位面积所接收到的光通量。该值受光的传播距离影响，对于同样光源而言，当光源的距离为原先的两倍时，照度减为原先的四分之一，呈平方反比关系。 在真实世界中，由于描述光源的重要物理参数不一样，我们通常用 光通量（Luminous Flux） 和 亮度（Luminance） 来描述生活中常见的带有照明面积的光源，用 照度（Illuminance） 来描述太阳光。 色温（ColorTemperature） 色温 是指绝对黑体从绝对零度（-273℃）开始加温后所呈现的颜色。 色温是影响光源颜色的重要属性，是个可选属性，当启用色温时，色温也参与了光源颜色的组成部分。 真实世界环境中，一天不同时段的环境色温也会动态发生变化： 可参考下表： 光源大小 真实世界中的光源都具有真实的物理尺寸，在 相同光通量 的情况下，光源的尺寸会影响 亮度 和 照度。 "},"concepts/scene/light/lightType/":{"url":"concepts/scene/light/lightType/","title":"光源","keywords":"","body":"光源 光源决定了物体所受到的光照的颜色、色温、强度、方向、以及产生的阴影效果等。目前 Creator 支持的光源类型包括： 平行光 球面光 聚光灯 环境光 添加光源 添加光源有以下两种方式： 在 层级管理器 中点击左上角的 + 按钮，选择 光源，然后根据需要选择光源类型就可以创建一个带有对应类型 光源组件 的节点到场景中。 在 层级管理器 中选择需要添加光源的节点，然后点击 属性检查器 下方的 添加组件 按钮，选择 Light，即可选择所需的光源组件到节点上。 "},"concepts/scene/light/lightType/dir-light.html":{"url":"concepts/scene/light/lightType/dir-light.html","title":"平行光","keywords":"","body":"平行光 平行光又称为方向光（Directional Light），是最常用的一种光源，模拟了无限远处的光源发出的光线，常用于实现太阳光。 因为光源与被照射目标的距离是未定义的（无限远），所以光照效果不受 光源位置 和 朝向 的影响（如下图，平行光在平面上产生的光照亮度都是一样的）。但是 旋转 会影响到平行光照射的方向，而光照方向又会影响到模型接受光照的范围以及模型产生阴影的位置。可通过编辑器左上角的 旋转变换工具 来调整平行光照射的方向。 在场景中添加平行光的方式可参考 添加光源。 注意：Cocos Creator 目前只支持一个平行光。若同时添加多个，则以最后一个添加的为准。 新建场景时，默认会自动创建一个 Main Light 平行光节点。 平行光组件相关接口，请参考 DirectionalLight API。 平行光属性 属性 说明 Color 设置光源颜色 UseColorTemperature 是否启用色温 ColorTemperature 调节色温 StaticSettings 设置静态灯光，详情请参考 光照贴图 Illumination 照度，单位 勒克斯（lx） "},"concepts/scene/light/lightType/sphere-light.html":{"url":"concepts/scene/light/lightType/sphere-light.html","title":"球面光","keywords":"","body":"球面光 Cocos Creator 3.x 的球面光与 v2.x 的点光源（Point Light）类似。 球面光会向所有方向均匀地发散光线，接近于蜡烛产生的光线。物体受到的光照强度会随着跟光源距离的增大而减弱，当距离超过设置的光照影响范围，则光照强度为 0。 在实际应用中可用于模拟火把、蜡烛、灯泡等光源，照亮四周一定距离内的环境。 在编辑器中可以直观地看到光源位置、颜色，以及它的照射范围，如下图所示。通过修改 属性检查器 中球面光组件的 Range 属性即可调整球面光的光照范围。 在场景中添加球面光的方式可参考 添加光源。 球面光组件接口请参考 SphereLight API。 球面光属性 属性 说明 Color 设置光源颜色 UseColorTemperature 是否启用色温 ColorTemperature 调节色温 Size 设置光源大小 Range 设置光照影响范围 Term 设置光照强度单位的类型，包括 光通量（LUMINOUS_POWER）和 亮度（LUMINANCE） 两种 LuminousPower 光通量，单位 流明（lm）当 Term 设置为 LUMINOUS_POWER 时生效 Luminance 亮度，单位 坎德拉每平方米（cd/m2）当 Term 设置为 LUMINANCE 时生效 StaticSettings 静态灯光设置，详情请参考 光照贴图 注意：目前球面光的 Size 属性在实际运行中不生效，以及暂不支持显示阴影，我们会在后续版本进行优化，请关注版本更新公告。 "},"concepts/scene/light/lightType/spot-light.html":{"url":"concepts/scene/light/lightType/spot-light.html","title":"聚光灯","keywords":"","body":"聚光灯 聚光灯 是由一个点向一个方向发射一束锥形光线，类似于手电筒或舞台照明灯产生的光线。与其他光源相比，聚光灯多了 SpotAngle 属性，用于调整聚光灯的光照范围。 在编辑器中可以直观地看到光源的位置、颜色、光照范围以及它的聚光角度等，如下图所示。配合编辑器左上角的 变换工具 可调整聚光灯的位置及照射方向等。 在场景中添加聚光灯的方式可参考 添加光源。 聚光灯组件接口请参考 SpotLight API。 聚光灯属性 属性 说明 Color 设置光源颜色 UseColorTemperature 是否启用色温 ColorTemperature 调节色温 Size 设置光源大小 Range 设置光照影响范围 SpotAngle 调整聚光角度，控制光照范围 Term 设置光照强度单位类型，包括 光通量（LUMINOUS_POWER） 和 亮度（LUMINANCE） 两种 LuminousPower 光通量，单位 流明（lm）当 Term 设置为 LUMINOUS_POWER 时生效 Luminance 亮度，单位 坎德拉每平方米（cd/m2）当 Term 设置为 LUMINANCE 时生效 StaticSettings 静态灯光设置，详情请参考 光照贴图 "},"concepts/scene/light/lightType/ambient.html":{"url":"concepts/scene/light/lightType/ambient.html","title":"环境光","keywords":"","body":"环境光 在生活中，错综复杂的光线与凹凸不平的物体表面相互反射，使得整个环境都被照亮，仿佛被一层光均匀笼罩，这个光一般称为环境光，也称为漫射环境光。 因为环境光可以均匀地照亮场景中的所有物体，常用于解决模型背光面全黑的问题，一般需要配合其他类型的光源一起使用。例如场景中只有一个平行光，那么在模型的背光源处会显得非常暗，加入环境光则可以提升模型背部的亮度，显得更加美观。 在 层级管理器 中选中 Scene，然后在 属性检查器 的 ambient 组件中即可设置环境光属性。 注意：由于环境光是没有方向的，所以不能产生阴影。 环境光属性 属性 说明 SkyColor 设置天空颜色 SkyIllumination 调节天空亮度 GroundAlbedo 设置地面反射光的颜色 环境光可配合天空盒一起使用，详情可参考 天空盒。 "},"concepts/scene/light/additive-per-pixel-lights.html":{"url":"concepts/scene/light/additive-per-pixel-lights.html","title":"基于多 Pass 的多光源支持","keywords":"","body":"基于多 Pass 的多光源支持 超着色器（Uber Shader）目前在一些性能受限的平台上仍然是主流方案，但随着硬件性能的增强和画质需求的提高，固定数量的光源再也无法满足实际应用的需求，于是就有了支持多光源的方案 — 多遍绘制。 下面以 Creator 中默认的光照材质 default-material.mtl 为例，介绍如何实现基于多 Pass 的多光源支持。 首先在 层级管理器 中新建一个 Sphere 球体 节点，然后继续添加一个平行光，两个聚光灯，将它们设置环绕在球体周围，如下图所示： 场景搭建完成后，选择编辑器上面的浏览器预览，可以在左下角看到 Draw Call。 我们可以通过第三方软件，例如 RenderDoc，打开 Frame Debug 来看看这些到底是如何渲染到屏幕上的： 由上图可以看出来，第一遍渲染的是 Directional Light 的光照： 第二遍，渲染的是 Spot Light 1 的光照： 第三遍，渲染的是 Spot Light 2 的光照： 这种渲染方式便是支持多种光照模型的 Forward-Pipeline。Forward 一般由两个 Pass 组成： 第一个 Pass 是 BasePass，用于渲染平行光的光照。 第二个 Pass 是 LightPass，用于渲染剩余光源的光照。 因此，当一个物体同时被多个灯光照射时，Draw Call 也会增加。 "},"concepts/scene/light/shadow.html":{"url":"concepts/scene/light/shadow.html","title":"阴影","keywords":"","body":"阴影 在 3D 世界中，光与影一直都是极其重要的组成部分，它们能够丰富整个环境，质量好的阴影可以达到以假乱真的效果，并且使得整个世界具有立体感。 Creator 3.0 目前支持 Planar 和 ShadowMap 两种阴影类型。 开启阴影 物体开启阴影效果的步骤如下： 在 层级管理器 中选中 Scene，然后在 属性检查器 的 shadows 组件中勾选 Enabled 属性。 在 层级管理器 中选中需要显示阴影的 3D 节点，然后在 属性检查器 的 MeshRenderer 组件中将 ShadowCastingMode 属性设置为 ON。 若阴影类型是 ShadowMap，还需要将 MeshRenderer 组件上的 ReceiveShadow 属性设置为 ON。 注意：如果阴影无法正常显示，需要调整一下方向光的照射方向。 shadows 类型 阴影类型可在 shadows 组件的 Type 属性中设置。 Planar shadow Planar 阴影类型一般用于较为简单的场景。 属性 说明 Enabled 是否开启阴影效果 Type 阴影类型 ShadowColor 设置阴影颜色 Normal 垂直于阴影的法线，用于调整阴影的倾斜度 Distance 阴影接收平面与坐标原点的距离 调节方向光照射的方向可以调节阴影的投射位置。 注意：Planar 类型的阴影只有投射在平面上才能正常显示，不会投射在物体上，也就是说 MeshRenderer 组件中的 ReceiveShadow 属性是无效的。 ShadowMap ShadowMap 是以光源为视点来渲染场景的。从光源位置出发，场景中看不到的地方就是阴影产生的地方。 属性 说明 Enabled 是否开启阴影效果 Type 设置阴影类型 ShadowColor 设置阴影颜色 Pcf 设置阴影边缘反走样等级，目前包括 HARD、 FILTER_X5、FILTER_X9、FILTER_X25 四种，详情可参考下文 PCF 软阴影 部分的介绍。 AutoAdapt 若勾选该项，则自动计算阴影产生的范围，详情可参考下文介绍。若不勾选该项，则启用下列属性来手动设置阴影产生的范围 Near 设置主光源相机的近裁剪面 Far 设置主光源相机的远裁剪面 OrthoSize 设置主光源相机的正交视口大小 MaxReceived 最多支持产生阴影的光源数量，默认为 4 个，可根据需要自行调整 ShadowMapSize 设置阴影纹理大小 Aspect 设置主光源相机的正交视口长宽比 Bias 设置阴影偏移值，防止 z-fiting ShadowMap 在开启了物体 MeshRenderer 组件上的 ReceiveShadow 后，就会接收并显示其它物体产生的阴影效果。 ShadowMap 一般用于要求光影效果比较真实，且较为复杂的场景。但不足之处在于如果不移动光源，那么之前生成的 ShadowMap 就可以重复使用，而一旦移动了光源，那么就需要重新计算新的 ShadowMap。 PCF 软阴影 百分比渐近过滤（PCF）是一个简单、常见的用于实现阴影边缘反走样的技术，通过对阴影边缘进行平滑处理来消除阴影贴图的锯齿现象。原理是在当前像素（也叫做片段）周围进行采样，然后计算样本跟片段相比更接近光源的比例，使用这个比例对散射光和镜面光成分进行缩放，然后再对片段着色，以达到模糊阴影边缘的效果。 目前 Cocos Creator 支持 5 倍、9 倍 和 25 倍采样，倍数越大，采样区域越大，阴影边缘也就越模糊。 AutoAdapt 自适应阴影计算技术 AutoAdapt 自适应阴影计算会自动计算视口（lightView）下阴影产生的范围，以及阴影相机的远近。 支持动态合批提高性能 对于材质中已经开启 instancing 的模型，平面阴影也会自动同步使用 instancing 绘制，详情请参考 动态合批。 "},"concepts/scene/light/lightmap.html":{"url":"concepts/scene/light/lightmap.html","title":"光照贴图","keywords":"","body":"光照贴图 注意：光照贴图功能目前暂不支持 Apple M1（Silicon）架构的设备，预计在 v3.2.1 支持。 烘焙系统会对光源稳定的静态物体所受到的光照和阴影等进行预先计算，计算产生的结果存放在一张纹理贴图中，这张贴图我们称之为 光照贴图。 生成的光照贴图 Creator 会在运行时自动处理并使用。在光源固定的场景中，使用光照贴图代替实时的光照计算，可以减少资源消耗，从而提高场景运行效率。 光照贴图面板 点击编辑器菜单栏的 项目 -> 光照贴图，打开光照贴图面板。面板由 Scene 和 Baked 两个页面组成。 Scene：主要用于配置生成光照贴图相关的参数。 Baked：主要用于展示生成的光照贴图及其相关信息。 具体内容请查看下方 生成光照贴图 部分的内容。 属性说明 Scene 页面各参数的说明如下： 参数 说明 MSAA 多重采样，可选值包括：1、2、4、8 Resolution 生成的光照贴图的分辨率，可选值包括：128、256、512、1024、2048 Gamma Gamma 矫正值 GIScale 全局光照缩放系数 GISamples 全局光照采样系数 AOLevel AO（Ambient Occlusion，环境光遮蔽）级别 AOStrength AO 强度 AORadius AO 半径 AOColor AO 颜色 生成光照贴图 在 层级管理器 中选中光源节点（带有光源组件），然后在 属性检查器 中设置光源组件的 StaticSettings，勾选 Bakeable 属性（目前不支持同时使用多个 主方向光）。 EditorOnly：是否只在编辑器中生效 Bakeable：是否烘焙静态光照 CastShadow：是否投射静态阴影 在 层级管理器 中选中要生成光照贴图的模型节点（带有 MeshRenderer 组件），然后在 属性检查器 中设置 LightmapSettings，勾选 Bakeable 属性。 Bakeable：是否烘焙静态光照 CastShadow：是否投射静态阴影 ReceiveShadow：是否接受静态阴影 LightmapSize：模型光照贴图尺寸 注意：要生成光照贴图的模型有以下两点要求： 美术人员在制作模型资源时，除了模型本身的 UV，还需要另外包含一套 UV，用于光照贴图。 模型的 Materials 需要开启 USE LIGHTMAP 渲染选项，例如： 打开 光照贴图 面板，并设置好对应参数。然后点击 生成光照贴图 按钮，会弹出一个文件存储对话框，需要指定一个文件夹（必须在 assets 目录下）用于存放生成的光照贴图数据信息。即可看到在 光照贴图 面板下方输出了烘焙进度的日志信息。 烘焙结束后可在 光照贴图 面板的 Baked 页面查看生成的光照贴图，以及文件名、尺寸等相关信息。生成的光照贴图引擎会自动处理使用，无需开发者手动操作。 烘焙结果：显示烘焙后生成的光照贴图。 清空光照贴图：用于删除生成的光照贴图及相关信息。 信息输出面板：显示生成的光照贴图的文件名、大小等相关信息。 "},"module-map/mesh/":{"url":"module-map/mesh/","title":"网格","keywords":"","body":"网格（Meshes） 网格 一般用于绘制 3D 图像。Creator 提供了以下网格渲染器组件来渲染基础网格、蒙皮网格等，从而将模型绘制显示出来： MeshRenderer：网格渲染器组件，用于渲染基础的模型网格。 SkinnedMeshRenderer：蒙皮网格渲染器组件，用于渲染蒙皮模型网格。 SkinnedMeshBatchRenderer：批量蒙皮网格渲染器组件，用于将同一个骨骼动画组件控制的所有子蒙皮模型合并渲染。 同时，模型若要应用于实际的物理碰撞中，实现类似凹凸不平的路面效果，可以使用网格碰撞组件，会根据模型形状生成碰撞网格。详情请参考 使用网格碰撞。 "},"engine/renderable/model-component.html":{"url":"engine/renderable/model-component.html","title":"MeshRenderer","keywords":"","body":"MeshRenderer 组件参考 MeshRenderer（网格渲染器）组件用于显示一个静态的 3D 模型。通过 Mesh 属性设置模型网格，通过 Materials 属性控制模型的显示外观。 在 属性检查器 中点击 添加组件 -> Mesh -> MeshRenderer 即可添加 MeshRenderer 组件。 MeshRenderer 属性 属性 功能 Materials 网格资源允许使用多个材质资源，所有材质资源都存在 materials 数组中。如果网格资源中有多个子网格，那么 Mesh Renderer 会从 materials 数组中获取对应的材质来渲染此子网格。 LightmapSettings 用于烘焙 Lightmap，详情请参考 光照贴图。 ShadowCastingMode 指定当前模型是否会投射阴影，需要先在场景中 开启阴影。 ReceiveShadow 指定当前模型是否会接收并显示其它物体产生的阴影效果，需要先在场景中 开启阴影。该属性仅在阴影类型为 ShadowMap 时生效。 Mesh 指定渲染所用的网格资源，详情请参考下文 网格资源 部分的内容。 网格渲染器组件相关接口请参考 MeshRenderer API。 蒙皮网格渲染器组件相关接口请参考 SkinnedMeshRenderer API 网格资源 Mesh 资源是渲染网格的必要资源，目前网格主要是在 导入模型资源 到 Creator 中时，由 Creator 自动生成的。 Mesh 资源中包含了一组顶点和多组索引。索引指向顶点数组中的顶点，每三组索引组成一个三角形。网格则是由多个三角形组成的，是 3D 世界中最基本的图元。多个三角形拼接成一个复杂的多边形，多个多边形则拼接成一个 3D 模型。 Creator 提供了几个简单的静态 3D 模型，其中包含了立方体、圆柱体等基础模型，开发者可根据自己的需要在 层级管理器 中创建几个，以初步了解。 模型分组渲染 分组渲染功能是通过相机组件的 Visibility 属性 配合节点的 Layer 属性 共同决定。用户可通过代码设置 Visibility 的值来完成分组渲染。所有节点默认都属于 DEFAULT 层，在所有相机都可见。 静态合批 目前静态合批方案为运行时静态合批，通过调用 BatchingUtility.batchStaticModel 可进行静态合批。 该函数接收一个节点，然后将该节点下的所有 MeshRenderer 里的 Mesh 合并成一个，并将其挂到另一个节点下。 在合批后，将无法改变原有的 MeshRenderer 的 transform，但可以改变合批后的根节点的 transform。 只有满足以下条件的节点才能进行静态合批： 子节点中只能包含 MeshRenderer； 子节点下的 MeshRenderer 的 Mesh 的顶点数据结构必须一致； 子节点下的 MeshRenderer 的材质必须相同。 关于动态合批 引擎目前提供两套动态合批系统，instancing 合批和合并 VB 方式的合批，两种方式不能共存，instancing 优先级大于合并 VB。 要开启合批，只需在模型所使用的材质中对应勾选 USE_INSTANCING 或 USE_BATCHING 开关即可。 注意：合批能够正常参与 frustum culling 流程，但对透明模型无法执行排序，会导致混合效果不正确。引擎没有明确禁止对透明物体的合批，开发者可以自行掌握其中权衡。 Instancing 合批 通过 Instancing 的合批适用于绘制大量顶点数据完全相同的动态模型，启用后绘制时会根据材质和顶点数据分组，每组内组织 instanced attributes 信息，然后一次性完成绘制。 关于蒙皮模型的支持及相关设定，参考 骨骼动画组件。 另外 instancing 还支持自定义额外的 instanced attributes，可以传递更多不同 instance 之间的差异性数据（比如不同人物间给一个漫反射颜色的外观差异，或大片草地中的风力影响）。 这需要自定义 effect 的支持，更详细的说明可以参考 语法指南。 合并 VB 合批 合并 VB 合批适用于绘制大量低面数且顶点数据各不相同的非蒙皮动态模型，启用后绘制时会根据材质分组，然后每组内每帧合并顶点和世界变换信息，然后分批完成绘制1。 每帧合并顶点等操作会引入一部分 CPU 开销，在 JS 中尤其昂贵；另外需要提醒 drawcall 数量并不是越少越好2，最佳性能往往是 CPU 与 GPU 负载均衡的结果，所以在尝试使用合批功能时，请一定多做测试，明确性能瓶颈，做有针对性的优化。 合批的最佳实践 通常来说合批系统的使用优先级为：静态合批 > instancing 合批 > 合并 VB 合批。 首先要确保材质统一，在这个前提下，如果确定某些模型在游戏周期内完全静止不会变化，就可以使用静态合批。 如果存在大量相同的模型重复绘制，相互间只有相对可控的小差异，就可以使用 instancing 合批。 如果存在大量面数很低但顶点数据又各不相同的模型，可以考虑尝试合并 VB 合批。 1. 注意目前使用 uniform 上传合批后的世界变换矩阵，考虑到 WebGL 标准的 uniform 数量限制，目前一批最多绘制 10 个模型，所以对大量同材质的模型，开启合批后 drawcall 数量预期最多会减少 10 倍。 ↩ 2. 关于合批与性能的话题业界一直有不少探讨，比如可以参考 这里 的 slide。 ↩ "},"module-map/texture/":{"url":"module-map/texture/","title":"纹理","keywords":"","body":"纹理（Textures） 纹理是一张可显示的图像，或一段用于计算的中间数据，通过 UV 坐标映射到渲染物体表面，使之效果更为丰富精彩且真实。Creator 中纹理的应用包括以下几种： 用于 2D UI 渲染，参考 SpriteFrame。 用于 3D 模型渲染，需要在材质中指定 纹理贴图资源，才能将其渲染映射到网格表面。纹理贴图还支持在 导入图像资源 时将其切换为 立方体贴图 或 法线贴图。 用于粒子系统，使粒子表现更丰富。与 3D 模型一样，纹理在粒子系统中的应用也依赖于材质。 用于地形渲染，参考 地形系统。 更多内容 渲染纹理（RenderTexture） 压缩纹理 "},"asset/compress-texture.html":{"url":"asset/compress-texture.html","title":"压缩纹理","keywords":"","body":"压缩纹理 Cocos Creator 可以直接在编辑器中设置纹理需要的压缩方式，然后在项目发布时自动对纹理进行压缩。支持同一平台同时导出多种图片格式，引擎将根据不同的设备支持情况自动下载合适的格式。 配置压缩纹理 Cocos Creator 支持导入多种格式的图片（具体见下表），但是在实际游戏运行中，我们不建议使用原始图片作为资源来加载。比如在手机平台上可能只需要原图 80% 或者更少的画质，又或者是没有使用到透明通道的 .png 可以将其转换成 .jpg，这样可以减少很大一部分图片的存储空间。 图片格式 Android iOS Mini Game Web PNG 支持 支持 支持 支持 JPG 支持 支持 支持 支持 WEBP Android 4.0 以上原生支持，其他版本可以使用 解析库 可以使用 解析库 支持 部分支持 PVR 不支持 支持 支持 iOS 设备 支持 iOS 设备 ETC1 支持 不支持 支持 Android 设备 支持 Android 设备 ETC2 部分支持，取决于手机硬件 不支持 不支持 支持部分 Android 设备 ASTC 部分支持 部分支持 不支持 部分支持 默认情况下 Creator 在构建的时候输出的是原始图片，如果在构建时需要对某一张图片或者自动图集进行压缩，可以在 资源管理器 中选中这张图片或图集，然后在 属性检查器 中勾选 useCompressTexture，再选择图片的纹理压缩格式预设即可。 编辑器将会默认提供一个默认预设，如果需要添加更多预设可以点击旁边的 编辑预设 按钮打开 项目设置 -> 压缩纹理 来添加编辑预设，这里的压缩格式仅作为展示使用不可编辑。关于添加纹理压缩预设，请参考 项目设置 - 压缩纹理。 图片资源上的压缩纹理选项将会存储在资源 meta 文件内，其中 presetId 是选择的压缩纹理预设的 ID。 压缩纹理详解 如果想要使用压缩纹理，在构建项目的时候需要打开压缩纹理选项使项目使用压缩纹理功能： Cocos Creator 3.0 在构建图片的时候，会查找当前图片是否进行了压缩纹理的配置，如果没有，则最后按原图输出。 如果查找到了压缩纹理的配置，那么会按照找到的配置对图片进行纹理压缩。项目设置里压缩纹理配置是按照平台大类划分的，具体到实际平台的支持程度会有一些差异。构建将会根据 实际构建平台 以及当前 图片纹理的透明通道 情况来对配置的纹理格式做一定的剔除和优先级选择，关于这块规则可以参考下文的示例来理解。 这些生成的图片不会都被加载到引擎中，引擎会根据 macro.SUPPORT_TEXTURE_FORMATS 中的配置来选择加载合适格式的图片。macro.SUPPORT_TEXTURE_FORMATS 列举了当前平台支持的所有图片格式，引擎加载图片时会从生成的图片中找到在这个列表中 优先级靠前（即排列靠前）的格式来加载。 开发者可以通过修改 macro.SUPPORT_TEXTURE_FORMATS 来自定义平台的图片资源支持情况以及加载顺序的优先级。 使用示例 示例 (一)：如上图所示，对于 MiniGame 平台的压缩纹理预设，假如 构建的是华为快游戏这类仅在安卓设备上运行的，构建将不会打包出 PVR 的纹理格式。更多的平台剔除细则可以参考文末的 构建平台的压缩纹理支持情况 示例 (二)：在上面的示例图中，ETC1 和 PVR 类型都 同时配置了 RGB 和 RGBA 两种类型的纹理格式，这种情况下构建将会根据当前图片的是否带有透明通道来优先选择其中一种格式。示例图中的图片是带透明通道的，则此时构建将只会打包出带有 REGA 类型的压缩纹理格式。当然这种剔除只有同时存在时才会，假如配置里只有 RGB 的图片格式，即便当前图片是带透明通道的也会正常打包出来。 构建平台的压缩纹理支持细节 除全平台支持的 JPG 和 PNG 外，其他纹理压缩格式的支持情况如下： 平台名称 支持的压缩格式 Web Desktop ASTC / ETC2 / ETC1 / PVR / WEBP Web Mobile ASTC / ETC2 / ETC1 / PVR / WEBP WeChat Mini Game ETC1 / PVR AliPay Mini Game ETC1 / PVR Baidu Mini Game ETC1 / PVR OPPO Mini Game ETC1 vivo Mini Game ETC1 Huawei Quick Game ETC1 Cocos Play ETC1 Xiaomi Quick Game ETC1 iOS ASTC / PVR / WEBP / ETC1 / ETC2 Android ASTC / ETC2 / ETC1 / WEBP "},"asset/render-texture.html":{"url":"asset/render-texture.html","title":"渲染纹理","keywords":"","body":"渲染纹理资源（RenderTexture） 渲染纹理是一张在 GPU 上的纹理。通常我们会把它设置到相机的 目标纹理 上，使相机照射的内容通过离屏的 frambuffer 绘制到该纹理上。一般可用于制作汽车后视镜，动态阴影等功能。 创建 RenderTexture 在 资源管理器 中点击左上方的 + 按钮，选择 渲染纹理，即可创建渲染纹理资源： 然后在 属性检查器 中便可以设置渲染纹理资源的相关属性： 属性 说明 Width 设置渲染纹理的宽 Height 设置渲染纹理的高 使用 RenderTexture 方法一：将 3D 相机可见范围内的内容绘制到 UI 的精灵帧上 export class CaptureToWeb extends Component { @property(Sprite) sprite: Sprite = null; @property(Camera) camera: Camera = null; protected _renderTex: RenderTexture = null; start () { const spriteframe = this.sprite.spriteFrame; const sp = new SpriteFrame(); sp.reset({ originalSize: spriteframe.getOriginalSize(), rect: spriteframe.getRect(), offset: spriteframe.getOffset(), isRotate: spriteframe.isRotated(), borderTop: spriteframe.insetTop, borderLeft: spriteframe.insetLeft, borderBottom: spriteframe.insetBottom, borderRight: spriteframe.insetRight, }); const renderTex = this._renderTex = new RenderTexture(); renderTex.reset({ width: 256, height: 256, colorFormat: RenderTexture.PixelFormat.RGBA8888, depthStencilFormat: RenderTexture.DepthStencilFormat.DEPTH_24_STENCIL_8 }); this.camera.targetTexture = renderTex; sp.texture = renderTex; this.sprite.spriteFrame = sp; } } 方法二：将 3D 相机可见范围内的内容绘制到 3D 模型上 export class RenderCameraToModel extends Component { @property(MeshRenderer) model: MeshRenderer = null; start () { // Your initialization goes here. const renderTex = new RenderTexture(); renderTex.reset({ width: 256, height: 256, colorFormat: RenderTexture.PixelFormat.RGBA8888, depthStencilFormat: RenderTexture.DepthStencilFormat.DEPTH_24_STENCIL_8, }); const cameraComp = this.getComponent(Camera); cameraComp.targetTexture = renderTex; const pass = this.model.material.passes[0]; const binding = pass.getBinding('mainTexture'); pass.bindTextureView(binding, renderTex.getGFXTextureView()); } } 更多方法请参考范例 RenderTexture（GitHub | Gitee）。 "},"material-system/overview.html":{"url":"material-system/overview.html","title":"材质系统","keywords":"","body":"材质系统总览 材质系统升级指南 Cocos Creator 从 v2.x 开始就支持了材质系统，在 v3.0 中我们持续改进了材质系统的设计和内置 Shader API，所以从 v2.x 升级到 v3.0 及后续版本时，部分内容可能还需要开发者手动进行调整，具体请参考下方的升级指南： v2.x to v3.0 材质升级指南 材质系统类图 材质系统控制着每个模型最终的着色流程与顺序，在引擎内相关类间结构如下： EffectAsset EffectAsset 是由用户书写的着色流程描述文件，详细结构及书写指南可以参考 Effect 语法。 这里主要介绍引擎读取 EffectAsset 资源的流程： 在编辑器导入 EffectAsset 时，会对用户书写的内容做一次预处理，替换 GL 字符串为管线内常量，提取 shader 信息，转换 shader 版本等。 以 builtin-unlit.effect 为例，编译输出的 EffectAsset 结构大致如下： { \"name\": \"builtin-unlit\", \"techniques\": [{ \"name\": \"opaque\", \"passes\": [{ \"program\": \"builtin-unlit|unlit-vs:vert|unlit-fs:frag\", \"properties\": { \"mainTexture\": { \"value\": \"grey\", \"type\": 28 }, \"tilingOffset\": { \"value\": [1, 1, 0, 0], \"type\": 16 }, \"mainColor\": { \"value\": [1, 1, 1, 1], \"editor\": { \"type\": \"color\" }, \"type\": 16 }, \"colorScale\": { \"value\": [1, 1, 1], \"type\": 15, \"handleInfo\": [\"colorScaleAndCutoff\", 0, 15] }, \"alphaThreshold\": { \"value\": [0.5], \"editor\": { \"parent\": \"USE_ALPHA_TEST\" }, \"type\": 13, \"handleInfo\": [\"colorScaleAndCutoff\", 3, 13] }, \"color\": { \"editor\": { \"visible\": false }, \"type\": 16, \"handleInfo\": [\"mainColor\", 0, 16] }, \"colorScaleAndCutoff\": { \"type\": 16, \"editor\": { \"visible\": false, \"deprecated\": true }, \"value\": [1, 1, 1, 0.5] } }, \"migrations\": { \"properties\": { \"mainColor\": { \"formerlySerializedAs\": \"color\" } } } }] }], \"shaders\": [{ \"name\": \"builtin-unlit|unlit-vs:vert|unlit-fs:frag\", \"hash\": 2093221684, \"glsl4\": { \"vert\": \"// glsl 460 vert source, omitted here for brevity\", \"frag\": \"// glsl 460 frag source, omitted here for brevity\", }, \"glsl3\": { \"vert\": \"// glsl 300 es vert source, omitted here for brevity\", \"frag\": \"// glsl 300 es frag source, omitted here for brevity\", }, \"glsl1\": { \"vert\": \"// glsl 100 vert source, omitted here for brevity\", \"frag\": \"// glsl 100 frag source, omitted here for brevity\", }, \"attributes\": [ { \"tags\": [\"USE_BATCHING\"], \"name\": \"a_dyn_batch_id\", \"type\": 13, \"count\": 1, \"defines\": [\"USE_BATCHING\"], \"location\": 1 }, { \"name\": \"a_position\", \"type\": 15, \"count\": 1, \"defines\": [], \"location\": 0 }, { \"name\": \"a_weights\", \"type\": 16, \"count\": 1, \"defines\": [\"USE_SKINNING\"], \"location\": 2 }, { \"name\": \"a_joints\", \"type\": 16, \"count\": 1, \"defines\": [\"USE_SKINNING\"], \"location\": 3 }, { \"tags\": [\"USE_VERTEX_COLOR\"], \"name\": \"a_color\", \"type\": 16, \"count\": 1, \"defines\": [\"USE_VERTEX_COLOR\"], \"location\": 4 }, { \"tags\": [\"USE_TEXTURE\"], \"name\": \"a_texCoord\", \"type\": 14, \"count\": 1, \"defines\": [\"USE_TEXTURE\"], \"location\": 5 } ], \"varyings\": [ { \"name\": \"v_color\", \"type\": 16, \"count\": 1, \"defines\": [\"USE_VERTEX_COLOR\"], \"location\": 0 }, { \"name\": \"v_uv\", \"type\": 14, \"count\": 1, \"defines\": [\"USE_TEXTURE\"], \"location\": 1 } ], \"builtins\": { \"globals\": { \"blocks\": [ { \"name\": \"CCGlobal\", \"defines\": [] } ], \"samplers\": [] }, \"locals\": { \"blocks\": [ { \"name\": \"CCLocalBatched\", \"defines\": [\"USE_BATCHING\"] }, { \"name\": \"CCLocal\", \"defines\": [] }, { \"name\": \"CCSkinningTexture\", \"defines\": [\"USE_SKINNING\", \"ANIMATION_BAKED\"] }, { \"name\": \"CCSkinningAnimation\", \"defines\": [\"USE_SKINNING\", \"ANIMATION_BAKED\"] }, { \"name\": \"CCSkinningFlexible\", \"defines\": [\"USE_SKINNING\"] } ], \"samplers\": [ { \"name\": \"cc_jointsTexture\", \"defines\": [\"USE_SKINNING\", \"ANIMATION_BAKED\"] } ] } }, \"defines\": [ { \"name\": \"USE_BATCHING\", \"type\": \"boolean\", \"defines\": [] }, { \"name\": \"USE_SKINNING\", \"type\": \"boolean\", \"defines\": [] }, { \"name\": \"ANIMATION_BAKED\", \"type\": \"boolean\", \"defines\": [\"USE_SKINNING\"] }, { \"name\": \"CC_SUPPORT_FLOAT_TEXTURE\", \"type\": \"boolean\", \"defines\": [\"USE_SKINNING\", \"ANIMATION_BAKED\"] }, { \"name\": \"USE_VERTEX_COLOR\", \"type\": \"boolean\", \"defines\": [] }, { \"name\": \"USE_TEXTURE\", \"type\": \"boolean\", \"defines\": [] }, { \"name\": \"FLIP_UV\", \"type\": \"boolean\", \"defines\": [\"USE_TEXTURE\"] }, { \"name\": \"CC_USE_HDR\", \"type\": \"boolean\", \"defines\": [] }, { \"name\": \"USE_ALPHA_TEST\", \"type\": \"boolean\", \"defines\": [] }, { \"name\": \"ALPHA_TEST_CHANNEL\", \"type\": \"string\", \"defines\": [\"USE_ALPHA_TEST\"], \"options\": [\"a\", \"r\", \"g\", \"b\"] } ], \"blocks\": [ { \"name\": \"TexCoords\", \"defines\": [\"USE_TEXTURE\"], \"binding\": 0, \"members\": [ { \"name\": \"tilingOffset\", \"type\": 16, \"count\": 1 } ] }, { \"name\": \"Constant\", \"defines\": [], \"binding\": 1, \"members\": [ { \"name\": \"mainColor\", \"type\": 16, \"count\": 1 }, { \"name\": \"colorScaleAndCutoff\", \"type\": 16, \"count\": 1 } ] } ], \"samplers\": [ { \"name\": \"mainTexture\", \"type\": 28, \"count\": 1, \"defines\": [\"USE_TEXTURE\"], \"binding\": 30 } ] } ] } 这里的信息量不小，但大多数时候这些细节都不需要普通开发者关心，重要的是： 对任意目标平台，所有着色必要的基础信息全部都在这里提前准备好，以保证跨平台和最高的运行效率。 同时在最后构建时会针对当前平台剔除所有冗余的信息，以保证最好的空间利用率。 Material Material 资源可以看成是 EffectAsset 在场景中的资源实例，它本身的可配置参数包括： effectAsset 或 effectName：effect 资源引用，指定使用哪个 EffectAsset 所描述的流程进行渲染。（必备） technique：指定使用 EffectAsset 中的第几个 technique，默认为第 0 个。 defines：宏定义列表，指定开启哪些宏定义，默认全部关闭。 states：管线状态重载列表，指定对渲染管线状态（深度模板透明混合等）有哪些重载，默认与 effect 声明一致。 代码示例： const mat = new Material(); mat.initialize({ effectName: 'pipeline/skybox', defines: { USE_RGBE_CUBEMAP: true } }); 有了这些信息后，Material 就可以被正确初始化，正确初始化的标志是生成渲染使用的 Pass 对象数组，可用于具体模型的渲染。 根据所使用 EffectAsset 的信息，可以进一步设置每个 Pass 的 uniform 等参数。 mat.setProperty('cubeMap', someCubeMap); console.log(mat.getProperty('cubeMap') === someCubeMap); // true 这些属性都是在材质资源对象本身内部生效，并不涉及场景。 要将 Material 应用到特定的模型上，需要将其挂载到一个 RenderableComponent 上，所有需要设定材质的 Component（MeshRenderer、SkinnedMeshRenderer 等）都继承自它。 const comp = someNode.getComponent(MeshRenderer); comp.material = mat; comp.setMaterial(mat, 0); // 与上一行作用相同 根据子模型的数量，Renderable 也可以引用多个 Material 资源： comp.setMaterial(mat, 1); // 赋给第二个 submodel 同一个 Material 也可挂载到任意多个 Renderable 上，一般在编辑器中通过拖拽的方式即可自动赋值。 const comp2 = someNode2.getComponent(MeshRenderer); comp2.material = mat; // the same material above 而当场景中某个模型的 Material 需要自定义一些属性时，会在从 Renderable 获取 Material 时自动做拷贝实例化，创建对应的 MaterialInstance，从而实现独立的定制。 const comp2 = someNode2.getComponent(MeshRenderer); const mat2 = comp2.material; // 拷贝实例化，mat2 是一个 MaterialInstance，接下来对 mat2 的修改只会影响 comp2 的模型 Material 与 MaterialInstance 的最大区别在于，MaterialInstance 从一开始就永久地挂载在唯一的 Renderable 上，且只会对这个模型生效，而 Material 则无此限制。 对于一个已初始化的材质，如果希望修改最初的基本信息，可以直接再次调用 initialize 函数，重新创建渲染资源。 mat.initialize({ effectName: 'builtin-standard', technique: 1 }); 特别地，如果只是希望修改 defines 或 states，引擎提供了更高效的直接设置接口，只需提供相对当前值的重载即可： mat2.recompileShaders({ USE_EMISSIVE: true }); mat2.overridePipelineStates({ rasterizerState: { cullMode: GFXCullMode.NONE } }); 注意：这些接口只能调用 MaterialInstance 实例，而不能调用 Material 资源。 每帧动态更新 uniform 值是非常常见的需求，在类似这种需要更高效接口的情况下，可以手动调用对应 pass 的接口： // 初始化时保存以下变量 const pass = mat2.passes[0]; const hColor = pass.getHandle('albedo'); const color = new Color('#dadada'); // 每帧更新时： color.a = Math.sin(director.getTotalFrames() * 0.01) * 127 + 127; pass.setUniform(hColor, color); Builtins 编辑器内置了几种常见类型的材质，包括无光照的 unlit、基于物理光照的 standard、skybox、粒子、sprite 等。 作为参考，下图是 builtin-standard 材质各着色参数的组装流程： 以下是对应参数和宏定义的完整列表： 参数 说明 tilingOffset 模型 UV 的平铺和偏移量，xy 对应平铺，zw 对应偏移 albedo/mainColor 漫反射颜色，指定模型的主要基色 albedoMap/mainTexture 漫反射贴图，如果有指定，这项会和漫反射颜色相乘 albedoScale 模型的漫反射强度，用于控制漫反射颜色对于最终颜色的影响权重 alphaThreshold 启用 alpha test 后的测试阈值。输出的 alpha 值低于此值的像素会被 discard 掉 normalMap 法线贴图，用于增加表面细节 normalStrenth 法线贴图强度，控制凹凸质感的强弱 pbrMapR（AO）G（Roughness）B（Metallic） PBR 材质参数贴图：环境遮挡、粗糙度和金属度采样结果会和常数项相乘 metallicRoughnessMapG（Roughness）B（Metallic） 独立的粗糙度和金属度贴图采样结果会和常数项相乘 occlusionMap 独立的环境遮挡贴图采样结果会和常数项相乘 occlusion 环境遮挡常数 roughness 粗糙度常数 metallic 金属度常数 emissive 自发光颜色，独立于光照计算，由模型本身直接发散出的颜色 emissiveMap 自发光贴图如果有指定，这项会和自发光颜色相乘，因此需要把自发光颜色（默认是黑色）调高才会有效果 emissiveScale 自发光强度用于控制自发光颜色对于最终颜色的影响权重 相对应的，还有控制这些参数的宏定义： 宏定义 说明 USE_BATCHING 是否启用动态 VB 合并式合批 USE_INSTANCING 是否启用动态 instancing HAS_SECOND_UV 是否存在第二套 UV ALBEDO_UV 指定采样漫反射贴图使用的 uv，默认为第一套 EMISSIVE_UV 指定采样自发光贴图使用的 uv，默认为第一套 ALPHA_TEST_CHANNEL 指定透明测试的测试通道，默认为 A 通道 USE_VERTEX_COLOR 如果启用，顶点色会与漫反射项相乘 USE_ALPHA_TEST 是否开启透明测试（镂空效果） USE_ALBEDO_MAP 是否使用漫反射贴图 USE_NORMAL_MAP 是否使用法线贴图 USE_PBR_MAP 是否使用 PBR 参数三合一贴图（按 glTF 标准，RGB 通道必须分别对应遮挡、粗糙和金属度） USE_METALLIC_ROUGHNESS_MAP 是否使用金属粗糙二合一贴图（按 glTF 标准，GB 通道必须分别对应粗糙和金属度） USE_OCCLUSION_MAP 是否使用遮挡贴图（按 glTF 标准，只会使用 R 通道） USE_EMISSIVE_MAP 是否使用自发光贴图 "},"material-system/yaml-101.html":{"url":"material-system/yaml-101.html","title":"YAML 101","keywords":"","body":"YAML 101 Cocos Creator 3.0 使用的是符合 YAML 1.2 标准的解析器，这意味着 Creator 是与 JSON 完全兼容的，直接使用 JSON 完全不会有问题： \"techniques\": [{ \"passes\": [{ \"vert\": \"skybox-vs\", \"frag\": \"skybox-fs\", \"rasterizerState\": { \"cullMode\": \"none\" } # ... }] }] 当然这也意味着繁琐的语法，所以 YAML 提供了一些更简洁的数据表示方式： 所有的引号和逗号都可以省略 key1: 1 key2: unquoted string 注意：冒号后的空格不可省略 行首的空格缩进数量代表数据的层级1 object1: key1: false object2: key2: 3.14 key3: 0xdeadbeef nestedObject: key4: 'quoted string' 以 连字符 + 空格 开头，表示数组元素 - 42 - \"double-quoted string\" - arrayElement3: key1: punctuations? sure. key2: you can even have {}s as long as they are not the first character key3: { nested1: 'but no unquoted string allowed inside brackets', nested2: 'also notice the comma is back too' } 综合以上几点，文档开头的 effect 内容就可以很简洁地写成这样： techniques: - passes: - vert: skybox-vs frag: skybox-fs rasterizerState: cullMode: none # ... 另一个非常有用的 YAML 特性是数据间的引用与继承。 引用 object1: &o1 key1: value1 object2: key2: value2 key3: *o1 这个数据解析出来是这样的： { \"object1\": { \"key1\": \"value1\" }, \"object2\": { \"key2\": \"value2\", \"key3\": { \"key1\": \"value1\" } } } 继承 object1: &o1 key1: value1 key2: value2 object2: 这个数据解析出来是这样的： { \"object1\": { \"key1\": \"value1\", \"key2\": \"value2\" }, \"object2\": { \"key1\": \"value1\", \"key2\": \"value2\", \"key3\": \"value3\" } } 对应到我们的 effect 中，比如多个 pass 拥有相同的 property 内容，或很多其他情景下，都可以很方便地复用数据： techniques: - passes: - # pass 1 specifications... properties: &props # declare once... p1: { value: [ 1, 1, 1, 1 ] } p2: { sampler: { mipFilter: linear } } p3: { inspector: { type: color } } - # pass 2 specifications... properties: *props # reference anywhere 最后，在实际 effect 文件中任何流程声明都需要包在 CCEffect 语法块内： CCEffect %{ # YAML starts here }% 若有疑问可复制代码示例到任何 在线 YAML JSON 转换器 观察生成的数据。 参考链接 https://en.wikipedia.org/wiki/YAML https://yaml.org/spec/1.2/spec.html 1. 标准 YAML 并不支持制表符，但在解析 effect 数据时，我们会先尝试把其中所有的制表符替换为 2 个空格，以避免偶然插入制表符带来的琐碎的麻烦。但整体上，请一定尽量避免插入制表符来确保编译无误。 ↩ "},"material-system/effect-syntax.html":{"url":"material-system/effect-syntax.html","title":"Effect Syntax","keywords":"","body":"Effect 语法 Cocos Effect 是一种基于 YAML 和 GLSL 的单源码嵌入式领域特定语言（single-source embedded domain-specific language），YAML 部分声明流程控制清单，GLSL 部分声明实际的 shader 片段，这两部分内容上相互补充，共同构成了一个完整的渲染流程描述。 如果希望在引擎中实现自定义的着色效果，需要书写自定义 Effect。我们推荐使用 VSCode，搜索安装 Cocos Effect 插件，以便编辑任何 effect 文件。 注意：这篇文档的目标受众是项目组中的 TA 或图形向的程序，如果有具体定制 shader 需求的美术人员，请联系项目 TA 或程序，把这篇文档丢给他！ 语法框架 以 builtin-unlit.effect 为例，这个 Effect 文件的内容大致如下： Effect 名称 Effect name 是基于 effect 文件名和所在路径两个信息自动生成的，路径部分固定为基于 assets/effects 目录的相对路径，文件名不包括扩展名。 在运行时可以通过 effect name 获取或使用 effect 资源： const effect = EffectAsset.get('builtin-unlit'); // this is the EffectAsset resource instance const mat = new Material(); mat.initialize({ effectName: 'builtin-standard' }); // now 'mat' is a valid standard material 注意：因为编辑器内置 effect 资源全部位于 Internal DB 的 assets/effects 目录下，因而引用时不需要路径部分。 在 层级管理器 中选中材质，然后在 属性检查器 的 Effect 属性下拉列表中可以看到所有当前可用的 effect name。 关于 YAML YAML 是一门面向数据序列化的，对人类书写十分友好的语言，但它引入了一些独特的语法来表示不同类型的数据，对于不熟悉这门语言的开发者可能会有一点门槛，我们在 YAML 101 中快速总结了最常用的一些语法和语言特性，有需要可以参考。 Pass 中可配置的参数 每个 Pass 只有 vert 和 frag 两个必填参数，声明了当前 pass 使用的 shader，格式为 片段名:入口函数名。这个名字可以是本文件中声明的 shader 片段名，也可以是引擎提供的标准头文件。 片段中不应该出现 main 函数入口，在 effect 编译期会插入 wrapper，将指定入口函数的返回值赋值给当前 shader 的输出（gl_Position 或最终的输出颜色）。 所有其他可选参数及默认值见 完整列表。 Shader 片段 Shader 片段在语法上基于 GLSL 300 ES，在资源加载时有相应的预处理编译流程。 这一节会介绍所有“领域特定”的扩展语法，更多实际使用示例，可参考编辑器内提供的 builtin effect。 在标准 GLSL 语法上，Creator 引入了以下几种非常自然的 C 风格语法扩展。 Include 机制 类似 C/C++ 的头文件 include 机制，你可以在任意 shader 代码（CCProgram 块或独立的头文件）中引入其他代码片段： #include #include \"../headers/my-shading-algorithm.chunk\" 相关规则和注意事项： 头文件默认扩展名为 .chunk，包含时可省略。尖括号和双引号没有区别； 在编译期的头文件展开过程中，每个头文件保证只会被展开一次，所以书写时不必担心，每个模块都可以（也应该）包含自己依赖的头文件，即使这中间有重复； 更进一步地，所有不参与运行时实际计算流程的函数声明也都会在编译期就被剔除，所以可以放心包含各类工具函数； 头文件引用可以指定基于当前文件目录的相对路径（以下统称\"相对路径\"），也可以指定基于 assets/chunks 目录的相对路径（以下统称\"项目绝对路径\"），两个位置如果有同名文件，则后者优先； 引用了编辑器其他 DB 的头文件（Internal 或各类插件 DB 等）只能指定项目绝对路径。当多个 DB 在此路径下有相同文件时，优先级为：用户项目 DB > 插件 DB > Internal DB； 编辑器内置头文件资源就在 internal DB 的 assets/chunks 目录下，所以可以不加目录直接引用，主要包括一些常用的工具函数和标准光照模型等。 所有在同一个 effect 文件中声明的 CCProgram 代码块都可以相互引用。 预处理宏定义 目前 Effect 系统的设计倾向于在游戏项目运行时可以方便地利用 shader 中的各类预处理宏，进而减少 runtime branching。 编辑器会在加载资源时收集所有在 shader 中出现的 defines，然后引擎在运行时动态地将需要的声明加入 shader 内容。所以如果要使用这些预处理宏，只需要像上面的截图例子一样，在 shader 中直接进行逻辑判断即可。所有的 define 都会被序列化到 属性检查器 上，以便随时调整。 注意： 为尽可能多地在编译期做类型检查，目前的策略是直接将所有自定义宏设置为 true（或根据 Macro Tags 指定的默认值）再交给后端尝试检查。所以如果在设计上某些宏之间存在互斥关系（不可能同时为 true）的话，应统一使用一个通过 tag 声明的宏来处理； 运行时会显式定义所有 shader 中出现的自定义宏（默认定义为 0），所以 除了 GLSL 语言内置宏外（GL_ 开头的 extension 等），请不要使用 #ifdef 或 #if defined 这样的形式做判断，否则执行结果会始终为 true； 运行时会对宏定义组合计算 hash，目前的计算机制在宏定义组合数 2^32 以内（一个 int 的范围），相对高效，对应到 shader 中相当于 32 个 boolean 开关。所以请尽量不要超出此限制，定义过多运行时可调整的宏定义，会影响运行效率。 Macro Tags 虽然引擎会尝试自动识别所有出现在预处理分支逻辑中 (#if) 的宏定义，但有时实际使用方式要比简单的布尔开关更复杂一些，如： // macro defined within certain numerical 'range' #if LAYERS == 4 // ... #elif LAYERS == 5 // ... #endif // multiple discrete 'options' float metallic = texture(pbrMap, uv).METALLIC_SOURCE; 针对这类有固定取值范围或固定选项的宏定义，需要选择一个合适的 tag 显式声明： Tag 说明 默认值 备注 range 一个长度为 2 的数组。首元素为最小值，末元素为最大值 [0, 3] 针对连续数字类型的宏定义，显式指定它的取值范围。范围应当控制到最小，有利于运行时的 shader 管理 options 一个任意长度的数组，每个元素都是一个可能的取值 如未显式声明则不会定义任何宏 针对有清晰选项的宏定义，显式指定它的可用选项 比如下面这样的声明： #pragma define LAYERS range([4, 5]) #pragma define METALLIC_SOURCE options([r, g, b, a]) 一个是名为 LAYERS 的宏定义，它在运行时可能的取值范围为 [4, 5]。 另一个是名为 METALLIC_SOURCE 的宏定义，它在运行时可能的取值为 'r'、'g'、'b'、'a' 四种。 注意：语法中的每个 tag 都只有一个参数，这个参数可以直接用 YAML 语法指定。 Functional Macros 由于 WebGL1 不支持原生，Creator 将函数式宏定义提供为 effect 编译期的功能，输出的 shader 中就已经将此类宏定义展开。这非常适用于 inline 一些简单的工具函数，或需要大量重复定义的相似代码。事实上，内置头文件中不少工具函数都是函数式宏定义： #define CCDecode(position) \\ position = vec4(a_position, 1.0) #define CCVertInput(position) \\ CCDecode(position); \\ #if CC_USE_SKINNING \\ CCSkin(position); \\ #endif \\ #pragma // empty pragma trick to get rid of trailing semicolons at effect compile time 但与 C/C++ 的宏定义系统相同，这套机制不会对宏定义的 卫生情况 做任何处理，由不卫生的宏展开而带来的问题需要开发者自行处理，因此我们推荐，并也确保所有内置头文件中，谨慎定义含有局部变量的预处理宏： // please do be careful with unhygienic macros like this #define INCI(i) do { int a=0; ++i; } while(0) // when invoking int a = 4, b = 8; INCI(b); // correct, b would be 9 after this INCI(a); // wrong! a would still be 4 Vertex Input1 为对接骨骼动画与数据解压流程，我们提供了 CCVertInput 工具函数，对所有 3D 模型使用的 shader，可直接在 vs 开始时类似这样写： #include vec4 vert () { vec3 position; CCVertInput(position); // ... do your thing with `position` (models space, after skinning) } 如果还需要法线等信息，可直接使用 standard 版本： #include vec4 vert () { StandardVertInput In; CCVertInput(In); // ... now use `In.position`, etc. } 这会返回模型空间的顶点位置（position）、法线（normal）和切空间（tangent）信息，并对骨骼动画模型做完蒙皮计算。 注意：引用头文件后，不要在 shader 内重复声明这些 attributes（a_position 等）。对于其他顶点数据（如 uv 等）还是正常声明 attributes 直接使用。 另外如果需要对接引擎动态合批和 instancing 流程，需要包含 cc-local-batch 头文件，通过 CCGetWorldMatrix 工具函数获取世界矩阵： // unlit version (when normal is not needed) mat4 matWorld; CCGetWorldMatrix(matWorld); // standard version mat4 matWorld, matWorldIT; CCGetWorldMatrixFull(matWorld, matWorldIT); 关于更多 shader 内置 uniform，可以参考 完整列表。 Fragment Output1 为对接引擎渲染管线，Creator 提供了 CCFragOutput 工具函数，对所有无光照 shader，都可以直接在 fs 返回时类似这样写： #include vec4 frag () { vec4 o = vec4(0.0); // ... do the computation return CCFragOutput(o); } 这样中间的颜色计算就不必区分当前渲染管线是否为 HDR 流程等。 如需包含光照计算，可结合标准着色函数 CCStandardShading 一起构成 surface shader 流程： #include #include void surf (out StandardSurface s) { // fill in your data here } vec4 frag () { StandardSurface s; surf(s); vec4 color = CCStandardShading(s); return CCFragOutput(color); } 在此框架下可方便地实现自己的 surface 输入，或其他 shading 算法。 注意：CCFragOutput 函数一般还是不需要自己实现，它只起到与渲染管线对接的作用，且对于这种含有光照计算的输出，因为计算结果已经在 HDR 范围，所以应该包含 output-standard 而非 output 头文件。 自定义 Instanced 属性 通过 instancing 动态合批的功能十分灵活，在默认的流程上，开发者可以加入更多 instanced 属性。如果要在 shader 中引入新的属性，那么所有相关处理代码都需要依赖统一的宏定义 USE_INSTANCING： #if USE_INSTANCING // when instancing is enabled #pragma format(RGBA8) // normalized unsigned byte in vec4 a_instanced_color; #endif 注意： 这里可以使用编译器提示 format 指定此属性的具体数据格式，参数为引擎 GFXFormat 的任意枚举名2，如未声明则默认为 32 位 float 类型； 所有 instanced 属性都是 VS 的输入 attribute，所以如果要在 FS 中使用，则需要在 VS 中自行传递； 记得确保代码在所有分支都能正常执行，无论 USE_INSTANCING 启用与否。 在运行时所有属性都会默认初始化为 0，脚本中设置接口为： const comp = node.getComponent(MeshRenderer); comp.setInstancedAttribute('a_instanced_color', [100, 150, 200, 255]); // should match the specified format 注意：在每次重建 PSO 时（一般对应更换新材质时）所有属性值都会重置，需要重新设置。 WebGL 1 fallback 支持 由于 WebGL 1 仅支持 GLSL 100 标准语法，在 effect 编译期会提供 300 es 转 100 的 fallback shader，所以开发者基本不需关心这层变化。 但需要注意的是目前的自动 fallback 只支持一些基本的格式转换，如果使用了 300 es 独有的 shader 函数（texelFetch、textureGrad 等）或 extension，我们推荐根据 \\_\\_VERSION__ 宏定义判断 shader 版本，自行实现更稳定精确的 fallback： #if __VERSION__ 在 effect 编译期我们会尝试解析所有已经为常量的宏控制流，将实际内容做剔除或拆分到不同版本的 shader 输出中。 关于 UBO 内存布局 Creator 规定在 shader 中所有非 sampler 的 uniform 都应以 block 形式声明，且对于所有 UBO： 不应出现 vec3 成员； 对数组类型成员，每个元素 size 不能小于 vec4； 不允许任何会引入 padding 的成员声明顺序。 这些规则都会在 effect 编译期做对应检查，以便在导入错误（implicit padding 相关）形式时提醒修改。 这可能听起来有些过分严格，但背后有非常务实的考量： 首先，UBO 是渲染管线内要做到高效数据复用的唯一基本单位，离散声明已不是一个选项； 其次，WebGL2 的 UBO 只支持 std140 布局，它遵守一套比较原始的 padding 规则3： 所有 vec3 成员都会补齐至 vec4： uniform ControversialType { vec3 v3_1; // offset 0, length 16 [IMPLICIT PADDING!] }; // total of 16 bytes 任意长度小于 vec4 类型的数组和结构体，都会将元素补齐至 vec4： uniform ProblematicArrays { float f4_1[4]; // offset 0, stride 16, length 64 [IMPLICIT PADDING!] }; // total of 64 bytes 所有成员在 UBO 内的实际偏移都会按自身所占字节数对齐4： uniform IncorrectUBOOrder { float f1_1; // offset 0, length 4 (aligned to 4 bytes) vec2 v2; // offset 8, length 8 (aligned to 8 bytes) [IMPLICIT PADDING!] float f1_2; // offset 16, length 4 (aligned to 4 bytes) }; // total of 32 bytes uniform CorrectUBOOrder { float f1_1; // offset 0, length 4 (aligned to 4 bytes) float f1_2; // offset 4, length 4 (aligned to 4 bytes) vec2 v2; // offset 8, length 8 (aligned to 8 bytes) }; // total of 16 bytes 这意味着大量的空间浪费，且某些设备的驱动实现也并不完全符合此标准5，因此目前 Creator 选择限制这部分功能的使用，以帮助排除一部分非常隐晦的运行时问题。 再次提醒，uniform 的类型与 inspector 的显示和运行时参数赋值时的程序接口可以不直接对应，通过 property target 机制，可以独立编辑任意 uniform 具体的分量。 1. 不包含粒子、sprite、后效等不基于 mesh 执行渲染的 shader。 ↩ 2. 注意 WebGL 1.0 平台下不支持整型 attributes，如项目需要发布到此平台，应使用默认浮点类型。 ↩ 3. OpenGL 4.5, Section 7.6.2.2, page 137 ↩ 4. 注意在示例代码中，UBO IncorrectUBOOrder 的总长度为 32 字节，实际上这个数据到今天也依然是平台相关的，看起来是由于 GLSL 标准的疏忽，更多相关讨论可以参考 这里。 ↩ 5. Interface Block - OpenGL Wiki：https://www.khronos.org/opengl/wiki/Interface_Block_(GLSL)#Memory_layout ↩ "},"material-system/pass-parameter-list.html":{"url":"material-system/pass-parameter-list.html","title":"Pass Params","keywords":"","body":"Pass 可选配置参数 Pass 中的参数主要分为开发者可自定义的 effect 参数和引擎提供的 PipelineStates 参数两部分内容，本文主要介绍 PipelineStates 相关的参数，所有参数不区分大小写。 参数名 说明 默认值 备注 switch 指定这个 pass 的执行依赖于哪个 define。可以是任意有效的宏名称，但不应与使用到的 shader 中定义的任何 define 重名 未定义 这个字段默认是不存在的，意味着这个 pass 是无条件执行的 priority 指定这个 pass 的渲染优先级，数值越小渲染优先级越高，取值范围为 0 ~ 255 128 可结合四则运算符指定相对值 stage 指定这个 pass 归属于管线的哪个 stage。可以是运行时管线中任何注册的 Stage 名称 default 对于默认的 forward 管线，只有 default 一个 stage phase 指定这个 pass 归属于管线的哪个 phase。可以是运行时管线中任何注册的 Phase 名称 default 对于默认的 forward 管线，可以是 default、forward-add 或者 shadow-caster propertyIndex 指定这个 pass 运行时的 uniform 属性数据要和哪个 pass 保持一致，例如 forward add 等 pass 需要和 base pass 一致才能保证正确的渲染效果。可以是任意有效的 pass 索引 未定义 一旦指定了此参数，材质面板上就不会再显示这个 pass 的任何属性 embeddedMacros 指定在这个 pass 的 shader 基础上额外定义的常量宏，可以是一个包含任意宏键值对的对象 未定义 只有当宏定义不同时才能在多个 pass 中使用此参数来复用 shader 资源 properties Properties 存储着这个 pass 中需要显示在 属性检查器 上的可定制的参数 详见下文 Properties 部分的介绍 migrations 迁移旧的材质数据 详见下文 Migrations 部分的介绍 primitive 创建材质顶点数据 triangle_list 可选项包括：point_list、line_list、line_strip、line_looptriangle_list、triangle_strip、triangle_fanline_list_adjacency、line_strip_adjacencytriangle_list_adjacency、triangle_strip_adjacencytriangle_patch_adjacency、quad_patch_list、iso_line_list dynamics 补充说明 [] 数组，包括：viewport、scissor、line_width、depth_bias、blend_constants、depth_bounds、stencil_write_mask、stencil_compare_mask RasterizerState 补充说明 详见下文 RasterizerState 部分的介绍 DepthStencilState 补充说明 详见下文 DepthStencilState 部分的介绍 BlendState 材质混合状态 false 详见下文 BlendState 部分的介绍 Properties Properties 存储着这个 Pass 中需要显示在 属性检查器 上的可定制的参数，这些参数可以是 shader 中某个 uniform 的完整映射，也可以是具体某个分量的映射（使用 target 参数）： albedo: { value: [1, 1, 1, 1] } # uniform vec4 albedo roughness: { value: 0.8, target: pbrParams.g } # uniform vec4 pbrParams offset: { value: [0, 0], target: tilingOffset.zw } # uniform vec4 tilingOffset # say there is another uniform, vec4 emissive, that doesn't appear here # so it will be assigned a default value of [0, 0, 0, 0] and will not appear in the inspector 运行时可以这样使用： // as long as it is a real uniform // it doesn't matter whether it is specified in the property list or not mat.setProperty('emissive', Color.GREY); // this works mat.setProperty('albedo', Color.RED); // directly set uniform mat.setProperty('roughness', 0.2); // set certain component const h = mat.passes[0].getHandle('offset'); // or just take the handle, mat.passes[0].setUniform(h, new Vec2(0.5, 0.5)); // and use Pass.setUniform interface instead 未指定的 uniform 将由引擎在运行时根据自动分析出的数据类型给予 默认初值。 为方便声明各 property 子属性，可以直接在 properties 内声明 __metadata__ 项，所有 property 都会继承它声明的内容，如： properties: __metadata__: { editor: { visible: false } } a: { value: [1, 1, 0, 0] } b: { editor: { type: color } } c: { editor: { visible: true } } 这样 uniform a 和 b 已声明的各项参数都不会受到影响，但都不会显示在 属性检查器 中（visible 为 false），而 uniform c 仍会正常显示。 Property 参数列表 Property 中可配置的参数如下表所示，任何可配置的字段如果和默认值相同都可以省掉。 参数 默认值 可选项 备注 target undefined undefined 任意有效的 uniform 通道，可指定连续的单个或多个，但不可随机重排 value 详见下文 Default Values 部分的介绍 sampler.minFilter linear none, point, linear, anisotropic sampler.magFilter linear none, point, linear, anisotropic sampler.mipFilter none none, point, linear, anisotropic sampler.addressU wrap wrap, mirror, clamp, border sampler.addressV wrap wrap, mirror, clamp, border sampler.addressW wrap wrap, mirror, clamp, border sampler.maxAnisotropy 16 16 sampler.cmpFunc never never, less, equal, less_equal, greater, not_equal, greater_equal, always sampler.borderColor [0, 0, 0, 0] [0, 0, 0, 0] sampler.minLOD 0 0 sampler.maxLOD 0 0 Remember to override this when enabling mip filter sampler.mipLODBias 0 0 editor.displayName *property name *property name 任意字符串 editor.type vector vector, color editor.visible true true, false editor.tooltip *property name *property name 任意字符串 editor.range undefined undefined, [ min, max, [step] ] editor.deprecated false true, false For any material using this effect, delete the existing data for this property after next saving Migrations 一般情况下，在使用材质资源时都希望底层的 effect 接口能始终向前兼容，但有时面对新的需求最好的解决方案依然是含有一定 breaking change 的，这时为了保持项目中已有的材质资源数据不受影响，或者至少能够更平滑地升级，就可以使用 effect 的迁移系统。 在 effect 导入成功后会 立即更新工程内所有 依赖于此 effect 的材质资源，对每个材质资源，会尝试寻找所有指定的旧参数数据（包括 property 和 宏定义 两类），然后将其复制或迁移到新属性中。 注意：使用迁移功能前请一定先备份好项目工程，以免丢失数据！ 对于一个现有的 effect，迁移字段声明如下： migrations: # macros: # macros follows the same rule as properties, without the component-wise features # USE_MIAN_TEXTURE: { formerlySerializedAs: USE_MAIN_TEXTURE } properties: newFloat: { formerlySerializedAs: oldVec4.w } 对于一个依赖于这个 effect，并在对应 pass 中持有属性的材质： { \"oldVec4\": { \"__type__\": \"cc.Vec4\", \"x\": 1, \"y\": 1, \"z\": 1, \"w\": 0.5 } } 在 effect 导入成功后，这些数据会被立即转换成： { \"oldVec4\": { \"__type__\": \"cc.Vec4\", \"x\": 1, \"y\": 1, \"z\": 1, \"w\": 0.5 }, \"newFloat\": 0.5 } 在 编辑器 内重新编辑并保存这个材质资源后会变成（假设 effect 和 property 数据本身并没有改变）： { \"newFloat\": 0.5 } 当然如果希望在导入时就直接删除旧数据，可以再加一条迁移信息来专门指定这点： oldVec4: { removeImmediately: true } 这对于在项目有大量旧材质，又能够确定这个属性的数据已经完全冗余时会比较有用。 更多地，注意这里的通道指令只是简单的取 w 分量，事实上还可以做任意的 shuffle： newColor: { formerlySerializedAs: someOldColor.yxx } 甚至基于某个宏定义： occlusion: { formerlySerializedAs: pbrParams. } 这里声明了新的 occlusion 属性会从旧的 pbrParams 中获取，而具体的分量取决于 OCCLUSION_CHANNEL 宏定义。并且如果材质资源中未定义这个宏，则默认取 z 通道。 但如果某个材质在迁移升级前就已经存着 newFloat 字段的数据，则不会对其做任何修改，除非指定为强制更新模式： newFloat: { formerlySerializedAs: oldVec4.w! } 强制更新模式会强制更新所有材质的属性，无论这个操作是否会覆盖数据。 注意：强制更新操作会在编辑器的每次资源事件中都执行（几乎对应每一次鼠标点击，相对高频），因此只是一个快速测试和调试的手段，一定不要将处于强制更新模式的 effect 提交到版本控制。 再次总结一下为防止数据丢失所设置的相关规则： 为避免有效旧数据丢失，只要没有显式指定 removeImmediately 规则，就不会在导入时自动删除旧数据； 为避免有效的新数据被覆盖，如果没有指定为强制更新模式，对于那些既有旧数据，又有对应的新数据的材质，不会做任何迁移操作。 RasterizerState 参数名 说明 默认值 可选项 cullMode 补充说明 back front, back, none DepthStencilState 参数名 说明 默认值 可选项 depthTest 补充说明 true true, false depthWrite 补充说明 true true, false depthFunc 补充说明 less never, less, equal, less_equal, greater, not_equal, greater_equal, always stencilTest 补充说明 false true, false stencilFunc 补充说明 always never, less, equal, less_equal, greater, not_equal, greater_equal, always stencilReadMask 补充说明 0xffffffff 0xffffffff, [1, 1, 1, 1] stencilWriteMask 补充说明 0xffffffff 0xffffffff, [1, 1, 1, 1] stencilFailOp 补充说明 keep keep, zero, replace, incr, incr_wrap, decr, decr_wrap, invert stencilZFailOp 补充说明 keep keep, zero, replace, incr, incr_wrap, decr, decr_wrap, invert stencilPassOp 补充说明 keep keep, zero, replace, incr, incr_wrap, decr, decr_wrap, invert stencilRef 补充说明 1 1, [0, 0, 0, 1] stencil*Front/Back 补充说明 *set above stencil properties for specific side BlendState 参数名 说明 默认值 可选项 BlendColor 补充说明 0 0, [0, 0, 0, 0] Targets 补充说明 false false true, false targets[i].blend 补充说明 false true, false targets[i].blendEq 补充说明 add add, sub, rev_sub targets[i].blendSrc 补充说明 one one, zero, src_alpha_saturate,src_alpha, one_minus_src_alpha,dst_alpha, one_minus_dst_alpha,src_color, one_minus_src_color,dst_color, one_minus_dst_color,constant_color, one_minus_constant_color,constant_alpha, one_minus_constant_alpha targets[i].blendDst 补充说明 zero one, zero, src_alpha_saturate,src_alpha, one_minus_src_alpha,dst_alpha, one_minus_dst_alpha,src_color, one_minus_src_color,dst_color, one_minus_dst_color,constant_color, one_minus_constant_color,constant_alpha, one_minus_constant_alpha targets[i].blendSrcAlpha 补充说明 one one, zero, src_alpha_saturate,src_alpha, one_minus_src_alpha,dst_alpha, one_minus_dst_alpha,src_color, one_minus_src_color,dst_color, one_minus_dst_color,constant_color, one_minus_constant_color,constant_alpha, one_minus_constant_alpha targets[i].blendDstAlpha 补充说明 zero one, zero, src_alpha_saturate,src_alpha, one_minus_src_alpha,dst_alpha, one_minus_dst_alpha,src_color, one_minus_src_color,dst_color, one_minus_dst_color,constant_color, one_minus_constant_color,constant_alpha, one_minus_constant_alpha targets[i].blendAlphaEq 补充说明 add add, sub, rev_sub targets[i].blendColorMask 补充说明 all all, none, r, g, b, a, rg, rb, ra, gb, ga, ba, rgb, rga, rba, gba Default Values 类型 默认值 可选项 int 0 ivec2 [0, 0] ivec3 [0, 0, 0] ivec4 [0, 0, 0, 0] float 0 vec2 [0, 0] vec3 [0, 0, 0] vec4 [0, 0, 0, 0] sampler2D default black, grey, white, normal, default samplerCube default-cube black-cube, white-cube, default-cube 对于 defines： boolean 类型默认值为 false。 number 类型默认值为 0，默认取值范围为 [0, 3]。 string 类型默认值为 options 数组第一个元素。 "},"material-system/builtin-shader-uniforms.html":{"url":"material-system/builtin-shader-uniforms.html","title":"Builtin Shader Uniforms","keywords":"","body":"常用 shader 内置 Uniform 要在 shader 中使用内置变量，需要包含对应头文件。 目前所有的内置变量，按所在头文件分组，依次有： cc-local.chunk Name Type Info cc_matWorld mat4 模型空间转世界空间矩阵 cc_matWorldIT mat4 模型空间转世界空间逆转置矩阵 cc-global.chunk Name Type Info cc_time vec4 x：游戏运行时间（秒） cc_screenSize vec4 xy：屏幕尺寸zw：屏幕尺寸倒数 cc_screenScale vec4 xy：屏幕缩放zw：屏幕缩放倒数 cc_nativeSize vec4 xy：实际着色缓冲的尺寸zw：实际着色缓冲的尺寸倒数 cc_matView mat4 视图矩阵 cc_matViewInv mat4 视图逆矩阵 cc_matProj mat4 投影矩阵 cc_matProjInv mat4 投影逆矩阵 cc_matViewProj mat4 视图投影矩阵 cc_matViewProjInv mat4 视图投影逆矩阵 cc_cameraPos vec4 xyz：相机位置 cc_exposure vec4 x：相机曝光y：相机曝光倒数z：是否启用 HDRw：HDR 转 LDR 缩放参数 cc_mainLitDir vec4 xyz：主方向光源方向 cc_mainLitColor vec4 xyz：主方向光颜色w：主方向光强度 cc_ambientSky vec4 xyz：天空颜色w：亮度 cc_ambientGround vec4 xyz：地面反射光颜色 cc-environment.chunk Name Type Info cc_environment samplerCube IBL 环境贴图 cc-forward-light.chunk Name Type Info cc_sphereLitPos[MAX_LIGHTS] vec4 xyz：球面光位置 cc_sphereLitSizeRange[MAX_LIGHTS] vec4 x：球光尺寸y：球光范围 cc_sphereLitColor[MAX_LIGHTS] vec4 xyz：球光颜色w：球光强度 cc_spotLitPos[MAX_LIGHTS] vec4 xyz：聚光灯位置 cc_spotLitSizeRangeAngle[MAX_LIGHTS] vec4 x：聚光灯尺寸y：聚光灯范围z：聚光灯角度 cc_spotLitDir[MAX_LIGHTS] vec4 xyz：聚光灯方向 cc_spotLitColor[MAX_LIGHTS] vec4 xyz：聚光灯颜色w：聚光灯强度 cc-shadow.chunk Name Type Info cc_matLightPlaneProj mat4 平面阴影的变换矩阵 cc_shadowColor vec4 阴影颜色 "},"module-map/effects/":{"url":"module-map/effects/","title":"特效组件","keywords":"","body":"特效组件 特效组件包括 广告牌 和 线段组件，可在 属性检查器 中点击 添加组件 -> Effects 进行添加。 具体的说明及使用请参考： 广告牌 线段组件 "},"particle-system/billboard-component.html":{"url":"particle-system/billboard-component.html","title":"广告牌","keywords":"","body":"Billboard 组件 Billboard 组件用于渲染一个始终面向摄像机的方块。 属性 说明 Texture billboard 显示的贴图。 Height billboard 的高度。 Width billboard 的宽度。 Rotation billboard 绕中心点旋转的角度。 Billboard 组件接口请参考 Billboard API。 "},"particle-system/line-component.html":{"url":"particle-system/line-component.html","title":"线段组件","keywords":"","body":"Line 组件 Line 组件用于渲染 3D 场景中给定的点连成的线段。Line 组件渲染的线段是有宽度的，并且总是面向摄像机，这与 billboard 组件相似。 属性 功能 texture 线段中显示的贴图。 worldSpace 线段中各个点的坐标采用哪个坐标系，勾选使用世界坐标系，不选使用本地坐标系。 positions 每个线段端点的坐标。 width 线段宽度，如果采用曲线，则表示沿着线段方向上的曲线变化。 tile 贴图平铺次数。 offset 贴图坐标的偏移。 color 线段颜色，如果采用渐变色，则表示沿着线段方向上的颜色渐变。 Line 组件接口请参考 Line API。 "},"concepts/scene/skybox.html":{"url":"concepts/scene/skybox.html","title":"天空盒","keywords":"","body":"天空盒 游戏中的天空盒是一个包裹整个场景的立方体，可以很好地渲染并展示整个场景环境，在基于 PBR 的工作流中天空盒也可以贡献非常重要的 IBL 环境光照。 开启天空盒 在 层级管理器 中选中 Scene，然后在 属性检查器 的 skybox 组件中勾选 Enabled 属性即可开启天空盒。 skybox 组件属性如下： 属性 说明 Enabled 是否开启天空盒 UseIBL 是否使用环境光照 Envmap 环境贴图，TextureCube 类型，具体设置方法可参考下文介绍。当该属性为空时，天空盒默认使用和显示的是像素贴图 IsRGBE 环境贴图的像素格式是否为 RGBE 设置天空盒的环境贴图 开启天空盒之后还需要设置天空盒的环境贴图，用于在场景中产生环境光照。天空盒的环境贴图资源可以是 TextureCube 类型的单张贴图，或者是由六张 texture 类型的贴图组合而成的 CubeMap（立方体贴图）。所以开发者可通过以下两种方式来设置天空盒的环境贴图。 通过设置 TextureCube 类型的贴图资源 导入贴图资源，直接将图片资源拖拽到 资源管理器 面板即可。 选中导入的贴图资源，在右侧的 属性检查器 面板中将 Type 属性设置为 texture cube，然后点击右上角的绿色打钩按钮保存设置。 在 层级管理器 中选中 Scene，然后将设置好的图片资源拖拽到 属性检查器 中 skybox 组件的 Envmap 属性框中： 这样子天空盒就设置完成了，开发者可以在 场景编辑器 中看到设置后的天空盒的环境贴图。若贴图没有正确显示，需要检查 SkyIllumination 参数 的值是否太低，或者 修改 Camera 的 Clear Flag。 SkyIllumination 参数 在 层级管理器 中选中 Scene，然后在 属性检查器 的 ambient 组件中即可看到 SkyIllumination 参数，默认值为 20000。 若 SkyIllumination 参数值设置 太低 可能会导致天空盒的环境贴图无法在 场景编辑器 中正确显示。一般情况下： 当 SkyIllumination 参数值小于 300 时，天空盒的环境贴图便无法正常显示。 当 SkyIllumination 参数值为 5000 时，效果相当于月夜的光照强度。 修改 Camera 的 Clear Flag 若 场景编辑器 中天空盒的环境贴图已经可以正确显示，但是在项目运行之后仍然没有生效，此时就需要修改 Camera 组件的 ClearFlag 为 SKYBOX： 通过设置 CubeMap（立方体贴图） 如果要使用 CubeMap（立方体贴图）作为天空盒的环境贴图，需要先制作一张 CubeMap 再将其拖拽到 skybox 组件的 Envmap 属性框中。操作步骤如下： 在 资源管理器 中将准备好的六张贴图资源全部选中，然后在 属性检查器 中将这些贴图资源的 Type 属性批量设置为 texture，并点击右上角的绿色打钩按钮。 新建 CubeMap 资源。在 资源管理器 中选中要存放 CubeMap 的文件夹，点击左上角的 + 按钮，然后选择 Cubemap 即可。或者也可以右键点击要存放 CubeMap 的文件夹，选择 新建 -> Cubemap。 将刚才设置为 texture 类型的 6 张贴图拖拽到 CubeMap 对应的属性框中，完成后点击右上方的绿色打钩按钮，这样就完成了一张 CubeMap。 注意： CubeMap 中未设置贴图的属性框将使用默认资源进行填充。 CubeMap 中的 6 个属性框 不要使用同一张贴图，否则会导致某些平台无法正常显示。 最后，将完成的 CubeMap 资源拖入到 skybox 组件的 Envmap 属性框中，这样就完成了 CubeMap 的应用。 "},"concepts/scene/fog.html":{"url":"concepts/scene/fog.html","title":"全局雾","keywords":"","body":"全局雾 全局雾用于在游戏中模拟室外环境中的雾效果。在游戏中除了用于雾效表现外，还可以用于隐藏摄像机远剪切平面外的模型来提高渲染的性能。 在 层级管理器 中选中 Scene，然后在 属性检查器 的 fog 组件中勾选 Enabled 属性即可开启全局雾。 全局雾类型 全局雾雾化类型取决于 相机 与 模型顶点 的计算结果，这个计算结果称为 雾化混合因子。雾化混合因子决定了雾化颜色和模型颜色的混合方式，最终展现出来的不同的全局雾效果。目前包括 LINEAR、EXP、EXP_SQUARED、LAYERED 四种雾化类型。 Linear（线性雾） 属性 说明 Enabled 是否开启全局雾 FogColor 设置全局雾的颜色 Type 全局雾的雾化类型 FogStart 雾效影响的起始位置 FogEnd 雾效影响的结束位置 Linear Fog 的雾化混合因子计算公式为： f = (FogEnd - Cam_dis) / (FogEnd - FogStart) 当 Cam_dis = FogEnd，也就是相机与模型顶点的距离等于 FogEnd 时，混合因子的计算结果为 0，此时物体为全雾化。 当 Cam_dis = FogStart，也就是相机与模型顶点的距离等于 FogStart 时，混合因子的计算结果为 1，此时物体不受任何雾化的影响。 在相机与模型顶点的距离固定的情况下，若要增加 Linear Fog 的浓度，有以下两种方式： 固定 FogStart 数值，减小 FogEnd 数值。 减小 FogStart 数值，固定 FogEnd 数值。 如果要调整合适的雾效浓度，最好同时对 FogStart 和 FogEnd 属性进行适当的调整。Linear Fog 示例效果图如下： Exponential（指数雾）和 Exponential Squared（指数平方雾） 属性 说明 Enabled 是否开启全局雾 FogColor 设置全局雾的颜色 Type 全局雾的雾化类型 FogDensity 雾化浓度，取值范围为 0 ~ 1 FogAtten 雾化衰减系数 Exponential Fog 的雾化混合因子计算公式为： f = e^(-distance * fogDensity) Exponential Squared Fog 的雾化混合因子计算公式为： f = e^(-distance * fogDensity)² 开发者可以通过 FogDensity 和 FogAtten 来调整全局雾在不同位置的浓度。 Exponential Fog 的示例效果图如下： Layered（层雾） Layered Fog（层雾）平行于水平面，具有一定的高度。可在场景世界坐标系垂直方向上的任一位置设定 Layered Fog 的顶部，以此来确定雾的高低。 属性 说明 Enabled 是否开启全局雾 FogColor 设置全局雾的颜色 Type 全局雾的雾化类型 FogAtten 雾化衰减系数 FogTop 模型顶点在世界坐标系垂直方向上的位置，小于该位置时所有的顶点都会受到雾化效果的影响 FogRange 雾化效果影响的范围 Layered Fog 的雾化计算相比前面三种雾化类型稍显复杂，引入了 FogTop 的概念，同时还需要在 x-z 平面进行距离计算。 Layered Fog 在现实中还是比较常见的，高耸入云的山脉和建筑物都有它的身影，如果能合理利用，相信对场景展现效果有不错的提升，但与此同时计算量也会有一定的增大，开发者可根据需要来决定。 Layered Fog 的示例效果图如下： "},"2d-object/":{"url":"2d-object/","title":"2D 对象","keywords":"","body":"2D 对象概述 区别于 3D 模型对象，我们将不涉及模型的图片渲染体统称为 2D 渲染对象。2D 渲染对象的处理在底层的数据提交上与 3D 模型存在差异，其遵循自己的规则做出了一些针对性的调整以实现更好的效率表现和使用体验。 2D 对象渲染结构说明 2D 渲染对象的收集采用树状结构，RenderRoot 节点（带有 RenderRoot2D 组件的节点）为 2D 对象数据收集的入口节点，所有的 2D渲染对象需在 RenderRoot 节点下才可以被渲染。由于 Canvas 组件本身继承 RenderRoot2D 组件，所以 Canvas 组件也可以作为数据收集的入口。2D 渲染节点必须带有 UITransform 组件作为渲染顶点数据、点击或者对齐策略等功能生效的必要条件。 2D 渲染也可以支持对模型进行渲染，唯一的条件是带有网格渲染器组件（例如 MeshRenderer/SkinnedMeshRenderer）的节点必须添加 UI/UIMeshRenderer 组件才可以和 UI 在相同的管线上进行渲染。 2D 渲染流程如下： 2D 对象分类 2D 对象大致上可以分为两类，2D 渲染对象 和 用户界面 User-interface（UI），其区别主要在于 2D 渲染对象一般只负责将 2D 对象渲染出来，而 UI 则更多的承担着用户交互的能力。具体的差别用户可参考具体的详细说明： 2D 渲染 UI 系统 "},"2d-object/2d-render/":{"url":"2d-object/2d-render/","title":"2D 渲染","keywords":"","body":"2D 渲染 引擎中所有不拥有的 model 的渲染对象都为 2D 渲染对象。与 3D 对象不同，2D 对象本身不拥有 model 信息，其顶点信息是由 UITransform 组件的 Rect 信息持有并由引擎创建的，且本身没有厚度。由于引擎的设计要求，2D 渲染对象需要为 RenderRoot 节点（带有 RenderRoot2D 组件的节点）的子节点才能完成数据的收集操作。 所以 2D 渲染对象的渲染要求有两点： 自身带有 UITransform 组件 需要为带有 RenderRoot2D/Canvas 组件节点的子节点 2D 渲染对象可见性说明 由于 2D 渲染对象在 Camera 的可见性判断上和 3D 渲染节点并无区别，所以用户需要自己控制节点的 layer 属性并设置 Camera 的 Visibility 来配合进行分组渲染，如果场景中出现多个相机的情况，错误的 layer 设置导致节点重复渲染或不渲染。 这里请 3D 1.2 版本升级的用户注意，我们纠正了之前的 Canvas 只会渲染其子节点的行为，目前需要用户自己管理节点的 layer 和相机的 Visibility，之前使用了多 Canvas 渲染的用户可能会需要对项目做出调整以达到更合理的场景结构。 2D 渲染组件 本身拥有渲染能力的组件我们称为 2D 渲染组件，包括： Sprite 组件参考 Label 组件参考 Mask 组件参考 Graphics 组件参考 RichText 组件参考 UIStaticBatch 组件参考 TiledMap 组件参考 TiledTile 组件参考 Spine（骨骼动画）Skeleton 组件参考 DragonBones（龙骨）ArmatureDisplay 组件参考 MotionStreak 组件参考 组件添加方式 我们在编辑器内置了一些 2D 渲染组件，在创建了 RenderRoot 节点之后，即可在此节点下创建带有 2D 渲染组件的节点： 也可以通过在节点上添加组件的方式来添加 2D 渲染组件，组件菜单中的 2D 菜单下的节点均为 2D 渲染组件： 注意：每个节点上只能添加一个渲染组件，重复添加会导致报错。 组件规则介绍 渲染排序规则 2D 渲染组件合批规则说明 2D 渲染对象自定义材质 "},"ui-system/components/engine/priority.html":{"url":"ui-system/components/engine/priority.html","title":"渲染排序规则","keywords":"","body":"渲染排序说明 2D 渲染节点排序 2D 渲染节点可分为在 Canvas 下的节点和不在 Canvas 下的节点两种： 在 Canvas 下的节点可参考下文 UI 节点排序 部分的内容。 不在 Canvas 下的节点，用户可选择通过 自定义材质 来开启深度检测实现和 3D 物体的遮挡显示，开启后会按照物体的 Z 轴坐标进行遮挡渲染（可参考范例 2d-rendering-in-3d（GitHub | Gitee）。若未开启深度检测，则数据提交依旧会按照节点树顺序提交，也就意味着节点树靠下的节点会后渲染。 UI 节点排序 UI 节点特指在 Canvas 节点下的 UI 节点，这些节点并未开启深度测试，所以节点的混合是严格按照节点树进行排序的。UI 的渲染排序采用的是一个深度优先的排序方式，每一个 UITransform 组件身上都有一个 priority 属性，根据 priority 的值来调整节点顺序。排序从根节点下的子节点开始，根据子节点的优先级来确定整体的渲染结构，也就是根节点下的子节点的排序已经决定了最终的渲染顺序。每一个节点下的所有子节点的 priority 则用来确定在当前节点下的渲染顺序。直接修改了 priority 也会直接改变节点树顺序。 举个例子： 因此，上图中整体的渲染顺序则是：B -> b1 -> C -> A -> a1 -> a2，在屏幕上的呈现状态为：a2 -> a1 -> A -> C -> b1 -> B。 注意事项 排序是一个很简单的功能，但是最终的呈现却是根据不同平台提供的渲染能力来的。因此，在这里说明一下，如果遇到了 UI 渲染出错，花屏，闪屏等现象，首先要检查的就是场景里所有相机（Camera 和 Canvas）的 ClearFlag，确保 场景里必须有一个相机要执行 Solid_Color 清屏操作。 具体如何设置 ClearFlag，可参考以下几种情况： 如果场景中只有一个 UI Canvas 或者 3D Camera，那么 ClearFlag 属性设置为 Solid_Color。 如果场景中包含 2D 背景层、3D 场景层、 2D UI 层，则： 2D 背景层：ClearFlag 属性设置为 Solid_Color。 3D 场景层：ClearFlag 属性设置为 Depth_Only。 2D UI 层：若有模型，ClearFlag 属性设置为 Depth_Only 以避免出现模型闪屏或者穿透的情况。若没有模型，ClearFlag 属性可设置为 Dont_Clear 或 Depth_Only。 "},"ui-system/components/engine/ui-batch.html":{"url":"ui-system/components/engine/ui-batch.html","title":"2D 渲染组件合批说明","keywords":"","body":"2D 渲染组件合批规则说明 合批条件说明 2D 渲染组件合批的规则是节点的 layer、使用的材质、渲染组件的 blendState 和 DepthStencilState 相同、贴图源以及贴图采样都相同才会进行合批。 下面我们就分别说明一下这些条件： 节点的 layer：由于 layer 会涉及到渲染与否，所以不同的 layer 之间不能进行合批 材质：材质相同是合批的必然要求，由于我们使用的材质实例化的机制，所以用户在设置了材质的 uniform 之后材质会进行实例化，实例化之后的材质是无法进行合批的，如果自定义材质进行了 uniform 设置之后导致此组件无法合批，之后 uniform 值使用完毕想要该组件参与合批，可将材质资源重新赋值给组件即可重新使组件参与合批（通过 CustomMaterial 接口赋值即可） BlendState 状态：对于部分 2D 渲染组件可以在面板上设置部分的 BlendState 值，这个值不同的话是无法进行合批的 DepthStencilState 状态：这个值控制着组件的深度检测和模板缓冲，一般来说用户不需关心这个值的设置，这个值由引擎自动控制（用于 Mask 的效果实现） 贴图源和贴图采样：一般来说，这个条件是影响合批的最主要的条件，尤其对于精灵和文本来说，贴图很容易产生差别导致无法合批。引擎提供了部分方法来实现更好的合批，可参考后文。 合批方法说明 结合以上的合批条件说明，我们可以通过一些方法来实现更好的合批方法，需要额外说明的是，2D 渲染组件的渲染数据采集是一个基于节点树的渲染方式，而一些组件是会打断合批的，目前引擎的内置组件 Mask，Graphics，UIMeshRenderer 由于材质不同和数据组织方式的差异会无法与其他组件合批，而 TiledMap，Spine 和 DragonBones 这三个中间件组件遵循自己的内部合批机制，所以上述组件都无法合批，且会打断其他组件合批，需要用户进行分模块管理节点树布局，以达到更好的合批效果。 对于 Sprite 组件，我们提供了 静态合图 和 动态合图 两种合批方案，通过将图片纹理合并，即可在其他条件满足的情况下合批 对于 Label 组件，我们提供了 Bitmap 的缓存方法，通过将 Label 的纹理合图，即可实现 Sprite 和 Label 组件的合批，但请注意，使用 Bitmap 缓存方式的 Label 不可频繁变动文字内容 一般来说，用户通过控制材质和节点树状态配合合图方法，能够达到较好的合批效果 "},"ui-system/components/engine/ui-material.html":{"url":"ui-system/components/engine/ui-material.html","title":"2D 渲染对象自定义材质","keywords":"","body":"2D 渲染对象自定义材质 2D 渲染对象的自定义材质是拓展 2D 渲染对象表现和提升 2D 渲染对象自身能力的最佳实践，可以通过自定义材质实现溶解、外发光等酷炫的渲染效果。 v3.0 的 2D 渲染组件大部分都支持使用自定义材质，其使用界面如下图（以 Sprite 组件为例）： 其使用方法与其他内置材质并无不同，将要使用的材质拖拽到 CustomMaterial 属性框中即可，但有一些需要注意的点如下： 当未指定自定义材质时，会使用内置材质进行渲染，面板功能及使用方法可参考 Sprite 组件参考 文档。 2D 渲染对象并不支持多材质，自定义材质的数量最多为一个。 请使用 builtin-spine 或 builtin-sprite 等 2D 专用 Shader 来自定义材质，请勿选择其他 3D 组件使用的 shader。 当使用了 2D 渲染对象自定义材质之后，面板上的 Grayscale 属性功能将会失效，用户可选择自行在材质中实现此功能。 使用了自定义材质之后，组件上的 BlendFactor 设置面板会自动隐藏且设置会失效，此时的 BlendFactor 会以自定义材质中的设置为准。 使用了自定义材质之后，组件的深度检测信息会以材质为准。如果想要实现和 3D 物体的遮挡，请使用自定义材质并开启深度检测。可参考范例 2d-rendering-in-3d（GitHub | Gitee）。 针对自定义材质，获取上传的贴图需要在 shader 中引入 cc-sprite-texture 头文件，文件中的 cc_spriteTexture 就对应在 2D 渲染组件属性面板上设置的 SpriteFrame 图片资源。例如一个简单地使用了面板设置 SpriteFrame 来采样纹理的 fragment shader 应该是下面的样子： CCProgram sprite-fs %{ precision highp float; #include in vec4 v_color; uniform ARGS{ float time; }; in vec2 uv0; uniform sampler2D u_normalMap; vec4 frag () { vec4 color = vec4(1, 1, 1, 1); color *= v_color; float value = 1.0; vec4 o = texture(u_normalMap, uv0); value *= o.r; if (value 如果用户希望对自定义材质进行 uniform 赋值操作，可通过获取 2D 渲染组件上的 customMaterial 来进行操作，我们提供了不同的接口以应对不同的操作情况，如下代码所示：（以 Sprite 为例）（请一定注意看不同接口的注释说明！） let spriteComp = this.node.getComponent(Sprite); // 通过 sharedMaterial 方法获取到的是“共享材质资源”，针对 material 进行的操作将会影响到所有使用此材质的渲染对象，此操作不会使资源实例化，不会影响合批 let material = spriteComp.sharedMaterial; // 通过 material 方法获取到的是“当前渲染组件使用的材质示例”，针对 material Instance 进行的操作只会对当前组件产生影响，此操作会使资源实例化，一旦实例化，此组件无法与其他组件合批 let materialInstance = spriteComp.material; "},"ui-system/components/editor/render-component.html":{"url":"ui-system/components/editor/render-component.html","title":"2D 渲染组件","keywords":"","body":"2D 渲染组件介绍 Sprite 组件参考 Label 组件参考 Mask 组件参考 Graphics 组件参考 RichText 组件参考 UIStaticBatch 组件参考 TiledMap 组件参考 TiledTile 组件参考 Spine（骨骼动画）Skeleton 组件参考 DragonBones（龙骨）ArmatureDisplay 组件参考 MotionStreak 组件参考 "},"ui-system/components/editor/sprite.html":{"url":"ui-system/components/editor/sprite.html","title":"Sprite 组件参考","keywords":"","body":"Sprite 组件参考 Sprite（精灵）是 2D/3D 游戏最常见的显示图像的方式，在节点上添加 Sprite 组件，就可以在场景中显示项目资源中的图片。 点击 属性检查器 下面的 添加组件 按钮，然后选择 UI/Render/Sprite 即可添加 Sprite 组件到节点上。 图像的组件接口请参考 Sprite API。 关于使用可以参考范例 Sprite（GitHub | Gitee）。 Sprite 属性 属性 功能说明 Type 渲染模式，包括普通（Simple）、九宫格（Sliced）、平铺（Tiled）和填充（Filled）四种模式 CustomMaterial 自定义材质，使用方法参考 自定义材质 Src Blend Factor 当前图像混合模式 Dst Blend Factor 背景图像混合模式，和上面的属性共同作用，可以将前景和背景 Sprite 用不同的方式混合渲染，效果预览可以参考 glBlendFunc Tool Color 图片颜色 Sprite Atlas Sprite 显示图片资源所属的图集（参考 Atlas）。 Sprite Frame 渲染 Sprite 使用的 SpriteFrame 图片资源。（Sprite Frame 后面的 编辑 按钮用于编辑图像资源的九宫格切分，详情请参考 使用 Sprite 编辑器制作九宫格图像） Size Mode 指定 Sprite 的尺寸Trimmed 表示会使用原始图片资源裁剪透明像素后的尺寸Raw 表示会使用原始图片未经裁剪的尺寸 Custom 表示会使用自定义尺寸。当用户手动修改过 Size 属性后，Size Mode 会被自动设置为 Custom，除非再次指定为前两种尺寸。 Grayscale 灰度模式，开启后 Sprite 会使用灰度模式渲染。 Trim 是否渲染原始图像周围的透明像素区域，详情请参考 图像资源的自动剪裁 添加 Sprite 组件之后，通过从 资源管理器 中拖拽 SpriteFrame 类型的资源到 SpriteFrame 属性引用中，就可以通过 Sprite 组件显示资源图像。 如果拖拽的 SpriteFrame 资源是包含在一个 Atlas 图集资源中的，那么 Sprite 的 Atlas 属性也会被一起设置。 若要动态更换 SpriteFrame 则需要先动态加载图片资源，然后再进行替换，详情请参考 获取和加载资源：动态加载。 渲染模式 Sprite 组件支持以下几种渲染模式： 普通模式（Simple）：根据原始图片资源渲染 Sprite，一般在这个模式下我们不会手动修改节点的尺寸，来保证场景中显示的图像和美术人员生产的图片比例一致。 九宫格模式（Sliced）：图像将被分割成九宫格，并按照一定规则进行缩放以适应可随意设置的尺寸(size)。通常用于 UI 元素，或将可以无限放大而不影响图像质量的图片制作成九宫格图来节省游戏资源空间。详细信息请阅读 使用 Sprite 编辑器制作九宫格图像 一节。 平铺模式（Tiled）：当 Sprite 的尺寸增大时，图像不会被拉伸，而是会按照原始图片的大小不断重复，就像平铺瓦片一样将原始图片铺满整个 Sprite 规定的大小。 填充模式（Filled）：根据原点和填充模式的设置，按照一定的方向和比例绘制原始图片的一部分。经常用于进度条的动态展示。 填充模式（Filled） Type 属性选择填充模式后，会出现一组新的属性可供配置： 属性 功能说明 Fill Type 填充类型选择，有 HORIZONTAL（横向填充）、VERTICAL（纵向填充）和 RADIAL（扇形填充）三种。 Fill Start 填充起始位置的标准化数值（从 0 ~ 1，表示填充总量的百分比），选择横向填充时，Fill Start 设为 0，就会从图像最左边开始填充 Fill Range 填充范围的标准化数值（同样从 0 ~ 1），设为 1，就会填充最多整个原始图像的范围。 Fill Center 填充中心点，该属性只有选择了 RADIAL 填充类型才能修改。决定了扇形填充时会环绕 Sprite 上的哪个点。 Fill Range 填充范围补充说明 在 HORIZONTAL 和 VERTICAL 这两种填充类型下，Fill Start 设置的数值将影响填充总量，如果 Fill Start 设为 0.5，那么即使 Fill Range 设为 1.0，实际填充的范围也仍然只有 Sprite 总大小的一半。 而 RADIAL 类型中 Fill Start 只决定开始填充的方向，Fill Start 为 0 时，从 x 轴正方向开始填充。Fill Range 决定填充总量，值为 1 时将填充整个圆形。Fill Range 为正值时逆时针填充，为负值时顺时针填充。 "},"ui-system/components/editor/label.html":{"url":"ui-system/components/editor/label.html","title":"Label 组件参考","keywords":"","body":"Label 组件参考 Label 组件用来显示一段文字，文字可以是系统字体，TrueType 字体、BMFont 字体或艺术数字。另外，Label 还具有排版功能。 点击 属性检查器 下面的 添加组件 按钮，然后从 UI/Render 中选择 Label，即可添加 Label 组件到节点上。 Label 的组件接口请参考 Label API。 具体使用方法可参考范例 Label（GitHub | Gitee）。 Label 属性 属性 功能说明 CustomMaterial 自定义材质，使用方法参考 自定义材质 SrcBlendFactor 当前渲染混合模式 DstBlendFactor 背景混合模式，和上面的属性共同作用，可以将前景和背景渲染的文本用不同的方式混合，效果预览可以参考 glBlendFunc Tool Color 文字颜色。 String 文本内容字符串。 HorizontalAlign 文本的水平对齐方式。可选值有 LEFT、CENTER 和 RIGHT。 VerticalAlign 文本的垂直对齐方式。可选值有 TOP、CENTER 和 BOTTOM。 FontSize 文本字体大小。 FontFamily 文字字体名字。在使用系统字体时生效。 LineHeight 文本的行高。 Overflow 文本的排版方式，目前支持 CLAMP、SHRINK 和 RESIZE_HEIGHT。详情见下方的 Label 排版 或者 文字排版。 EnableWrapText 是否开启文本换行。（在排版方式设为 CLAMP、SHRINK 时生效） Font 指定文本渲染需要的 字体资源。若要使用艺术数字字体，请参考 艺术数字资源 文档进行配置。如果使用系统字体，则此属性可以为空。 UseSystemFont 布尔值，是否使用系统字体。 CacheMode 文本缓存类型，仅对 系统字体 或 TTF 字体有效，BMFont 字体无需进行这个优化。包括 NONE、BITMAP、CHAR 三种模式。详情见下方的 文本缓存类型。 IsBold 文字是否加粗，支持系统字体以及部分 TTF 字体。 IsItalic 文字是否倾斜，支持系统字体以及 TTF 字体。 IsUnderline 文字是否加下划线，支持系统字以及 TTF 字体。 Label 排版 属性 功能说明 CLAMP 文字尺寸不会根据 Content Size 的大小进行缩放。Wrap Text 关闭的情况下，按照正常文字排列，超出 Content Size 的部分将不会显示。Wrap Text 开启的情况下，会试图将本行超出范围的文字换行到下一行。如果纵向空间也不够时，也会隐藏无法完整显示的文字。 SHRINK 文字尺寸会根据 Content Size 大小进行自动缩放（不会自动放大，最大显示 Font Size 规定的尺寸）。Wrap Text 开启时，当宽度不足时会优先将文字换到下一行，如果换行后还无法完整显示，则会将文字进行自动适配 Content Size 的大小。Wrap Text 关闭时，则直接按照当前文字进行排版，如果超出边界则会进行自动缩放。 RESIZE_HEIGHT 文本的 Content Size 会根据文字排版进行适配，这个状态下用户无法手动修改文本的高度，文本的高度由内部算法自动计算出来。 文本缓存类型（Cache Mode） 类型 功能说明 NONE 默认值，Label 中的整段文本将生成一张位图。 BITMAP 选择后，Label 中的整段文本仍将生成一张位图，但是会尽量参与 动态合图。只要满足动态合图的要求，就会和动态合图中的其它 Sprite 或者 Label 合并 Draw Call。由于动态合图会占用更多内存，该模式只能用于文本不常更新的 Label。此模式在节点安排合理的情况下可大幅降低 Draw Call，请酌情选择使用 CHAR 原理类似 BMFont，Label 将以“字”为单位将文本缓存到全局共享的位图中，相同字体样式和字号的每个字符将在全局共享一份缓存。能支持文本的频繁修改，对性能和内存最友好。不过目前该模式还存在如下限制，我们将在后续的版本中进行优化：1、该模式只能用于字体样式和字号（通过记录字体的 fontSize、fontFamily、color、outline 为关键信息，以此进行字符的重复使用，其他有使用特殊自定义文本格式的需要注意）固定，并且不会频繁出现巨量未使用过的字符的 Label。这是为了节约缓存，因为全局共享的位图尺寸为 2048*2048，只有场景切换时才会清除，一旦位图被占满后新出现的字符将无法渲染。2、Overflow 不支持 SHRINK。3、不能参与动态合图（同样启用 CHAR 模式的多个 Label 在渲染顺序不被打断的情况下仍然能合并 Draw Call） 注意：Cache Mode 对所有平台都有优化效果。 "},"ui-system/components/editor/mask.html":{"url":"ui-system/components/editor/mask.html","title":"Mask 组件参考","keywords":"","body":"Mask（遮罩）组件参考 Mask 用于规定子节点可渲染的范围，默认带有 Mask 组件的节点会使用该节点的约束框（也就是 属性检查器 中 Node 组件的 ContentSize 规定的范围）创建一个矩形渲染遮罩，该节点的所有子节点都会依据这个遮罩进行裁剪，遮罩范围外的将不会渲染。 点击 属性检查器 下面的 添加组件 按钮，然后从 UI 中选择 Mask，即可添加 Mask 组件到节点上。注意该组件不能添加到有其他渲染组件（如 Sprite、Label 等）的节点上。 遮罩的组件接口请参考 Mask API。 关于使用可以参考范例 Mask（GitHub | Gitee）。 Mask 属性 属性 功能说明 Type 遮罩类型。包括 RECT、ELLIPSE、GRAPHICS_STENCIL、IMAGE_STENCIL 四种类型。 Segments 椭圆遮罩的曲线细分数，只在遮罩类型设为 ELLIPSE 时生效 Inverted 反向遮罩 SpriteFrame 图片遮罩所使用图片 Type RECT 矩形遮罩 ELLIPSE 椭圆遮罩 可以在运行时通过代码设置： const mask = this.getComponent(Mask); mask.type = Mask.Type.ELLIPSE; mask.segments = 32; GRAPHICS_STENCIL 自定义图形遮罩 可以在运行时通过代码设置： const mask = this.getComponent(Mask); mask.type = Mask.Type.GRAPHICS_STENCIL; const g = mask.graphics; g.lineWidth = 10; g.fillColor.fromHEX('#ff0000'); g.moveTo(-40, 0); g.lineTo(0, -80); g.lineTo(40, 0); g.lineTo(0, 80); g.close(); g.stroke(); g.fill(); IMAGE_STENCIL 自定义图片遮罩 可以在运行时通过代码设置： const mask = this.getComponent(Mask); mask.type = Mask.Type.IMAGE_STENCIL; mask.spriteFrame = this.spriteFrame; mask.alphaThreshold = 0.1; 注意： 节点添加了 Mask 组件之后，所有在该节点下的子节点，在渲染的时候都会受 Mask 影响。 GRAPHICS_STENCIL 类型在这里没有做任何引擎需要的事，只是放开了对 graphics 操控，用户可以使用 mask 组件里的 graphics 属性来绘制自定义图形，但是节点的点击事件还是根据节点的尺寸来计算。 IMAGE_STENCIL 类型默认需要一个图片资源，如果没有设置的话，相当于没有遮罩。 在当前版本以及之前版本上，由于底层渲染架构原因，Mask 在编辑器下的所有子节点的渲染内容都看不见。 解决方法：在编辑器下调整 Mask 节点的 layer 为 default 即可，不会影响运行时数据。 "},"ui-system/components/editor/graphics.html":{"url":"ui-system/components/editor/graphics.html","title":"Graphics 组件参考","keywords":"","body":"Graphics 组件参考 Graphics 组件提供了一系列绘画接口，这些接口参考了 Canvas 的绘画接口来进行实现。 新建一个空节点，然后点击 属性检查器 下方的 添加组件 按钮，从 UI/Render 中选择 Graphics，即可添加 Graphics 组件到节点上。 Graphics 脚本接口请参考 Graphics API。 关于使用可以参考范例 Graphics（GitHub | Gitee）。 Graphics 组件属性 属性 功能说明 CustomMaterial 自定义材质，可用于实现溶解、外发光等渲染效果。 LineWidth 设置或返回当前的线条宽度 LineJoin 设置或返回两条线相交时，所创建的拐角类型 LineCap 设置或返回线条的结束端点样式 StrokeColor 设置或返回笔触的颜色 FillColor 设置或返回填充绘画的颜色 MiterLimit 设置或返回最大斜接长度 绘图接口 路径 方法 功能说明 moveTo (x, y) 把路径移动到画布中的指定点，不创建线条 lineTo (x, y) 添加一个新点，然后在画布中创建从该点到最后指定点的线条 bezierCurveTo (c1x, c1y, c2x, c2y, x, y) 创建三次方贝塞尔曲线 quadraticCurveTo (cx, cy, x, y) 创建二次贝塞尔曲线 arc (cx, cy, r, startAngle, endAngle, counterclockwise) 创建弧/曲线（用于创建圆形或部分圆） ellipse (cx, cy, rx, ry) 创建椭圆 circle (cx, cy, r) 创建圆形 rect (x, y, w, h) 创建矩形 close () 创建从当前点回到起始点的路径 stroke () 绘制已定义的路径 fill () 填充当前绘图（路径） clear () 清除所有路径 通过脚本代码设置绘制图案 import { _decorator, Component, Graphics } from 'cc'; const { ccclass, property } = _decorator; @ccclass('Example') export class Example extends Component { start () { const g = this.getComponent(Graphics); g.lineWidth = 10; g.fillColor.fromHEX('#ff0000'); g.moveTo(-40, 0); g.lineTo(0, -80); g.lineTo(40, 0); g.lineTo(0, 80); g.close(); g.stroke(); g.fill(); } } "},"ui-system/components/editor/richtext.html":{"url":"ui-system/components/editor/richtext.html","title":"RichText 组件参考","keywords":"","body":"RichText 组件参考 RichText 组件用来显示一段带有不同样式效果的文字，你可以通过一些简单的 BBCode 标签来设置文字的样式。目前支持的样式有：颜色（color）、字体大小（size）、字体描边（outline）、加粗（b）、斜体（i）、下划线（u）、换行（br）、图片（img）和点击事件（on），并且不同的 BBCode 标签是可以支持相互嵌套的。 更多关于 BBCode 标签的内容，请参考本文档的 BBCode 标签格式说明 小节。 点击 属性检查器 下面的 添加组件 按钮，然后选择 UI/Render/RichText 即可添加 RichText 组件到节点上。 富文本的脚本接口请参考 RichText API。 关于使用可以参考范例 RichText（GitHub | Gitee）。 RichText 属性 属性 功能说明 String 富文本的内容字符串，你可以在里面使用 BBCode 来指定特定文本的样式 Horizontal Align 水平对齐方式 Font Size 字体大小，单位是 point（注意：该字段不会影响 BBCode 里面设置的字体大小） Font 富文本定制字体，所有的 label 片段都会使用这个定制的 TTF 字体 Font Family 富文本定制系统字体。 Use System Font 是否使用系统字体。 Max Width 富文本的最大宽度，传 0 的话意味着必须手动换行. Line Height 字体行高，单位是 point Image Atlas 对于 img 标签里面的 src 属性名称，都需要在 imageAtlas 里面找到一个有效的 spriteFrame，否则 img tag 会判定为无效。 Handle Touch Event 选中此选项后，RichText 将阻止节点边界框中的所有输入事件（鼠标和触摸），从而防止输入事件穿透到底层节点。 BBCode 标签格式 基本格式 目前支持的标签类型有：size、color、b、i、u、img 和 on，分别用来定制字体大小、字体颜色、加粗、斜体、下划线、图片和点击事件。每一个标签都有一个起始标签和一个结束标签，起始标签的名字和属性格式必要符合要求，且全部为小写。结束标签的名字不做任何检查，只需要满足结束标签的定义即可。 下面分别是应用 size 和 color 标签的一个例子： 你好，Creator 支持标签 注意：所有的 tag 名称必须是小写，且属性值是用 = 号赋值。 名称 描述 示例 注意事项 color 指定字体渲染颜色，颜色值可以是内置颜色，比如 white，black 等，也可以使用 16 进制颜色值，比如 #ff0000 表示红色 Red Text size 指定字体渲染大小，大小值必须是一个整数 enlarge me Size 值必须使用等号赋值 outline 设置文本的描边颜色和描边宽度 A label with outline 如果你没有指定描边的颜色或者宽度的话，那么默认的颜色是白色 (#ffffff)，默认的宽度是 1 b 指定使用粗体来渲染 This text will be rendered as bold 名字必须是小写，且不能写成 bold i 指定使用斜体来渲染 This text will be rendered as italic 名字必须是小写，且不能写成 italic u 给文本添加下划线 This text will have a underline 名字必须是小写，且不能写成 underline on 指定一个点击事件处理函数，当点击该 Tag 所在文本内容时，会调用该事件响应函数 click me! 除了 on 标签可以添加 click 属性，color 和 size 标签也可以添加，比如 click me param 当点击事件触发时，可以在回调函数的第二个参数获取该数值 click me! 依赖 click 事件 br 插入一个空行 注意： 和 都是不支持的。 img 给富文本添加图文混排功能，img 的 src 属性必须是 ImageAtlas 图集里面的一个有效的 spriteframe 名称 注意：只有 这种写法是有效的。如果你指定一张很大的图片，那么该图片创建出来的精灵会被等比缩放，缩放的值等于富文本的行高除以精灵的高度。 img 标签的可选属性 为了更好地排版，我们为 img 标签类型提供了可选属性，你可以使用 width 及 height 来指定 SpriteFrame 的大小，这将允许该图片可以大于或是小于行高（但此设定不会改变行高）。 当你改变了 SpriteFrame 的高度或宽度后，或许会需要使用 align 来调整该图片在行中的对齐方式。 属性 描述 示例 注意事项 height 指定 SpriteFrame 的渲染高度，大小值必须为整数 如果你只使用了高度属性，该 SpriteFrame 会自动计算宽度以保持图片比例 width 指定 SpriteFrame 的渲染宽度，大小值必须为整数 你可以同时使用高度及宽度属性 align 指定 SpriteFrame 在行中的对齐方式，值必需为 bottom、top 或 center 预设对齐方式为 bottom 为了支持定制图片排版，我们还提供了 offset 属性，用于微调 SpriteFrame 在 RichText 中的位置。设置 offset 时需注意属性值必须为整数，并且如设置不当将导致图片与文字重叠。 offset 属性 示例 描述 注意事项 Y 指定 SpriteFrame 的 y 轴加上 5 当 offset 只设定一个值的时候，它代表 y 轴的偏移 Y 指定 SpriteFrame 的 y 轴减少 5 你可以设定负整数来减少 y 轴 X, Y 指定 SpriteFrame 的 x 轴加上 6，y 轴减少 5 偏移属性的值只能包含 0-9、- 和 , 字符 标签嵌套 标签与标签是支持嵌套的，且嵌套规则跟 HTML 是一样的。比如下面的嵌套标签设置一个文本的渲染大小为 30，且颜色为绿色。 I'm green 也可以实现为: I'm green 文本缓存类型（Cache Mode） 由于富文本组件是由多个 Label 节点拼装而成，所以对于复杂的富文本，drawcall 数量也会比较高，因此引擎为富文本组件提供了 Label 组件的文本缓存类型设置，来适当减少 drawcall 的增加。对于每种缓存类型的具体说明，参照 Label 组件的文本缓存类型 类型 功能说明 NONE 默认值，对富文本所拆分创建的每个 Label 节点，设置其 CacheMode 为 NONE 类型，即将每个 Label 的整段文本生成一张位图并单独进行渲染。 BITMAP 选择后，对富文本所拆分创建的每个 Label 节点，设置其 CacheMode 为 BITMAP 类型，即将每个 Label 的整段文本生成一张位图，并将该位图添加到动态图集中，再依据动态图集进行合并渲染。 CHAR 选择后，对富文本所拆分创建的每个 Label 节点，设置其 CacheMode 为 CHAR 类型，即将每个 Label 的文本以“字”为单位缓存到全局共享的位图中，相同字体样式和字号的每个字符将在全局共享一份缓存。 详细说明 富文本组件全部由 JS 层实现，采用底层的 Label 节点拼装而成，并且在上层做排版逻辑。这意味着，你新建一个复杂的富文本，底层可能有十几个 label 节点，而这些 label 节点都是采用系统字体渲染的。 所以，一般情况下，你不应该在游戏的主循环里面频繁地修改富文本的文本内容，这可能会导致性能比较低。另外，如果能不使用富文本组件，就尽量使用普通的文本组件，并且 BMFont 的效率是最高的。 "},"ui-system/components/editor/ui-static.html":{"url":"ui-system/components/editor/ui-static.html","title":"UIStaticBatch 组件参考","keywords":"","body":"UIStaticBatch 组件参考 UI 静态合批组件是一个提升 UI 渲染性能的组件，脚本在初始化当前帧渲染的过程中会收集该 UI 节点树下的所有渲染数据（除了模型、Mask 和 Graphics），存储为一个静态的 IA 渲染数据。并在后续的渲染流程中使用固定数据进行渲染，不再遍历其节点树，此后的坐标变换将不再生效。当你需要修改静态数据的时候，可以调用 markAsDirty 接口来重新触发渲染数据收集标记。 遮罩的组件接口请参考 UIStaticBatch API。 关于使用可以参考范例 UIStaticBatch（GitHub | Gitee）。 通过脚本代码开启静态合批 import { _decorator, Component } from 'cc'; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { start(){ const uiStatic = this.node.getComponent(UIStaticBatch); // 选择你要开始静态合批的时机，调用此接口开始静态合批 uiStatic.markAsDirty(); } } 注意事项 使用该组件有以下几点需要注意： 不要频繁触发静态合批，因为会清空原先存储的 IA 数据重新采集，会有一定性能和内存损耗。 不适用于子节点树中包含 Mask、Graphics 和 Model 的情况。 对于节点树不会有任何改变的节点（例如 2D 地图），在 开始静态合批之后 即可将所有子节点删除，以得到最好的性能和内存表现。 "},"editor/components/spine.html":{"url":"editor/components/spine.html","title":"Spine Skeleton 组件参考","keywords":"","body":"Spine Skeleton 组件参考 Spine Skeleton 组件支持 Spine 官方工具导出的数据格式，并对 Spine（骨骼动画）资源进行渲染和播放。 在 层级管理器 中选中需要添加 ArmatureDisplay 组件的节点，然后点击 属性检查器 下方的 添加组件 -> Spine -> Skeleton 按钮，即可添加 Skeleton 组件到节点上。 Spine Skeleton 组件的使用方法可参考 Spine（GitHub | Gitee）范例。 Spine Skeleton 相关的脚本接口请参考 Skeleton API。 Spine 属性 属性 功能说明 CustomMaterial 自定义材质，可用于实现溶解、外发光等渲染效果。详情请参考 自定义材质。 Color 设置骨骼动画颜色 SkeletonData 骨骼信息数据，拖拽 Spine 导出后的骨骼资源到该属性中 Default Skin 选择默认的皮肤 Animation 当前播放的动画名称 Animation Cache Mode 渲染模式，包括 REALTIME（默认）、SHARED_CACHE 和 PRIVATE_CACHE 三种。1. REALTIME 模式，实时运算，支持 Spine 所有的功能。2. SHARED_CACHE 模式，将骨骼动画及贴图数据进行缓存并共享，相当于预烘焙骨骼动画。拥有较高性能，但不支持动作融合和动作叠加，只支持动作开始和结束事件。至于内存方面，当创建 N（N>=3）个相同骨骼、相同动作的动画时，会呈现内存优势。N 值越大，优势越明显。综上 SHARED_CACHE 模式适用于场景动画、特效、副本怪物、NPC 等，能极大提高帧率和降低内存。3. PRIVATE_CACHE 模式，与 SHARED_CACHE 类似，但不共享动画及贴图数据，且会占用额外的内存，仅存在性能优势，如果大量使用该模式播放动画可能会造成卡顿。若想利用缓存模式的高性能，但又存在换装需求（不能共享贴图数据）时，那么 PRIVATE_CACHE 就适合你。 Loop 是否循环播放当前动画 PremultipliedAlpha 图片是否启用贴图预乘，默认为 True。当图片的透明区域出现色块时需要关闭该项，当图片的半透明区域颜色变黑时需要启用该项。 TimeScale 当前骨骼中所有动画的时间缩放率 DebugSlots 是否显示 Slot 的 Debug 信息 DebugBones 是否显示骨骼的 Debug 信息 DebugMesh 是否显示 Mesh 的 Debug 信息 UseTint 是否开启染色效果，默认关闭。 Sockets 用于将某些外部节点挂到指定的骨骼关节上，属性的值表示挂点的数量。详情请参考下文介绍。 注意： 当使用 Spine Skeleton 组件时，属性检查器 中 Node 组件上的 Anchor 与 Size 属性是无效的。 Spine Skeleton 组件属于 UI 渲染组件，而 Canvas 节点是 UI 渲染的 渲染根节点，所以带有该组件的节点必须是 Canvas 节点（或者是带有 RenderRoot2D 组件的节点）的子节点才能在场景中正常显示。 当使用 Spine Skeleton 组件时，由于拥有 UseTint 属性，所以其自定义材质需要有两个颜色信息，可参考引擎内置的 builtin-spine.effect（GitHub | Gitee）实现，否则 Spine 的染色效果可能会出错。 Spine 换装 下面通过一个范例介绍 Spine 如何换装。 首先在 层级管理器 中新建一个 Canvas 节点，然后在 Canvas 节点下新建一个空节点并命名为 girl。选中 girl 节点并在 属性检查器 中添加 Skeleton 组件，将资源拖拽至 Skeleton 组件的 SkeletonData 属性框中。可更改 Skeleton 组件的 Animation 属性用于设置想要播放的动画。 在 资源管理器 中新建一个 TypeScript 脚本并命名为 SpineSkin，编写组件脚本。脚本代码如下： import { _decorator, Component, sp } from 'cc'; const { ccclass, property } = _decorator; @ccclass('SpineSkin') export class SpineSkin extends Component { @property({ type:sp.Skeleton }) spine: sp.Skeleton | null = null; skinId: number = 0; start () { // Your initialization goes here. } change() { const skins =['girl', 'boy', 'girl-blue-cape', 'girl-spring-dress'].map(x=> `full-skins/${x}`); this.skinId = (this.skinId + 1) % skins.length; this.spine!.setSkin(skins[this.skinId]); } // update (deltaTime: number) { // // Your update function goes here. // } } 然后将 SpineSkin 脚本挂载到 Canvas 节点上，即将脚本拖拽到 Canvas 节点的 属性检查器 中。再将 层级管理器 中的 girl 节点拖拽到 SpineSkin 脚本组件对应的属性框中，并保存场景。 接下来我们需要利用 Button 组件的点击事件来触发 SpineSkin 脚本中的 change 回调，实现通过点击按钮来切换皮肤。 在 层级管理器 的 Canvas 节点下新建一个 Button 节点并命名为 change_skin，根据需要调整其位置、大小、文字显示等属性。 然后在 属性检查器 中设置 change_skin 节点的点击事件，将挂载了 SpineSkin 脚本组件的 Canvas 节点拖拽到 ClickEvents 属性的 cc.Node 属性框中，指定脚本组件为 SpineSkin，并设置回调为 change： 根据需要调整场景结构，保存场景后点击编辑器上方的预览按钮，点击 change skin 按钮，可以看到人物皮肤已被替换。 注意：若预览时未显示场景，请检查各节点的 Layer 属性是否与 Camera 节点的保持一致。 Spine 顶点效果 顶点效果只有当 Spine Skeleton 组件的 Animation Cache Mode 属性设置为 REALTIME 模式时有效，下面通过一个范例介绍 Spine 如何设置顶点效果。 首先在 层级管理器 中新建一个 Canvas 节点，然后在 Canvas 节点下新建一个空节点并命名为 Spine。选中 Spine 节点，并在 属性检查器 中添加 Skeleton 组件，将资源拖拽到 Skeleton 组件的 SkeletonData 属性框中，设置好 Skeleton 组件属性。 在 资源管理器 中新建一个 TypeScript 脚本并命名为 SpineExample，编写组件脚本。脚本代码如下： import { _decorator, Component, sp } from 'cc'; const { ccclass, property } = _decorator; @ccclass('SpineExample') export class SpineExample extends Component { @property({ type:sp.Skeleton }) skeleton: sp.Skeleton | null = null; private _jitterEffect?:sp.VertexEffectDelegate; start () { this._jitterEffect = new sp.VertexEffectDelegate(); // 设置好抖动参数。 this._jitterEffect.initJitter(20, 20); // 调用 Skeleton 组件的 setVertexEffectDelegate 方法设置效果。 this.skeleton!.setVertexEffectDelegate(this._jitterEffect!); } }; 然后将 SpineExample 脚本挂载到 Canvas 节点上，即将脚本拖拽到节点的 属性检查器 中。再将 层级管理器 中挂载了 Skeleton 组件的 Spine 节点拖拽到脚本组件对应的 Skeleton 属性框中，并保存场景。 点击编辑器上方的预览按钮，即可看到 Spine 动画顶点抖动的效果。详情可参考 SpineMesh（GitHub | Gitee）范例。 Spine 挂点 在使用骨骼动画时，经常需要在骨骼动画的某个部位上挂载节点，以实现节点与骨骼动画联动的效果。我们可以通过使用编辑器和脚本两种方式来实现 Spine 挂点。下面通过一个范例来介绍 Spine 如何使用挂点将星星挂在龙的尾巴上，并随一起晃动。 通过编辑器实现 Spine 挂点 首先在 层级管理器 中新建一个 Canvas 节点，然后在 Canvas 节点下新建一个空节点并命名为 Spine。选中 Spine 节点，并在 属性检查器 中添加 Skeleton 组件，将资源拖拽到 Skeleton 组件的 SkeletonData 属性框中，设置好 Skeleton 组件属性。 在 层级管理器 中右键点击 Spine 节点，选择 创建 -> 2D 对象 -> Sprite 为其添加一个子节点并命名为 star。然后将星星资源拖拽到 属性检查器 中 Sprite 组件的 SpriteFrame 属性上。 在 层级管理器 中选中 Spine 节点，在 属性检查器 中将 Skeleton 组件的 Sockets 属性设置为 1（Sockets 属性的值代表了挂点的数量）。 然后设置 Sockets 中的 Path 和 Target 属性，Path 的下拉框中会列出所有的骨骼，选择想要挂载的目标骨骼，这里以龙的尾巴为例，然后将 star 节点拖拽到 Target 属性框中。即可在 场景编辑器 中看到星星挂在了龙的尾巴上。 保存场景，点击编辑器上方的预览按钮，也可以看到星星挂在龙的尾巴上，并随着龙的尾巴一起晃动。具体可参考官方 SpineAttach（GitHub | Gitee）范例。 通过脚本实现 Spine 挂点 前两个步骤与通过编辑器实现的一致。 在 资源管理器 中新建一个 TypeScript 脚本并命名为 SpineAttach，编写组件脚本。脚本代码如下： import { _decorator, Component, sp, Label, Node } from 'cc'; const { ccclass, property } = _decorator; @ccclass('SpineAttach') export class SpineAttach extends Component { @property({ type: sp.Skeleton }) skeleton: sp.Skeleton = null!; @property({ type: Node }) attachNode: Node = null!; start () { var socket = new sp.SpineSocket(\"root/hip/tail1/tail2/tail3/tail4/tail5/tail6/tail7/tail8/tail9/tail10\", this.attachNode); // 第一个参数传入的是挂点的目标骨骼。第二个参数传入的是挂点的节点 this.skeleton!.sockets.push(socket); this.skeleton!.sockets = this.skeleton!.sockets; } } 注意：若不知道目标骨骼的名称，可将 Spine 组件中的 Sockets 属性设置为 1，然后在 Path 的下拉框中查找所需的目标骨骼名称。查找完成后再将 Sockets 属性还原为 0 即可。 然后将 SpineAttach 脚本挂载到 Canvas 节点或者其他节点上，即将脚本拖拽到节点的 属性检查器 中。再将 层级管理器 中挂载了 Skeleton 组件的 Spine 节点和 star 节点分别拖拽到脚本组件对应的 Skeleton 属性框和 AttachNode 属性框中，并保存场景。 点击编辑器上方的预览按钮，即可看到星星挂在龙的尾巴上，并随着龙的尾巴一起晃动。 Spine 碰撞检测 通过 Spine 挂点功能可以对骨骼动画的某个部位做碰撞检测。下面通过一个范例来介绍 Spine 如何实现碰撞检测，通过判断人物脚与地面接触与否来实现当人物跑动时，动态地改变地面颜色。 首先需要在编辑器菜单栏的 项目 -> 项目设置 -> 功能裁剪 中将 2D 物理系统 设置为 内置 2D 物理系统。 与 Spine 挂点的前两个步骤一样，创建好 Spine 节点和其空子节点（命名为 frontFoot），以及 Sprite 节点作为地面（命名为 Ground），并设置好位置大小等属性。 在 层级管理器 中选中 frontFoot 节点，在 属性检查器 中点击 添加组件 -> Physics2D -> Colliders -> Polygon Collider2D 添加碰撞组件，然后设置好碰撞组件参数。 参考通过编辑器实现 Spine 挂点的第 3、4 个步骤，将 frontFoot 节点挂载到 Sprite 节点的目标骨骼上（例如脚上），frontFoot 节点便会随着骨骼动画一起运动，从而碰撞组件的包围盒也会实时地与骨骼动画保持同步。 在 层级管理器 中选中 Ground 节点，在 属性检查器 中点击 添加组件 -> Physics2D -> Colliders -> BoxCollider2D 添加碰撞组件，然后设置好碰撞组件参数。 在 资源管理器 中新建一个 TypeScript 脚本并命名为 SpineCollider，然后将脚本挂载到地面节点 Ground 上。脚本代码如下： import { _decorator, Component, Node, PhysicsSystem2D, Contact2DType, Collider2D, Color, Sprite, ParticleSystem2D, EPhysics2DDrawFlags } from 'cc'; const { ccclass } = _decorator; @ccclass('SpineCollider') export class SpineCollider extends Component { touchingCountMap : Map = new Map; private debugDrawFlags : number = 0; start () { // Your initialization goes here. PhysicsSystem2D.instance.on(Contact2DType.BEGIN_CONTACT, this.onBeginContact, this); PhysicsSystem2D.instance.on(Contact2DType.END_CONTACT, this.onEndContact, this); this.debugDrawFlags = PhysicsSystem2D.instance.debugDrawFlags; } onEnable () { PhysicsSystem2D.instance.debugDrawFlags = this.debugDrawFlags | EPhysics2DDrawFlags.Shape; } onDisable () { PhysicsSystem2D.instance.debugDrawFlags = this.debugDrawFlags; } addContact (c: Collider2D) { let count = this.touchingCountMap.get(c.node) || 0; this.touchingCountMap.set(c.node, ++count); let sprite = c.getComponent(Sprite); if (sprite) { sprite.color = Color.RED; } } removeContact (c: Collider2D) { let count = this.touchingCountMap.get(c.node) || 0; --count; if (count 点击编辑器上方的预览按钮，即可看到效果。具体可参考 SpineCollider（GitHub | Gitee）范例。 注意：由于挂点的实现机制，会导致基于挂点的碰撞检测存在延迟一帧的问题。 "},"editor/components/dragonbones.html":{"url":"editor/components/dragonbones.html","title":"DragonBones ArmatureDisplay 组件参考","keywords":"","body":"DragonBones ArmatureDisplay 组件参考 ArmatureDisplay 组件可以对 DragonBones（龙骨）资源进行渲染和播放。 在 层级管理器 中选中需要添加 ArmatureDisplay 组件的节点，然后点击 属性检查器 下方的 添加组件 -> DragonBones -> ArmatureDisplay 按钮，即可添加 ArmatureDisplay 组件到节点上。 ArmatureDisplay 组件的使用方法可参考 DragonBones（GitHub | Gitee）范例。 DragonBones 相关的脚本接口请参考 DragonBones API。 DragonBones 属性 属性 功能说明 CustomMaterial 自定义材质，可用于实现溶解、外发光等渲染效果。详情请参考 自定义材质。 Color 设置骨骼动画颜色 DragonAsset 骨骼信息数据，包含了骨骼信息（绑定骨骼动作、slots、渲染顺序、attachments、皮肤等）和动画，但不持有任何状态。多个 ArmatureDisplay 可以共用相同的骨骼数据。可拖拽 DragonBones 导出的骨骼资源到这里 DragonAtlasAsset 骨骼数据所需的 Atlas Texture 数据。可拖拽 DragonBones 导出的 Atlas 资源到这里 Armature 当前使用的 Armature 名称 Animation 当前播放的骨骼动画名称 Animation Cache Mode 渲染模式，包括 REALTIME（默认）、SHARED_CACHE 和 PRIVATE_CACHE 三种。1. REALTIME 模式，实时运算，支持 DragonBones 所有的功能。2. SHARED_CACHE 模式，将骨骼动画及贴图数据进行缓存并共享，相当于预烘焙骨骼动画。拥有较高性能，但不支持动作融合、动作叠加、骨骼嵌套，只支持动作开始和结束事件。至于内存方面，当创建 N（N>=3）个相同骨骼、相同动作的动画时，会呈现内存优势。N 值越大，优势越明显。综上 SHARED_CACHE 模式适用于场景动画、特效、副本怪物、NPC 等，能极大地提高帧率和降低内存。3. PRIVATE_CACHE 模式，与 SHARED_CACHE 类似，但不共享动画及贴图数据，所以在内存方面没有优势，仅存在性能优势。若想利用缓存模式的高性能，但又存在换装的需求（不能共享贴图数据）时，那么 PRIVATE_CACHE 就适合你。 TimeScale 当前骨骼中所有动画的时间缩放率，默认为 1，表示不缩放。 PlayTimes 播放默认动画的循环次数。-1 表示使用 DragonBones 资源文件中的默认值0 表示无限循环>0 表示循环次数 PremultipliedAlpha 图片是否启用贴图预乘，默认为 True。当图片的透明区域出现色块时需要关闭该项。当图片的半透明区域颜色变黑时需要启用该项 DebugBones 是否显示 bone 的 debug 信息 Sockets 用于将某些外部节点挂到指定的骨骼关节上，属性的值表示挂点的数量。详情请参考下文介绍。 注意： 当使用 ArmatureDisplay 组件时，属性检查器 中 Node 组件上的 Anchor 与 Size 属性是无效的。 ArmatureDisplay 组件属于 UI 渲染组件，而 Canvas 节点是 UI 渲染的 渲染根节点，所以带有该组件的节点必须是 Canvas 节点（或者是带有 RenderRoot2D 组件的节点）的子节点才能在场景中正常显示。 DragonBones 换装 下面通过一个范例介绍 DragonBones 如何换装。通过替换插槽的显示对象，将下图机器人的武器替换为红色框中的武器。 首先在 层级管理器 中新建一个 Canvas 节点，然后在 Canvas 节点下新建一个空节点并命名为 replaceDBNode。选中 replaceDBNode 并在 属性检查器 中添加 ArmatureDisplay 组件，将绿色框中的武器资源拖拽至 ArmatureDisplay 组件的属性框中，如下图所示： 再次新建一个空节点并命名为 dbNode，然后在 属性检查器 中添加 ArmatureDisplay 组件，并将机器人的资源拖拽至 ArmatureDisplay 组件的属性框中，如下图所示。可更改 ArmatureDisplay 组件的 Animation 属性用于设置想要播放的动画。 在 资源管理器 中新建一个 TypeScript 脚本并命名为 ReplaceSlotDisplay，编写组件脚本。脚本代码如下： import { _decorator, Component, dragonBones } from 'cc'; const { ccclass, property } = _decorator; @ccclass('ReplaceSlotDisplay') export class ReplaceSlotDisplay extends Component { @property({ type: dragonBones.ArmatureDisplay }) armatureDisplay: dragonBones.ArmatureDisplay | null = null @property({ type: dragonBones.ArmatureDisplay }) replaceArmatureDisplay: dragonBones.ArmatureDisplay | null = null; _leftWeaponIndex = 0; _rightDisplayIndex = 0; _rightDisplayNames:string[] = []; _rightDisplayOffset:{x: number, y: number}[] = []; start () { this.replaceArmatureDisplay!.node.active = false; this._leftWeaponIndex = 0; this._rightDisplayIndex = 0; this._rightDisplayNames = [\"weapon_1004s_r\", \"weapon_1004e_r\"]; this._rightDisplayOffset = [{ x: 0, y: 0 }, { x: -60, y: 100 }]; } left () { let armature = this.armatureDisplay!.armature(); let slot = armature!.getSlot(\"weapon_hand_l\"); slot!.displayIndex = slot!.displayIndex == 0 ? 4 : 0; } right () { this._rightDisplayIndex++; this._rightDisplayIndex %= this._rightDisplayNames.length; let armature = this.armatureDisplay!.armature(); let slot = armature!.getSlot(\"weapon_hand_r\"); let replaceArmatureName = this.replaceArmatureDisplay!.armatureName; const displayName = this._rightDisplayNames[this._rightDisplayIndex]; let factory = dragonBones.CCFactory.getInstance() as any; factory.replaceSlotDisplay(this.replaceArmatureDisplay!.getArmatureKey(), replaceArmatureName , \"weapon_r\", displayName, slot); let offset = this._rightDisplayOffset[this._rightDisplayIndex]; slot!.parent.offset.x = offset.x; slot!.parent.offset.y = offset.y; armature!.invalidUpdate(); } } 然后将 ReplaceSlotDisplay 脚本挂载到 Canvas 节点上，即将脚本拖拽到 Canvas 节点的 属性检查器 中。再将 层级管理器 中的 dbNode 节点和 replaceDBNode 节点分别拖拽到脚本组件对应的属性框中，并保存场景。 接下来我们需要利用 Button 组件的点击事件来触发 ReplaceSlotDisplay 脚本中的 left 和 right 回调，实现通过点击按钮来替换机器人左/右手的武器。 在 层级管理器 的 Canvas 节点下新建两个 Button 节点并命名为 left 和 right，根据需要调整其位置、大小、文字显示等属性。 然后在 属性检查器 中设置 left 和 right 节点的点击事件，将挂载了 ReplaceSlotDisplay 脚本组件的 Canvas 节点分别拖拽到两个节点的 ClickEvents 属性的 cc.Node 属性框中，指定脚本组件为 ReplaceSlotDisplay，并设置回调为 left/right（下图以 right 节点为例）： 保存场景后，点击编辑器上方的预览按钮，然后点击 Left/Right 按钮即可看到机器人左/右手的武器已经被替换。 详情可参考官方范例 ReplaceSlotDisplay（GitHub | Gitee）。 注意： 范例运行起来后右手替换的武器样式与场景中预备的武器样式不一致，这是资源问题导致的，开发者请参考具体的代码实现。 若预览时未显示场景，请检查各节点的 Layer 属性是否与 Camera 节点的保持一致。 DragonBones 挂点与碰撞检测 DragonBones 挂点和碰撞检测的方法与 Spine 完全相同，详情请参考 Spine 挂点与碰撞检测。 "},"editor/components/tiledmap.html":{"url":"editor/components/tiledmap.html","title":"TiledMap 组件参考","keywords":"","body":"TiledMap 组件参考 TiledMap（地图）用于在游戏中显示 TMX 格式的地图。 点击 属性检查器 下方的 添加组件 -> Components -> TiledMap 按钮，即可添加 TiledMap 组件到节点上。 TiledMap 的脚本接口请参考 TiledMap API。 TiledMap 属性 属性 功能说明 Tmx Asset 指定 .tmx 格式的地图资源（请将 .tmx 和 .tsx 放置于同一文件夹） EnableCulling 启用裁剪，如果需要旋转地图或者把地图置于 3D 相机中，则需要关闭裁剪。如果地图块不是非常多，例如小于 5000 块，那么关闭裁剪能减少 CPU 的运算负担，GPU 直接使用缓存进行渲染 详细说明 添加 TiledMap 组件之后，从 资源管理器 中拖拽一个 .tmx 格式的地图资源到 Tmx Asset 属性上就可以在场景中看到地图的显示了。 在 TiledMap 组件中添加了 Tmx Asset 属性后，会在节点中自动添加与地图中的 Layer 对应的节点（如下图中的 floor、barrier 和 players 节点）。这些节点都添加了 TiledLayer 组件。请勿删除这些 Layer 节点中的 TiledLayer 组件。 TiledMap 组件不支持 mapLoaded 回调，在 start 函数中可正常使用 TiledMap 组件。 TiledLayer 与节点遮挡 TiledLayer 组件会将添加到地图层的节点坐标转化为地图块行列坐标。当按行列顺序渲染地图层中的地图块时，如果该地图块的行列中存在节点，那么将会中断渲染地图块转而渲染节点。当地图块中的节点渲染完毕后，会继续渲染地图块。以此实现节点与地图层相互遮挡关系。 注意：该遮挡关系只与节点的坐标有关，与节点的大小无关。 下面通过一个范例来介绍 TiledLayer 如何与节点相互遮挡。 在场景中新建一个节点并添加 TiledMap 组件，设置好 TiledMap 组件属性后会自动生成带有 TiledLayer 组件的节点（即地图层）。 创建 预制资源 以便在场景中实例化出多个节点。 在 资源管理器 中新建一个 TypeScript 脚本，编写组件脚本。脚本代码如下： import { _decorator, Component, Node, TiledLayer, loader, Prefab, v2, instantiate, Vec3, SystemEventType, EventTouch } from 'cc'; const { ccclass, property } = _decorator; @ccclass('ShieldNode') export class ShieldNode extends Component { @property({ type: TiledLayer }) public tiledLayer: TiledLayer | null = null; @property({ type: Prefab }) public nodePrefab: Prefab | null = null; start () { this.initScene(this.nodePrefab!); } initScene (prefab: Prefab) { const posArr = [v2(-249, 96), v2(-150, 76), v2(-60, 54), v2(-248, -144), v2(-89, -34)]; const tmpP = new Vec3(); for (let i = 0; i { const deltaMove = event.getDelta(); shieldNode.getPosition(tmpP); tmpP.x += deltaMove.x; tmpP.y += deltaMove.y; shieldNode.setPosition(tmpP); }); } } } 将脚本组件挂载到 Canvas 节点上，即将脚本拖拽到 Canvas 节点的 属性检查器 中。再将 层级管理器 中自动生成的带有 TiledLayer 组件的节点以及 资源管理器 中的预制资源拖拽至脚本组件对应的属性框中，然后保存场景。 点击编辑器上方的预览按钮，即可看到节点与地图层相互遮挡的效果。关于代码可参考 ShieldNode（GitHub | Gitee）范例。 若想移除地图层中的节点，调用 TiledLayer 的 removeUserNode 方法即可。 "},"editor/components/tiledtile.html":{"url":"editor/components/tiledtile.html","title":"TiledTile 组件参考","keywords":"","body":"TiledTile 组件参考 TiledTile 组件可以单独对某一个地图块进行操作。 创建方式 通过编辑器创建 在创建 TiledMap 组件 过程中 自动生成 的 Layer 节点下创建一个空节点。然后选中该空节点，点击 属性检查器 下方的 添加组件 -> TiledMap -> TiledTile，即可添加 TiledTile 组件到节点上。再通过设置 TiledTile 组件上的属性来操作地图块。 相关 TiledTile 脚本接口请参考 TiledTile API 通过代码创建 在代码中设置地图块有两种方式。当你在某个 Layer 节点中设置了 TiledTile 之后，该 Layer 节点原先所在位置的 TiledTile 将会被取代。 通过对一个节点添加 TiledTile 组件创建 // 创建一个新节点 const node = new Node(); // 然后把该节点的父节点设置为任意的 layer 节点 node.parent = this.layer.node; // 最后添加 TiledTile 组件到该节点上，并返回 TiledTile 对象，就可以对 TiledTile 对象进行一系列操作 const tiledTile = node.addComponent(TiledTile); 通过 getTiledTileAt 获取 TiledTile // 获取 layer 上横向坐标为 0，纵向坐标为 0 的 TiledTile 对象，就可以对 TiledTile 对象进行一系列操作 const tiledTile = this.layer.getTiledTileAt(0, 0); Layer 脚本接口相关请参考 TiledLayer API TiledTile 属性 属性 功能说明 X 指定 TiledTile 的横向坐标，以地图块为单位 Y 指定 TiledTile 的纵向坐标，以地图块为单位 Gid 指定 TiledTile 的 gid 值，来切换 TiledTile 的样式 TiledTile 可以控制指定的地图块，以及将节点的位移、旋转和缩放等应用到地图块。用户可以通过更改 TiledTile 的 gid 属性来更换地图块样式。 注意: 只能使用地图中现有地图块的 gid 来切换地图块的样式，无法通过自定义 Sprite Frame 来切换地图块的样式。 可作用到 TiledTile 上的节点属性 属性 功能说明 Position 可对指定的 TiledTile 进行 平移 操作 Rotation 可对指定的 TiledTile 进行 旋转 操作 Scale 可对指定的 TiledTile 进行 缩放 操作 Color 可对指定的 TiledTile 进行更改 颜色 操作 Opacity 可对指定的 TiledTile 调整 不透明度 Skew 可对指定的 TiledTile 调整 倾斜角度 "},"editor/components/motion-streak.html":{"url":"editor/components/motion-streak.html","title":"MotionStreak","keywords":"","body":"MotionStreak（拖尾）组件参考 MotionStreak（拖尾）是运动轨迹，用于在游戏对象的运动轨迹上实现拖尾渐隐效果。 点击 属性检查器 下方的 添加组件 按钮，然后从 Effects 中选择 MotionStreak，即可添加 MotionStreak 组件到节点上。 具体的使用方式可以参考 MotionStreak (GitHub | Gitee) 范例。 拖尾的脚本接口请参考 MotionStreak API。 MotionStreak 属性 属性 功能说明 CustomMaterial 自定义材质，使用方法请参考 自定义材质。 SrcBlendFactor 源混合因子值，详情可参考 API srcBlendFactor。 DstBlendFactor 目标混合因子值，详情可参考 API dstBlendFactor。 Color 拖尾的颜色。 Preview 是否启用预览。若勾选该项，则可在 场景编辑器 中预览拖尾效果 FadeTime 拖尾的渐隐时间，以秒为单位。 MinSeg 最小的片段长度（渐隐片段的大小）。拖尾条带相连顶点间的最小距离。 Stroke 拖尾的宽度。 Texture 拖尾的贴图。 FastMode 是否启用快速模式。当启用快速模式，新的顶点会被更快地添加，但精度较低。 "},"2d-object/ui-system/":{"url":"2d-object/ui-system/","title":"UI 系统","keywords":"","body":"UI 系统 本章将介绍 Cocos Creator 中强大而灵活的 UI（用户界面）系统，通过组合不同 UI 组件来生产能够适配多种分辨率屏幕的、通过数据动态生成和更新显示内容，以及支持多种排版布局方式的 UI 界面。 UI 入门 在引擎中界定 UI 和 2D 渲染对象的区别主要在于适配和交互，所有的 UI 需要在 Canvas 节点下，以做出适配行为，而 Canvas 组件本身继承自 RenderRoot2D 组件，所以也可以作为数据收集的入口。 UI 是游戏开发的必要交互部分，一般游戏上的按钮、文字、背景等都是通过 UI 来制作的。在开始制作一款 UI 时，首先需要确定当前设计的内容显示区域大小（设计分辨率），可以在菜单栏的 项目 -> 项目设置 -> 项目数据 面板中设置： 设计分辨率设置完成后，开始创建 UI 元素，所有的 UI 元素都包含在 Canvas 节点下。可以在 层级管理器 面板中点击左上方的 + 按钮，然后选择 UI Component -> Canvas 来创建 Canvas 节点。Canvas 节点上有一个 Canvas 组件，该组件可以关联一个 camera。 注意： 在一个场景中可以存在多个 Canvas 节点，但是 Canvas 节点不应该嵌套在另一个 Canvas 节点或其子节点下。 Canvas 组件并非和 camera 是一一对应关系，它们之前的渲染与否完全取决于 node 的 layer 和 camera 的 Visibility，在多 Canvas 的时候要格外注意 layer 管理以得到想要的渲染效果。 接下来就可以在 Canvas 节点下创建 UI 节点了。编辑器自带的 UI 节点有以下几种： 可以通过选中节点，在 属性检查器 面板中点击 添加组件 来查看 UI 组件。 UI 渲染组件的先后顺序采用的是深度排序方案，也就是 Canvas 节点下的子节点的排序就已经决定了之后的整个 渲染排序。 在一般的游戏开发中，必要的 UI 元素除了 Sprite（精灵图）、Label（文字）、Mask（遮罩）等基础 2D 渲染组件外，还有用于快速搭建界面的 Layout（布局）、Widget（对齐）等。其中 Sprite 和 Label 用于渲染图片和文字。Mask 主要用于限制显示内容，比较常用的地方是一些聊天框和背包等。Layout 主要用于排版，一般用于按钮单一排列，背包内道具整齐排列等。 最后一个比较重要的功能其实是 Widget，主要用于显示对齐。这里可能涉及到另外一个功能，那就是多分辨率适配，在我们设计完 UI 需要发布到不同平台时，势必会出现平台的实际设备分辨率和我们的设计分辨率不符的情况，这个时候为了适配不得不做一些取舍，比如头像框，是不能做缩放的，但是我们又希望它没有很大程度受设备影响，那么我们则需要为它添加上 Widget 组件，并且始终保证它对齐在我们的设计分辨率的左上方，具体参考：对齐策略 和 对齐。 当我们的界面制作完成之后，可能有人会发现，怎么发布 iPhone 7 和 iPhone X 的显示效果不一样？这个其实也是我们上面提到的设备分辨率的问题。在你以设计分辨率设计，最终以设备分辨率发布的时候，因为不同型号的手机设备分辨率可能不一致，这中间存在像素偏差的问题，因此，还需要做的一道转换工序那就是屏幕适配。 在菜单栏的 项目 -> 项目设置 -> 项目数据 页面中可以看到，还有两个选项是 适配屏幕宽度 / 适配屏幕高度，按照屏幕适配规则再结合 Widget 组件，就可以实现不同设备的轻松适配。具体适配规则可参考 多分辨率适配方案。 UI 组件 UI 组件大部分自身不具有渲染能力，但持有了 2D 渲染组件用于渲染，其本身更多拥有着快速构成用户交互界面的能力，承担着事件响应，排版适配等功能。各 UI 组件具体说明请参考 UI 组件。 UI 实践指南 多分辨率适配方案 对齐策略 文字排版 自动布局容器 制作动态生成内容的列表 制作可任意拉伸的 UI 图像 "},"ui-system/components/editor/base-component.html":{"url":"ui-system/components/editor/base-component.html","title":"UI 组件","keywords":"","body":"UI 组件 一些常用的 UI 控件可通过添加节点的方式来创建。在 层级管理器 中点击左上角的 + 创建节点按钮，然后选择 UI 来创建所需的 UI 节点，相应的 UI 组件便会自动挂载到节点上： 其它的 UI 组件，可以手动在 层级管理器 中选中节点，然后在 属性检查器 中点击 添加组件 -> UI 的方式来添加： 各组件的具体说明，请参考相应的组件说明文档。 "},"ui-system/components/editor/canvas.html":{"url":"ui-system/components/editor/canvas.html","title":"Canvas 组件参考","keywords":"","body":"Canvas（画布）组件参考 RenderRoot2D 组件所在的节点是 2D 渲染组件数据收集的入口，而 Canvas（画布） 组件继承自 RenderRoot2D 组件，所以 Canvas 组件也是数据收集入口。场景中 Canvas 节点可以有多个，所有 2D 渲染元素都必须作为 RenderRoot2D 的子节点才能被渲染。 Canvas 节点除了继承自 RenderRoot2D 的数据入口能力，其本身还作为屏幕适配的重要组件，在游戏制作上面对多分辨率适配也起到关键作用，具体请参考 多分辨率适配方案。Canvas 的设计分辨率和适配方案统一通过 项目设置 配置。 Canvas 本身和相机并无关系，其更主要的作用是上文叙述的屏幕适配，所以 Canvas 的渲染只取决于和其节点 layer 对应的 camera。所以可以通过控制 camera 的属性来决定 Canvas 下节点的渲染效果。 Canvas 属性 属性 功能说明 CameraComponent Canvas 关联的相机，此相机不一定会渲染 Canvas 下内容，可以与 AlignCanvasWithScreen 属性配合自动改变 Camera 的一些参数使其与 Canvas 对齐 AlignCanvasWithScreen Canvas 关联的相机是否要与 Canvas 对齐，如果想要自己控制相机位置请勿勾选此选项（卷轴游戏等） 注意事项 如果遇到 UI 渲染出错、花屏、闪屏等现象，请参考 注意事项。 "},"ui-system/components/editor/ui-transform.html":{"url":"ui-system/components/editor/ui-transform.html","title":"UITransform 组件参考","keywords":"","body":"UI 变换组件 定义了 UI 上的矩形信息，包括矩形的尺寸和锚点位置。开发者可以通过该组件任意地操作矩形的大小、位置。一般用于渲染、点击事件的计算、界面布局以及屏幕适配等。 点击 属性检查器 下面的 添加组件 按钮，然后选择 UI/UITransform 即可添加 UITransform 组件到节点上。 UITransform 脚本接口请参考 Mask API。 UITransform 属性介绍 属性 功能说明 ContentSize UI 矩形内容尺寸 AnchorPoint UI 矩形锚点位置 Priority UI 节点优先级，在当前父节点下排序，Canvas 节点顺序不受此属性影响。 通过脚本代码修改节点尺寸和锚点 import { _decorator, Component, Node, UITransform } from 'cc'; const { ccclass, property } = _decorator; @ccclass('Example') export class Example extends Component { start () { const uiTransform = this.getComponent(UITransform); // 方法一 uiTransform.setContentSize(200, 120); uiTransform.setAnchorPoint(0, 0.5); // 方法二 uiTransform.width = 200; uiTransform.height = 120; uiTransform.anchorX = 0; uiTransform.anchorY = 0.5; } } "},"ui-system/components/editor/widget.html":{"url":"ui-system/components/editor/widget.html","title":"Widget 组件参考","keywords":"","body":"Widget 组件参考 Widget (对齐挂件) 是一个很常用的 UI 布局组件。它能使当前节点自动对齐到父物体的任意位置，或者约束尺寸，让你的游戏可以方便地适配不同的分辨率。对齐方案详细说明请参考 对齐方案 点击 属性检查器 下面的 添加组件 按钮，然后选择 UI/Widget 即可添加 Widget 组件到节点上。 对齐挂件的脚本接口请参考 Widget API。 关于使用可以参考范例 Widget（GitHub | Gitee）。 选项 选项 说明 备注 Top 对齐上边界 选中后，将在旁边显示一个输入框，用于设定当前节点的上边界和父物体的上边界之间的距离。 Bottom 对齐下边界 选中后，将在旁边显示一个输入框，用于设定当前节点的下边界和父物体的下边界之间的距离。 Left 对齐左边界 选中后，将在旁边显示一个输入框，用于设定当前节点的左边界和父物体的左边界之间的距离。 Right 对齐右边界 选中后，将在旁边显示一个输入框，用于设定当前节点的右边界和父物体的右边界之间的距离。 HorizontalCenter 水平方向居中 VerticalCenter 竖直方向居中 Target 对齐目标 指定对齐参照的节点，当这里未指定目标时会使用直接父级节点作为对齐目标 AlignMode 指定 Widget 的对齐方式，用于决定运行时 Widget 应何时更新 通常设置为 ALWAYS，每次节点产生变动时重新对齐。设置为 ONCE 时，仅在组件初始化时进行一次对齐。ON_WINDOW_RESIZE 时会在每次窗口变动时候更新一次 对齐边界 我们可以在 Canvas 下新建一个 sprite，在 sprite 节点上添加一个 Widget 组件，然后做如下一些测试： 左对齐，左边界距离 100 px 下对齐，下边界距离 50% 百分比将以父节点的宽或高作为基准。 右下对齐，边界距离 0 px 居中对齐 水平方向居中 竖直方向居中，并且右边界距离 50% 约束尺寸 如果左右同时对齐，或者上下同时对齐，那么在相应方向上的尺寸就会被拉伸。 下面演示一下，在场景中放置两个矩形 Sprite，大的作为对话框背景，小的作为对话框上的按钮。按钮节点作为对话框的子节点，并且按钮设置成 Sliced 模式以便展示拉伸效果。 宽度拉伸，左右边距 10% 高度拉伸，上下边距 0，同时水平居中 水平和竖直同时拉伸，边距 50 px 对节点位置、尺寸的限制 如果 Align Mode 属性设为 ALWAYS 时，会在运行时每帧都按照设置的对齐策略进行对齐，组件所在节点的位置（position）和尺寸（width，height）属性可能会被限制，不能通过 API 或动画系统自由修改。这是因为通过 Widget 对齐是在每帧的最后阶段进行处理的，因此对 Widget 组件中已经设置了对齐的相关属性进行设置，最后都会被 Widget 组件本身的更新所重置。 如果需要同时满足对齐策略和可以在运行时改变位置和尺寸的需要，可以通过以下两种方式实现： 确保 Widget 组件的 Align Mode 属性设置为 ONCE，该属性只会负责在组件初始化（onEnable）时进行一次对齐，而不会每帧再进行一次对齐。可以在初始化时自动完成对齐，然后就可以通过 API 或动画系统对 UI 进行移动变换了。 通过调用 Widget 组件的对齐边距 API，包括 top、 bottom、 left、 right，直接修改 Widget 所在节点的位置或某一轴向的拉伸。这些属性也可以在动画编辑器中添加相应关键帧，保证对齐的同时实现各种丰富的 UI 动画。 通过脚本代码修改对齐距离 import { _decorator, Component, Widget } from 'cc'; const { ccclass, property } = _decorator; @ccclass('Example') export class Example extends Component { start () { const widget = this.getComponent(Widget); // 设置默认对齐单位是 px widget!.bottom = 50; widget!.top = 50; // 设置对齐单位是 % widget!.isAbsoluteTop = false; widget!.isAbsoluteBottom = false; widget!.bottom = 0.1; // 10% widget!.top = 0.1; // 10% } } "},"ui-system/components/editor/button.html":{"url":"ui-system/components/editor/button.html","title":"Button 组件参考","keywords":"","body":"Button（按钮）组件参考 Button 组件可以响应用户的点击操作，当用户点击 Button 时，Button 自身会有状态变化。另外，Button 还可以让用户在完成点击操作后响应一个自定义的行为。 点击 属性检查器 下面的 添加组件 按钮，然后从 添加 UI 组件 中选择 Button，即可添加 Button 组件到节点上。 按钮的脚本接口请参考 Button API。 Button 属性 属性 功能说明 Target Node 类型，当 Button 发生 Transition 的时候，会相应地修改 Target 节点的 SpriteFrame，颜色或者 Scale。 Interactable 布尔类型，设为 false 时，则 Button 组件进入禁用状态。 Transition 枚举类型，包括 NONE、COLOR、SPRITE 和 SCALE。每种类型对应不同的 Transition 设置。详情见下方的 Button Transition 部分。 Click Event 列表类型，默认为空，用户添加的每一个事件由节点引用，组件名称和一个响应函数组成。详情见下方的 Button 点击事件 部分。 Button Transition Button 的 Transition 用来指定当用户点击 Button 时的状态表现。目前主要有 NONE、COLOR、SPRITE 和 SCALE。 Color Transition 属性 功能说明 Normal Button 在 Normal 状态下的颜色。 Pressed Button 在 Pressed 状态下的颜色。 Hover Button 在 Hover 状态下的颜色。 Disabled Button 在 Disabled 状态下的颜色。 Duration Button 状态切换需要的时间间隔。 Sprite Transition 属性 功能说明 Normal Button 在 Normal 状态下的 SpriteFrame。 Pressed Button 在 Pressed 状态下的 SpriteFrame。 Hover Button 在 Hover 状态下的 SpriteFrame。 Disabled Button 在 Disabled 状态下的 SpriteFrame。 Scale Transition 属性 功能 Duration Button 状态切换需要的时间间隔。 ZoomScale 当用户点击按钮后，按钮会缩放到一个值，这个值等于 Button 原始 scale * zoomScale，zoomScale 可以为负数 Button 点击事件 Button 目前只支持 Click 事件，即当用户点击并释放 Button 时才会触发相应的回调函数。 组件事件结构 属性 功能说明 Target 带有脚本组件的节点。 Component 脚本组件名称。 Handler 指定一个回调函数，当用户点击 Button 并释放时会触发此函数。 CustomEventData 用户指定任意的字符串作为事件回调的最后一个参数传入。 通过脚本代码添加回调 方法一 这种方法添加的事件回调和使用编辑器添加的事件回调是一样的，都是通过代码添加。首先需要构造一个 EventHandler 对象，然后设置好对应的 target、component、handler 和 customEventData 参数。 import { _decorator, Component, Event, Node, Button, EventHandler } from 'cc'; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { onLoad () { const clickEventHandler = new EventHandler(); clickEventHandler.target = this.node; // 这个 node 节点是你的事件处理代码组件所属的节点 clickEventHandler.component = 'example';// 这个是脚本类名 clickEventHandler.handler = 'callback'; clickEventHandler.customEventData = 'foobar'; const button = this.node.getComponent(Button); button.clickEvents.push(clickEventHandler); } callback (event: Event, customEventData: string) { // 这里 event 是一个 Touch Event 对象，你可以通过 event.target 取到事件的发送节点 const node = event.target as Node; const button = node.getComponent(Button); console.log(customEventData); // foobar } } 方法二 通过 button.node.on('click', ...) 的方式来添加，这是一种非常简便的方式，但是该方式有一定的局限性，在事件回调里面无法 获得当前点击按钮的屏幕坐标点。 // 假设我们在一个组件的 onLoad 方法里面添加事件处理回调，在 callback 函数中进行事件处理 import { _decorator, Component, Button } from 'cc'; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { @property(Button) button: Button | null = null; onLoad () { this.button.node.on(Button.EventType.CLICK, this.callback, this); } callback (button: Button) { // 注意这种方式注册的事件，无法传递 customEventData } } "},"ui-system/components/editor/layout.html":{"url":"ui-system/components/editor/layout.html","title":"Layout 组件参考","keywords":"","body":"Layout 组件参考 Layout 是一种容器组件，容器能够开启自动布局功能，自动按照规范排列所有子物体，方便用户制作列表、翻页等功能。 点击 属性检查器 下面的 添加组件 按钮，然后选择 UI -> Layout 即可添加 Layout 组件到节点上。 布局的组件接口请参考 Layout API。 具体使用方法可参考范例 Layout（GitHub | Gitee）。 Layout 属性 属性 功能说明 Type 布局类型，支持 NONE、HORIZONTAL、VERTICAL 和 GRID。 ResizeMode 缩放模式，支持 NONE、CHILDREN 和 CONTAINER。 PaddingLeft 排版时，子物体相对于容器左边框的距离。 PaddingRight 排版时，子物体相对于容器右边框的距离。 PaddingTop 排版时，子物体相对于容器上边框的距离。 PaddingBottom 排版时，子物体相对于容器下边框的距离。 SpacingX 水平排版时，子物体与子物体在水平方向上的间距。NONE 模式无此属性。 SpacingY 垂直排版时，子物体与子物体在垂直方向上的间距。NONE 模式无此属性。 HorizontalDirection 指定水平排版时，第一个子节点从容器的左边还是右边开始布局。当容器为 GRID 类型时，此属性和 Start Axis 属性一起决定 Grid 布局元素的起始水平排列方向。 VerticalDirection 指定垂直排版时，第一个子节点从容器的上面还是下面开始布局。当容器为 GRID 类型时，此属性和 Start Axis 属性一起决定 Grid 布局元素的起始垂直排列方向。 CellSize 此属性只在 GRID 布局、Children 缩放模式时存在，指定网格容器里面排版元素的大小。 StartAxis 此属性只在 GRID 布局时存在，指定网格容器里面元素排版指定的起始方向轴。 AffectedByScale 子节点的缩放是否影响布局。 AutoAlignment 自动对齐，在 Type 类型为 HORIZONTAL 或 VERTICAL 模式下，保证另外一个轴向值始终为 0。 Constraint 布局约束，可以在某个方向上约束排列数量，支持 NONE、FIXED_ROW 和 FIXED_COL。 ConstraintNum 布局约束值，在 Constraint 的类型为 FIXED_ROW 或 FIXED_COL 模式下有效。 详细说明 添加 Layout 组件之后，默认的布局类型是 NONE，可以通过修改 属性检查器 里的 Type 切换容器排列类型。类型分为 HORIZONTAL（水平）、VERTICAL（垂直）以及 GRID（网格）布局。另外，除了 NONE 布局类型，其他都支持 ResizeMode。 ResizeMode 模式： 设置为 NONE 时，子物体和容器的大小变化互不影响。 设置为 CHILDREN 时，子物体大小会随着容器的大小而变化。 设置为 CONTAINER 时，容器的大小会随着子物体的大小变化。 所有的排列都是根据容器大小进行计算的，如果需要固定排序，可以将 Type 设置为 GRID，然后设置 Constraint 和 ConstraintNum 来固定排序。 Constraint 模式： 设置为 NONE 时，自由布局。 设置为 FIXED_ROW 时，固定行数，搭配 ConstraintNum 使用。 设置为 FIXED_COL 时，固定列数，搭配 ConstraintNum 使用。 注意：Layout 设置后的结果需要到下一帧才会更新，除非你设置完以后手动调用 updateLayout API。 更多布局案例，详情请参考 自动布局。 "},"ui-system/components/editor/editbox.html":{"url":"ui-system/components/editor/editbox.html","title":"EditBox 组件参考","keywords":"","body":"EditBox 组件参考 EditBox 是一种文本输入组件，该组件让你可以轻松获取用户输入的文本。 点击 属性检查器 下面的 添加组件 按钮，然后从 UI/EditBox 即可添加 EditBox 组件到节点上。 EditBox 的脚本接口请参考 EditBox API。 关于使用可以参考范例 EditBox（GitHub | Gitee）。 EditBox 属性 属性 功能说明 BackgroundImage 输入框背景节点上挂载的 Sprite 组件对象 FontColor 输入框文本的颜色 FontSize 输入框文本的字体大小 InputFlag 指定输入标识：可以指定输入方式为密码或者单词首字母大写（仅支持 Android 平台） InputMode 指定输入模式：ANY 表示多行输入，其它都是单行输入，移动平台上还可以指定键盘样式。 LineHeight 输入框文本的行高 MaxLength 输入框最大允许输入的字符个数 Placeholder 输入框占位符的文本内容 PlaceholderFontColor 输入框占位符的文本字体颜色 PlaceholderFontSize 输入框占位符的文本字体大小 PlaceholderLabel 输入框占位符节点上挂载的 Label 组件对象 ReturnType 指定移动设备上面回车按钮的样式 String 输入框的初始输入内容，如果为空则会显示占位符的文本 TabIndex 修改 DOM 输入元素的 tabIndex，这个属性只有在 Web 上面修改有意义。 TextLabel 输入框输入文本节点上挂载的 Label 组件对象 EditBox 事件 事件结构参考：组件事件结构 Editing Did Began：该事件在用户点击输入框获取焦点的时候被触发。 Editing Did Ended：在单行模式下面，一般是在用户按下回车或者点击屏幕输入框以外的地方调用该函数。如果是多行输入，一般是在用户点击屏幕输入框以外的地方调用该函数。 Text Changed：该事件在用户每一次输入文字变化的时候被触发。但若是通过 EditBox.string 的 setter 设置时不会派发该事件。 详细说明 如果需要输入密码，则需要把 Input Flag 设置为 password，同时 Input Mode 必须是 Any 之外的选择，一般选择 Single Line。 如果要输入多行，可以把 Input Mode 设置为 Any。 背景图片支持九宫格缩放 通过脚本代码添加回调 方法一 这种方法添加的事件回调和使用编辑器添加的事件回调是一样的，都是通过代码添加。首先需要构造一个 EventHandler 对象，然后设置好对应的 target、component、handler 和 customEventData 参数。 import { _decorator, Component, EditBox, EventHandler } from 'cc'; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { onLoad() { const editboxEventHandler = new EventHandler(); editboxEventHandler.target = this.node; // 这个 node 节点是你的事件处理代码组件所属的节点 editboxEventHandler.component = 'example'; editboxEventHandler.handler = 'onEditDidBegan'; editboxEventHandler.customEventData = 'foobar'; const editbox = this.node.getComponent(EditBox); editbox.editingDidBegan.push(editboxEventHandler); // 你也可以通过类似的方式来注册其它回调函数 // editbox.editingDidEnded.push(editboxEventHandler); // editbox.textChanged.push(editboxEventHandler); // editbox.editingReturn.push(editboxEventHandler); } onEditDidBegan(editbox, customEventData) { // 这里 editbox 是一个 EditBox 对象 // 这里的 customEventData 参数就等于你之前设置的 \"foobar\" } // 假设这个回调是给 editingDidEnded 事件的 onEditDidEnded(editbox, customEventData) { // 这里 editbox 是一个 EditBox 对象 // 这里的 customEventData 参数就等于你之前设置的 \"foobar\" } // 假设这个回调是给 textChanged 事件的 onTextChanged(text, editbox, customEventData) { // 这里的 text 表示修改完后的 EditBox 的文本内容 // 这里 editbox 是一个 EditBox 对象 // 这里的 customEventData 参数就等于你之前设置的 \"foobar\" } // 假设这个回调是给 editingReturn 事件的 onEditingReturn(editbox, customEventData) { // 这里 editbox 是一个 EditBox 对象 // 这里的 customEventData 参数就等于你之前设置的 \"foobar\" } } 方法二 通过 editbox.node.on('editing-did-began', ...) 的方式来添加 // 假设我们在一个组件的 onLoad 方法里面添加事件处理回调，在 callback 函数中进行事件处理: import { _decorator, Component, EditBox } from 'cc'; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { @property(EditBox) editbox: EditBox | null = null; onLoad(){ this.editbox.node.on('editing-did-began', this.callback, this); } callback(editbox: EditBox){ // 回调的参数是 editbox 组件，注意这种方式注册的事件，无法传递 customEventData } } 同样的，你也可以注册 editing-did-ended、text-changed 和 editing-return 事件，这些事件的回调函数的参数与 editing-did-began 的参数一致。 "},"ui-system/components/editor/scrollview.html":{"url":"ui-system/components/editor/scrollview.html","title":"ScrollView 组件参考","keywords":"","body":"ScrollView 组件参考 ScrollView 是一种带滚动功能的容器，它提供一种方式可以在有限的显示区域内浏览更多的内容。通常 ScrollView 会与 Mask 组件配合使用，同时也可以添加 ScrollBar 组件来显示浏览内容的位置。 点击 属性检查器 下面的 添加组件 按钮，然后选择 UI/ScrollView 即可添加 ScrollView 组件到节点上。 滚动视图的脚本接口请参考 ScrollView API。 关于使用可以参考范例 ScrollView（GitHub | Gitee）。 ScrollView 属性 属性 功能说明 content 它是一个节点引用，用来创建 ScrollView 的可滚动内容，通常这可能是一个包含一张巨大图片的节点。 Horizontal 布尔值，是否允许横向滚动。 Vertical 布尔值，是否允许纵向滚动。 Inertia 滚动的时候是否有加速度。 Brake 浮点数，滚动之后的减速系数。取值范围是 0-1，如果是 1 则立马停止滚动，如果是 0，则会一直滚动到 content 的边界。 Elastic 布尔值，是否回弹。 BounceDuration 浮点数，回弹所需要的时间。取值范围是 0-10。 HorizontalScrollBar 它是一个节点引用，用来创建一个滚动条来显示 content 在水平方向上的位置。 VerticalScrollBar 它是一个节点引用，用来创建一个滚动条来显示 content 在垂直方向上的位置 ScrollEvents 列表类型，默认为空，用户添加的每一个事件由节点引用，组件名称和一个响应函数组成。详情见下方的 ScrollView 事件 CancelInnerEvents 如果这个属性被设置为 true，那么滚动行为会取消子节点上注册的触摸事件，默认被设置为 true。 ScrollView 事件 事件结构参考：组件事件结构 ScrollView 的事件回调有两个参数，第一个参数是 ScrollView 本身，第二个参数是 ScrollView 的事件类型。 ScrollBar 设置 ScrollBar 是可选的，你可以选择只设置 Horizontal ScrollBar 或者 Vertical ScrollBar，当然也可以两者都设置。建立关联可以通过在 层级管理器 里面拖拽一个带有 ScrollBar 组件的节点到 ScrollView 的相应字段完成。 详细说明 ScrollView 组件必须有指定的 content 节点才能起作用，通过指定滚动方向和 content 节点在此方向上的长度来计算滚动时的位置信息，Content 节点也可以通过添加 Widget 设置自动 resize，也可以通过添加 Layout 来完成子节点布局，但是这两个组件不应该同时添加到一个节点上以避免产生不可预料的后果。 通常一个 ScrollView 的节点树如下图： 这里的 view 用来定义一个可以显示的滚动区域，所以通常 MaskComponent 组件会被添加到 view 上。可以滚动的内容可以直接放到 content 节点或者添加节 content 的子节点上。 通过脚本代码添加回调 方法一 这种方法添加的事件回调和使用编辑器添加的事件回调是一样的，都是通过代码添加。首先需要构造一个 EventHandler 对象，然后设置好对应的 target、component、handler 和 customEventData 参数。 import { _decorator, Component, ScrollView, EventHandler } from 'cc'; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { onLoad() { const scrollViewEventHandler = new EventHandler(); scrollViewEventHandler.target = this.node; // 这个 node 节点是你的事件处理代码组件所属的节点 scrollViewEventHandler.component = 'example';// 这个是脚本类名 scrollViewEventHandler.handler = 'callback'; scrollViewEventHandler.customEventData = 'foobar'; const scrollview = this.node.getComponent(ScrollView); scrollview.scrollEvents.push(scrollViewEventHandler); } callback(scrollview, eventType, customEventData){ // 这里 scrollview 是一个 Scrollview 组件对象实例 // 这里的 eventType === ScrollView.EventType enum 里面的值 // 这里的 customEventData 参数就等于你之前设置的 'foobar' } } 方法二 通过 scrollview.node.on('scroll-to-top', ...) 的方式来添加 // 假设我们在一个组件的 onLoad 方法里面添加事件处理回调，在 callback 函数中进行事件处理: import { _decorator, Component, ScrollView } from 'cc'; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { @property(ScrollView) scrollview: ScrollView | null = null; onLoad(){ this.scrollview.node.on('scroll-to-top', this.callback, this); } callback(scrollView: ScrollView) { // 回调的参数是 ScrollView 组件，注意这种方式注册的事件，无法传递 customEventData } } 同样的，你也可以注册 scrolling、touch-up、scroll-began 等事件，这些事件的回调函数的参数与 scroll-to-top 的参数一致。 关于完整的 ScrollView 的事件列表，可以参考 ScrollView 的 API 文档 ScrollView API。 "},"ui-system/components/editor/scrollbar.html":{"url":"ui-system/components/editor/scrollbar.html","title":"ScrollBar 组件参考","keywords":"","body":"ScrollBar 组件参考 ScrollBar 允许用户通过拖动滑块来滚动一张图片，它与 Slider 组件有点类似，但是它主要是用于滚动而 Slider 则用来设置数值。 点击 属性检查器 下面的 添加组件 按钮，然后选择 UI/ScrollBar 即可添加 ScrollBar 组件到节点上。 滚动条的脚本接口请参考 ScrollBar API。 ScrollBar 属性 属性 功能说明 Handle ScrollBar 前景图片，它的长度/宽度会根据 ScrollView 的 content 的大小和实际显示区域的大小来计算。 Direction 滚动方向，目前包含水平和垂直两个方向。 Enable Auto Hide 是否开启自动隐藏，如果开启了，那么在 ScrollBar 显示后的 Auto Hide Time 时间内会自动消失。 Auto Hide Time 自动隐藏时间，需要配合设置 Enable Auto Hide 详细说明 ScrollBar 一般不会单独使用，它需要与 ScrollView 配合使用，另外 ScrollBar 需要指定一个 Sprite 组件，即属性面板里面的 Handle。 通常我们还会给 ScrollBar 指定一张背景图片，用来指示整个 ScrollBar 的长度或者宽度。 "},"ui-system/components/editor/progress.html":{"url":"ui-system/components/editor/progress.html","title":"ProgressBar 组件参考","keywords":"","body":"ProgressBar 组件参考 ProgressBar（进度条）经常被用于在游戏中显示某个操作的进度，在节点上添加 ProgressBar 组件，然后给该组件关联一个 Bar Sprite 就可以在场景中控制 Bar Sprite 来显示进度了。 点击 属性检查器 下面的 添加组件 按钮，然后选择 UI/ProgressBar 即可添加 ProgressBar 组件到节点上。 进度条的脚本接口请参考ProgressBar API。 关于使用可以参考范例 Progress（GitHub | Gitee）。 ProgressBar 属性 属性 功能说明 Bar Sprite 进度条渲染所需要的 Sprite 组件，可以通过拖拽一个带有 Sprite 组件的节点到该属性上来建立关联。 Mode 支持 HORIZONTAL（水平）、VERTICAL（垂直）和 FILLED（填充）三种模式，可以通过配合 reverse 属性来改变起始方向。 Total Length 当进度条为 100% 时 Bar Sprite 的总长度/总宽度。在 FILLED 模式下 Total Length 表示取 Bar Sprite 总显示范围的百分比，取值范围从 0 ~ 1。 Progress 浮点，取值范围是 0~1，不允许输入之外的数值。 Reverse 布尔值，默认的填充方向是从左至右/从下到上，开启后变成从右到左/从上到下。 详细说明 添加 ProgressBar 组件之后，通过从 层级管理器 中拖拽一个带有 Sprite 组件的节点到 Bar Sprite 属性上，此时便可以通过拖动 progress 滑块来控制进度条的显示了。 Bar Sprite 可以是自身节点，子节点，或者任何一个带有 Sprite 组件的节点。另外，Bar Sprite 可以自由选择 Simple、Sliced 和 Filled 渲染模式。 进度条的模式选择 FILLED 的情况下，Bar Sprite 的 Type 也需要设置为 FILLED，否则会报警告。 "},"ui-system/components/editor/label-outline.html":{"url":"ui-system/components/editor/label-outline.html","title":"LabelOutline 组件参考","keywords":"","body":"LabelOutline 组件参考 LabelOutline 组件会为所在节点的 Label 添加描边效果，不支持 BMFont 字体。 点击 属性检查器 下方的 添加组件 按钮，然后从 UI 中选择 LabelOutline，即可添加 LabelOutline 组件到节点上。 LabelOutline 属性 属性 功能说明 Color 字体发光边缘颜色 Width 字体发光边缘宽度 "},"ui-system/components/editor/label-shadow.html":{"url":"ui-system/components/editor/label-shadow.html","title":"LabelShadow 组件参考","keywords":"","body":"LabelShadow 组件参考 LabelShadow 组件可以为 Label 组件添加阴影效果。 点击 属性检查器 下方的 添加组件 按钮，然后从 UI 中选择 LabelShadow，即可添加 LabelShadow 组件到节点上。 注意： LabelShadow 只能用于 系统字体 或者 TTF 字体。 当 Label 组件的 CacheMode 属性设置为 CHAR 时，LabelShadow 不生效。 LabelShadow 不支持原生平台 LabelShadow 相关脚本接口请参考 LabelShadow API。 LabelShadow 属性 属性 说明 Color 阴影的颜色 Offset 字体与阴影的偏移 Blur 阴影的模糊程度 "},"ui-system/components/editor/toggle.html":{"url":"ui-system/components/editor/toggle.html","title":"Toggle 组件参考","keywords":"","body":"Toggle 组件参考 Toggle 是一个 CheckBox，当它和 ToggleContainer 一起使用的时候，可以变成 RadioButton。 点击 属性检查器 下面的 添加组件 按钮，然后选择 UI/Toggle 即可添加 Toggle 组件到节点上。 Toggle 的组件接口请参考 Toggle API。 关于使用可以参考范例 Toggle（GitHub | Gitee）。 Toggle 属性 属性 功能说明 isChecked 布尔类型，如果这个设置为 true，则 check mark 组件会处于 enabled 状态，否则处于 disabled 状态。 checkMark Sprite 类型，Toggle 处于选中状态时显示的图片 Check Events 列表类型，默认为空，用户添加的每一个事件由节点引用，组件名称和一个响应函数组成。详情见下方的 Toggle 事件 部分 注意：因为 Toggle 继承自 Button，所以关于 Toggle 的 Button 相关属性的详细说明和用法请参考 Button 组件。 Toggle 事件 事件结构参考：组件事件结构。 Toggle 的事件回调有二个参数，第一个参数是 Toggle 本身，第二个参数是 customEventData。 详细说明 Toggle 组件的节点树一般为： 注意：checkMark 组件所在的节点需要放在 background 节点的上面。 通过脚本代码添加回调 方法一 这种方法添加的事件回调和使用编辑器添加的事件回调是一样的，都是通过代码添加。首先需要构造一个 EventHandler 对象，然后设置好对应的 target、component、handler 和 customEventData 参数。 import { _decorator, Component, Event, Node, ToggleComponent, EventHandler } from 'cc'; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { onLoad(){ const checkEventHandler = new EventHandler(); checkEventHandler.target = this.node; //这个 node 节点是你的事件处理代码组件所属的节点 checkEventHandler.component = 'example';//这个是脚本类名 checkEventHandler.handler = 'callback'; checkEventHandler.customEventData = 'foobar'; const toggle = this.node.getComponent(ToggleComponent); toggle.checkEvents.push(checkEventHandler); } callback(event: Event, customEventData: string){ //这里 event 是一个 Touch Event 对象，你可以通过 event.target 取到事件的发送节点 // 这里的 customEventData 参数就等于之前设置的 'foobar' } } 方法二 通过 toggle.node.on('toggle', ...) 的方式来添加 // 假设我们在一个组件的 onLoad 方法里面添加事件处理回调，在 callback 函数中进行事件处理 import { _decorator, Component, ToggleComponent } from 'cc'; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { @property(ToggleComponent) toggle: ToggleComponent | null = null; onLoad(){ this.toggle.node.on('toggle', this.callback, this); } callback(toggle: ToggleComponent){ // 回调的参数是 toggle 组件，注意这种方式注册的事件，无法传递 customEventData } } "},"ui-system/components/editor/toggleContainer.html":{"url":"ui-system/components/editor/toggleContainer.html","title":"ToggleContainer 组件参考","keywords":"","body":"ToggleContainer 组件参考 ToggleContainer 不是一个可见的 UI 组件，它可以用来修改一组 Toggle 组件的行为。当一组 Toggle 属于同一个 ToggleContainer 的时候，任何时候只能有一个 Toggle 处于选中状态。 注意：所有包含 Toggle 组件的一级子节点都会自动被添加到该容器中 点击 属性检查器 下面的 添加组件 按钮，然后选择 UI/ToggleContainer 即可添加 ToggleContainer 组件到节点上。 ToggleContainer 的组件接口请参考 ToggleContainer API。 关于使用可以参考范例 Toggle（GitHub | Gitee）。 ToggleContainer 属性 属性 功能说明 AllowSwitchOff 如果这个设置为 true，那么 toggle 按钮在被点击的时候可以反复地被选中和未选中。 CheckEvents 选中事件。列表类型，默认为空，用户添加的每一个事件由节点引用，组件名称和一个响应函数组成。 ToggleContainer 事件 事件结构参考：组件事件结构 ToggleContainer 的事件回调有二个参数，第一个参数是 Toggle 本身，第二个参数是 customEventData。 详细说明 ToggleContainer 一般不会单独使用，它需要与 Toggle 配合使用来实现 RadioButton 的单选效果。 通过脚本代码添加回调 这种方法添加的事件回调和使用编辑器添加的事件回调是一样的，都是通过代码添加。首先需要构造一个 EventHandler 对象，然后设置好对应的 target、component、handler 和 customEventData 参数。 import { _decorator, Component, Event, Node, ToggleContainer, EventHandler } from 'cc'; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { onLoad(){ const containerEventHandler = new EventHandler(); containerEventHandler.target = this.node; // 这个 node 节点是你的事件处理代码组件所属的节点 containerEventHandler.component = 'example';// 这个是脚本类名 containerEventHandler.handler = 'callback'; containerEventHandler.customEventData = 'foobar'; const container = this.node.getComponent(ToggleContainer); container.checkEvents.push(containerEventHandler); } callback(event: Event, customEventData: string) { // 这里 event 是一个 Touch Event 对象，你可以通过 event.target 取到事件的发送节点 // 这里的 customEventData 参数就等于之前设置的 'foobar' } } "},"ui-system/components/editor/slider.html":{"url":"ui-system/components/editor/slider.html","title":"Slider 组件参考","keywords":"","body":"Slider 组件参考 Slider 是一个滑动器组件。 点击 属性检查器 下面的 添加组件 按钮，选择 UI -> Slider 即可添加 Slider 组件到节点上。也可以直接在 层级管理器 中点击右上角的 + 按钮，然后选择 UI 组件 -> Slider 创建一个 Slider 节点。 滑动器的脚本接口请参考 Slider API。 关于使用可以参考范例 Slider（GitHub | Gitee）。 Slider 属性 属性 功能说明 handle 滑块按钮部件，可以通过该按钮进行滑动调节 Slider 数值大小 direction 滑动器的方向，分为横向和竖向 progress 当前进度值，该数值的区间是 0-1 之间 slideEvents 滑动器组件事件回调函数 Slider 事件 事件结构参考：组件事件结构 Slider 的事件回调有两个参数，第一个参数是 Slider 本身，第二个参数是 CustomEventData 详细说明 Slider 通常用于调节 UI 的数值（例如音量调节），它主要的部件是一个滑块按钮，该部件用于用户交互，通过该部件可进行调节 Slider 的数值大小。 通常一个 Slider 的节点树如下图： 通过脚本代码添加回调 方法一 这种方法添加的事件回调和使用编辑器添加的事件回调是一样的，都是通过代码添加。首先需要构造一个 EventHandler 对象，然后设置好对应的 target、component、handler 和 customEventData 参数。 import { _decorator, Component, Event, Node, Slider, EventHandler } from 'cc'; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { onLoad () { const sliderEventHandler = new EventHandler(); // 这个 node 节点是事件处理脚本组件所属的节点 sliderEventHandler.target = this.node; // 这个是脚本类名 sliderEventHandler.component = 'example'; sliderEventHandler.handler = 'callback'; sliderEventHandler.customEventData = 'foobar'; const slider = this.node.getComponent(Slider); slider!.slideEvents.push(sliderEventHandler); } callback(slider: Slider, customEventData: string) { //这里 event 是一个 Touch Event 对象，你可以通过 event.target 取到事件的发送节点 // 这里的 customEventData 参数就等于之前设置的 'foobar' } } 方法二 通过 slider.node.on('slide', ...) 的方式来添加 // 假设我们在一个组件的 onLoad 方法里面添加事件处理回调，在 callback 函数中进行事件处理 import { _decorator, Component, Slider } from 'cc'; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { @property(Slider) slider: Slider | null = null; onLoad () { this.slider!.node.on('slide', this.callback, this); } callback(slider: Slider) { // 回调的参数是 slider 组件，注意这种方式注册的事件，无法传递 customEventData } } "},"ui-system/components/editor/pageview.html":{"url":"ui-system/components/editor/pageview.html","title":"PageView 组件参考","keywords":"","body":"PageView 组件参考 PageView 是一种页面视图容器. 点击 属性检查器 下面的 添加组件 按钮，然后选择 UI/PageView 即可添加 PageView 组件到节点上。 页面视图的脚本接口请参考 PageView API。 关于使用可以参考范例 PageView（GitHub | Gitee）。 PageView 属性 属性 功能说明 SizeMode 页面视图中每个页面大小类型，目前有 Unified 和 Free 类型。 Content 它是一个节点引用，用来创建 PageView 的可滚动内容 Direction 页面视图滚动方向 ScrollThreshold 滚动临界值，默认单位百分比，当拖拽超出该数值时，松开会自动滚动下一页，小于时则还原 AutoPageTurningThreshold 快速滑动翻页临界值，当用户快速滑动时，会根据滑动开始和结束的距离与时间计算出一个速度值，该值与此临界值相比较，如果大于临界值，则进行自动翻页 Inertia 否开启滚动惯性 Brake 开启惯性后，在用户停止触摸后滚动多快停止，0 表示永不停止，1 表示立刻停止 Elastic 布尔值，是否回弹 Bounce Duration 浮点数，回弹所需要的时间。取值范围是 0-10 Indicator 页面视图指示器组件 PageTurningEventTiming 设置 PageView、PageTurning 事件的发送时机 PageEvents 数组，滚动视图的事件回调函数 CancelInnerEvents 布尔值，是否在滚动行为时取消子节点上注册的触摸事件 PageViewIndicator 设置 PageViewIndicator 是可选的，该组件是用来显示页面的个数和标记当前显示在哪一页。 建立关联可以通过在 层级管理器 里面拖拽一个带有 PageViewIndicator 组件的节点到 PageView 的相应字段完成。 PageView 事件 属性 功能说明 Target 带有脚本组件的节点 Component 脚本组件名称 Handler 指定一个回调函数，当 PageView 的事件发生的时候会调用此函数 CustomEventData 用户指定任意的字符串作为事件回调的最后一个参数传入 PageView 的事件回调有两个参数，第一个参数是 PageView 本身，第二个参数是 PageView 的事件类型。 详细说明 PageView 组件必须有指定的 content 节点才能起作用，content 中的每个子节点为一个单独页面，且每个页面的大小为 PageView 节点的大小，如果节点大小大于内容大小的话，可能会导致出现滚动不完整的现象。在 PageView 组件下有一个 view 节点对象，该对象结合 ScrollThreshold 决定了当前滑动的距离是否达到可以翻页的条件，操作效果分为以下两种： 缓慢滑动：通过拖拽视图中的页面到达指定的 ScrollThreshold 数值（该数值是页面大小的百分比）以后松开会自动滑动到下一页。 快速滑动：快速的向一个方向进行拖动，自动滑倒下一页，每次滑动最多只能一页。 通过脚本代码添加回调 方法一 这种方法添加的事件回调和使用编辑器添加的事件回调是一样的，都是通过代码添加。首先需要构造一个 EventHandler 对象，然后设置好对应的 target、component、handler 和 customEventData 参数。 import { _decorator, Component, Event, Node, PageView, EventHandler } from 'cc'; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { onLoad(){ const pageChangedEventHandler = new EventHandler(); pageChangedEventHandler.target = this.node; // 这个 node 节点是你的事件处理代码组件所属的节点 pageChangedEventHandler.component = 'example'; // 这个是脚本类名 pageChangedEventHandler.handler = 'callback'; pageChangedEventHandler.customEventData = 'foobar'; const page = this.node.getComponent(PageView); page.clickEvents.push(pageChangedEventHandler); } callback(event: Event, customEventData: string){ // 这里 event 是一个 Touch Event 对象，你可以通过 event.target 取到事件的发送节点 const node = event.target as Node; const pageview = node.getComponent(PageView); console.log(customEventData); // foobar } } 方法二 通过 pageView.node.on('page-turning', ...) 的方式来添加 // 假设我们在一个组件的 onLoad 方法里面添加事件处理回调，在 callback 函数中进行事件处理: import { _decorator, Component, Event, Node, PageView } from 'cc'; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { onLoad(){ this.pageView.node.on('page-turning', this.callback, this); } callback(pageView: PageView) { // 回调的参数是 pageView 组件 // 另外，注意这种方式注册的事件，也无法传递 customEventData } } "},"ui-system/components/editor/pageviewindicator.html":{"url":"ui-system/components/editor/pageviewindicator.html","title":"PageViewIndicator 组件参考","keywords":"","body":"PageViewIndicator 组件参考 PageViewIndicator 用于显示 PageView 当前的页面数量和标记当前所在的页面。 点击 属性检查器 下面的 添加组件 按钮，然后选择 UI -> PageViewIndicator 即可添加 PageViewIndicator 组件到节点上。 PageViewIndicator 的脚本接口请参考 PageViewIndicator API。 关于使用可以参考范例 PageView（GitHub | Gitee）。 PageViewIndicator 属性 属性 功能说明 spriteFrame 每个页面标记显示的图片 direction 页面标记摆放方向，分别为 水平方向 和 垂直方向 cellSize 每个页面标记的大小 spacing 每个页面标记之间的边距 详细说明 PageViewIndicator 一般不会单独使用，它需要与 PageView 配合使用，可以通过相关属性，来进行创建相对应页面的数量的标记，当你滑动到某个页面的时，PageViewIndicator 就会高亮它对应的标记。 "},"ui-system/components/editor/ui-model.html":{"url":"ui-system/components/editor/ui-model.html","title":"UIMeshRenderer 组件参考","keywords":"","body":"UIMeshRenderer 组件参考 UIMeshRenderer 是一个将 3D 模型从 3D 渲染管线转换到 2D 渲染管线的带有转换功能的渲染组件。该组件支持 3D 模型和粒子在 UI 上的显示，没有这个组件，即使模型和粒子节点在 UI 里也不会被渲染。 注意：若 3D 模型无法在 UI 场景中正常显示，请尝试放大模型倍数。 该组件的添加方式是在 层级管理器 中选中带有或继承自 MeshRenderer 组件的节点，然后点击 属性检查器 下方的 添加组件 按钮，选择 UI-> UIMeshRenderer 即可。而粒子则是添加到粒子节点上。通常结构如下所示： "},"ui-system/components/editor/ui-coordinate-tracker.html":{"url":"ui-system/components/editor/ui-coordinate-tracker.html","title":"UICoordinateTracker 组件参考","keywords":"","body":"UICoordinateTracker 组件参考 UI 坐标跟踪映射组件是在 UI 上执行坐标转换以及模拟透视相机下 3D 物体近大远小效果。通过事件的方式将转换后的坐标以及物体在视口下的占比返回。适用于 3D 人物血条以及姓名条之类功能。 UICoordinateTracker 属性 属性 功能说明 Target 目标对象。需要转换到哪一个 UI 节点下。 Camera 照射相机。 UseScale 是否是缩放映射。如果是透视相机，勾选此项，返回一个物体在视口下的占比。 Distance 距相机多少距离为正常显示计算大小。根据模型在相机下的照射效果调整最佳位置，以该位置为分界线计算在视口占比。 CoordinateDataEvents 映射数据事件。回调的第一个参数是映射后的本地坐标，第二个是距相机距离比。 具体的使用方法可参考范例 UI 展示 Demo（GitHub | Gitee）中的 rocker 场景。 "},"ui-system/components/editor/ui-opacity.html":{"url":"ui-system/components/editor/ui-opacity.html","title":"UIOpacity 组件参考","keywords":"","body":"UIOpacity（透明度设置）组件参考 该组件会为节点记录一个透明度修改标识用来影响到后续的渲染节点。一般用于非渲染节点，如果作用在渲染节点上会形成透明度叠加现象。渲染节点可以通过设置 color 的 alpha 通道来设置透明度。 使用方法如下： 也可以通过代码设置透明度： const opacityComp = this.getComponent(UIOpacity); opacityComp.opacity = 157; 遮罩的组件接口请参考 UIOpacity API。 关于使用可以参考范例 UIOpacity（GitHub | Gitee）。 UIOpacity 属性 属性 功能说明 Opacity 透明度 "},"ui-system/components/editor/block-input-events.html":{"url":"ui-system/components/editor/block-input-events.html","title":"BlockInputEvents 组件参考","keywords":"","body":"BlockInputEvents 组件参考 BlockInputEvents 组件将拦截所属节点 bounding box 内的所有输入事件（鼠标和触摸），防止输入穿透到下层节点，一般用于上层 UI 的背景。 当我们制作一个弹出式的 UI 对话框时，对话框的背景默认不会截获事件。也就是说虽然它的背景挡住了游戏场景，但是在背景上点击或触摸时，下面被遮住的游戏元素仍然会响应点击事件。这时我们只要在背景所在的节点上添加这个组件，就能避免这种情况。 该组件没有任何 API 接口，直接添加到场景即可生效。 "},"ui-system/components/editor/webview.html":{"url":"ui-system/components/editor/webview.html","title":"WebView 组件参考","keywords":"","body":"WebView 组件参考 WebView 是一种显示网页的组件，该组件让你可以在游戏里面集成一个小的浏览器。由于不同平台对于 WebView 组件的授权、API、控制方式都不同，还没有形成统一的标准，所以目前只支持 Web、iOS 和 Android 平台。 点击 属性检查器 下方的 添加组件 按钮，然后从 UI 组件 中选择 WebView，即可添加 WebView 组件到节点上。 WebView 的脚本接口请参考 WebView API。 WebView 属性 属性 功能说明 Url 指定一个 URL 地址，这个地址以 http 或者 https 开头，请填写一个有效的 URL 地址。 WebView Events WebView 的回调事件，当 webview 在加载网页过程中，加载网页结束后或者加载网页出错时会调用此函数。 注意：在 WebView Events 属性的 Node 中，应该填入的是一个挂载有用户脚本组件的节点，在用户脚本中便可以根据用户需要使用相关的 WebView 事件。 WebView 事件 WebViewEvents 事件 属性 功能说明 Target 带有脚本组件的节点。 Component 脚本组件名称。 Handler 指定一个回调函数，当网页加载过程中、加载完成后或者加载出错时会被调用，该函数会传一个事件类型参数进来。详情见下方的 WebView 事件回调参数 部分 CustomEventData 用户指定任意的字符串作为事件回调的最后一个参数传入。 详情可参考 API 文档 Component.EventHandler 类型 WebView 事件回调参数 名称 功能说明 LOADING 表示网页正在加载过程中。 LOADED 表示网页加载已经完毕。 ERROR 表示网页加载出错了。 详情可参考 API WebView 事件。 使用方式可参考范例 Webview（GitHub | Gitee）。 详细说明 目前此组件只支持 Web（PC 和手机）、iOS 和 Android 平台（v2.0.0～2.0.6 版本不支持），Mac 和 Windows 平台暂时还不支持，如果在场景中使用此组件，那么在 PC 的模拟器里面预览的时候可能看不到效果。 注意： WebView 组件暂时不支持加载指定 HTML 文件或者执行 Javascript 脚本。 如果开发者在项目中未使用到 WebView 相关功能，请确保在 项目 -> 项目设置 -> 功能裁剪 中剔除 WebView 模块，以提高 iOS 的 App Store 机审成功率。如果开发者确实需要使用 WebView（或者添加的第三方 SDK 自带了 WebView），并因此 iOS 的 App Store 机审不通过，仍可尝试通过邮件进行申诉。 通过脚本代码添加回调 方法一 这种方法添加的事件回调和使用编辑器添加的事件回调是一样的，通过代码添加，你需要首先构造一个 Component.EventHandler 对象，然后设置好对应的 target、component、handler 和 customEventData 参数。 import { _decorator, Component, WebView } from 'cc'; const { ccclass, type } = _decorator; @ccclass('MyComponent') export class MyComponent extends Component { @type(WebView) webview = null; start () { const eventHandler = new Component.EventHandler(); eventHandler.target = newTarget; // 这个对象是你的事件处理代码组件所属的节点 eventHandler.component = \"MyComponent\"; eventHandler.handler = \"callback\"; eventHandler.customEventData = \"foobar\"; this.webview.webviewEvents.push(eventHandler); } // 注意参数的顺序和类型是固定的 callback: function(webview, eventType, customEventData) { // webview：是一个 webview 组件对象实例 // eventType：等于 WebView.EventType enum 里面的值 // customEventData：参数就等于你之前设置的 \"foobar\" } } 方法二 通过 webview.node.on(WebView.EventType.LOADED, ...) 的方式来添加 import { _decorator, Component, WebView } from 'cc'; const { ccclass, type } = _decorator; @ccclass('WebViewCtrl') export class WebViewCtrl extends Component { @type(WebView) webview = null; start () { this.webview.node.on(WebView.EventType.LOADED, this.callback, this); } callback (webview) { // 这里的 webview 是一个 WebView 组件对象 // 对 webview 进行你想要的操作 // 另外，需要注意的是通过这种方式注册的事件，无法传递 customEventData } } 同样的，你也可以注册 WebView.EventType.LOADING、WebView.EventType.ERROR 事件，这些事件的回调函数的参数与 WebView.EventType.LOADED 的参数一致。 如何与 WebView 内部页面进行交互 调用 WebView 内部页面 import { _decorator, Component, WebView } from 'cc'; const { ccclass, type } = _decorator; @ccclass('WebViewCtrl') export class WebViewCtrl extends Component { @type(WebView) webview = null; start () { // 这里的 Test 是你 webView 内部页面代码里定义的全局函数 this.webview.evaluateJS('Test()'); } } 注意：Web 平台上的跨域问题需要自行解决 WebView 内部页面调用外部的代码 目前 Android 与 iOS 用的机制是，通过截获 URL 的跳转，判断 URL 前缀的关键字是否与之相同，如果相同则进行回调。 通过 setJavascriptInterfaceScheme 设置 URL 前缀关键字 通过 setOnJSCallback 设置回调函数，函数参数为 URL import { _decorator, Component, WebView } from 'cc'; const { ccclass, type } = _decorator; @ccclass('WebViewCtrl') export class WebViewCtrl extends Component { @type(WebView) webview = null; start () { // 这里是与内部页面约定的关键字，请不要使用大写字符，会导致 location 无法正确识别。 let scheme = \"testkey\"; function jsCallback (target, url) { // 这里的返回值是内部页面的 URL 数值，需要自行解析自己需要的数据。 let str = url.replace(scheme + '://', ''); // str === 'a=1&b=2' // webview target console.log(target); } this.webview.setJavascriptInterfaceScheme(scheme); this.webview.setOnJSCallback(jsCallback); } } 因此当你需要通过内部页面交互 WebView 时，应当设置内部页面 URL：testkey://(后面你想要回调到 WebView 的数据)。WebView 内部页面代码如下： function onClick () { // 其中一个设置 URL 方案 document.location = 'testkey://a=1&b=2'; } 由于 Web 平台的限制，导致无法通过这种机制去实现，但是内部页面可以通过以下方式进行交互： function onClick () { // 如果 TestCode 是定义在 window 上，则 parent.TestCode(); } 再强调一遍：Web 平台上的跨域问题需要自行解决 "},"ui-system/components/editor/videoplayer.html":{"url":"ui-system/components/editor/videoplayer.html","title":"VideoPlayer 组件参考","keywords":"","body":"VideoPlayer 组件参考 VideoPlayer 是一种视频播放组件，可通过该组件播放本地和远程视频。 播放本地视频： 播放远程视频： 点击 属性检查器 下面的 添加组件 按钮，然后从 UI 组件 中选择 VideoPlayer，即可添加 VideoPlayer 组件到节点上。 VideoPlayer 的脚本接口请参考 VideoPlayer API。 VideoPlayer 属性 属性 功能说明 Resource Type 视频来源的类型，目前支持本地（LOCAL）视频和远程（REMOTE）视频 URL Remote URL 当 Resource Type 为 REMOTE 时显示的字段，填入远程视频的 URL Clip 当 Resource Type 为 LOCAL 时显示的字段，拖拽本地视频的资源到此处来使用 Play On Awake 视频加载后是否自动开始播放？ Current Time 指定从哪个时间点开始播放视频 Volume 视频的音量（0.0 ~ 1.0） Mute 是否静音视频。静音时设置音量为 0，取消静音时恢复原来的音量 Keep Aspect Ratio 是否保持视频原来的宽高比 Full Screen On Awake 是否全屏播放视频 Stay On Bottom 永远在游戏视图最底层（该属性仅在 Web 平台生效） Video Player Event 视频播放回调函数，该回调函数会在特定情况被触发，比如播放中，暂时，停止和完成播放。详情见下方的 VideoPlayer 事件 章节或者 VideoPlayerEvent API。 注意：在 Video Player Event 属性的 Node 中，应该填入的是一个挂载有用户脚本组件的节点，在用户脚本中便可以根据用户需要使用相关的 VideoPlayer 事件。 VideoPlayer 事件 VideoPlayerEvent 事件 属性 功能说明 target 带有脚本组件的节点。 component 脚本组件名称。 handler 指定一个回调函数，当视频开始播放后，暂停时或者结束时都会调用该函数，该函数会传一个事件类型参数进来。 customEventData 用户指定任意的字符串作为事件回调的最后一个参数传入。 详情可参考 API 文档 Component.EventHandler 事件回调参数 名称 功能说明 PLAYING 表示视频正在播放中。 PAUSED 表示视频暂停播放。 STOPPED 表示视频已经停止播放。 COMPLETED 表示视频播放完成。 META_LOADED 表示视频的元信息已加载完成，你可以调用 getDuration 来获取视频总时长。 READY_TO_PLAY 表示视频准备好了，可以开始播放了。 ERROR 处理视频时触发的错误 CLICKED 表示视频被用户点击了。（只支持 Web 平台） 注意：在 iOS 平台的全屏模式下，点击视频无法发送 CLICKED 事件。如果需要让 iOS 全屏播放并正确接受 CLICKED 事件，可以使用 Widget 组件把视频控件撑满。 详情可参考 VideoPlayer 事件。 使用方式可参考范例 VideoPlayer（GitHub | Gitee）。 详细说明 VideoPlayer 支持的视频格式为 mp4。 通过脚本代码添加回调 方法一 这种方法添加的事件回调和使用编辑器添加的事件回调是一样的。通过代码添加，首先你需要构造一个 Component.EventHandler 对象，然后设置好对应的 target、component、handler 和 customEventData 参数。 import { _decorator, Component, VideoPlayer } from 'cc'; const { ccclass, type } = _decorator; @ccclass('MyComponent') export class MyComponent extends Component { @type(VideoPlayer) videoPlayer = null; start () { const eventHandler = new Component.EventHandler(); eventHandler.target = newTarget; // 这个对象是你的事件处理代码组件所属的节点 eventHandler.component = \"MyComponent\"; eventHandler.handler = \"callback\"; eventHandler.customEventData = \"foobar\"; this.videoplayer.videoPlayerEvent.push(eventHandler); } // 注意参数的顺序和类型是固定的 callback: function(videoplayer, eventType, customEventData) { // 这里的 videoplayer 是一个 VideoPlayer 组件对象实例 // 这里的 eventType === VideoPlayer.EventType enum 里面的值 // 这里的 customEventData 参数就等于你之前设置的 \"foobar\" } } 方法二 通过 videoplayer.node.on(VideoPlayer.EventType.READY_TO_PLAY, ...) 的方式来添加 //假设我们在一个组件的 onLoad 方法里面添加事件处理回调，在 callback 函数中进行事件处理: import { _decorator, Component, VideoPlayer } from 'cc'; const { ccclass, type } = _decorator; @ccclass('VideoPlayerCtrl') export class VideoPlayerCtrl extends Component { @type(VideoPlayer) videoPlayer = null; start () { this.videoplayer.node.on(VideoPlayer.EventType.READY_TO_PLAY, this.callback, this); } callback (videoplayer) { // 这里的 videoplayer 表示的是 VideoPlayer 组件 // 对 videoplayer 进行你想要的操作 // 另外，注意这种方式注册的事件，也无法传递 customEventData } } 同样的，用户也可以注册 meta-loaded、clicked、playing 等事件，这些事件的回调函数的参数与 ready-to-play 的参数一致。 注意：由于 VideoPlayer 是特殊的组件，所以它无法监听节点上的 触摸 和 鼠标 事件。 关于完整的 VideoPlayer 的事件列表，可以参考 VideoPlayer API。 如何实现 UI 在 VideoPlayer 上渲染 可通过以下两个步骤实现 UI 在 VideoPlayer 上显示： 确保 项目设置 -> Macro Config 中的 ENABLE_TRANSPARENT_CANVAS 为勾选状态（设置 Canvas 背景支持 alpha 通道） 可在 属性检查器 中勾选 VideoPlayer 组件上的 stayOnBottom 属性。 注意： 该功能仅支持 Web 平台。 各个浏览器具体效果无法保证一致，跟浏览器是否支持与限制有关。 开启 stayOnBottom 后，将无法正常监听 VideoPlayerEvent 中的 clicked 事件。 详情可参考范例 VideoPlayer（GitHub | Gitee）。 最终效果如下图所示： 支持平台 由于不同平台对于 VideoPlayer 组件的授权、API、控制方式都不同，还没有形成统一的标准，所以目前只支持 Web、iOS、Android、微信小游戏、Facebook Instant Games 以及 Google Play Instant 平台。 关于自动播放的问题 一些移动端的浏览器或 WebView 不允许自动播放视频，用户需要在触摸事件中手动播放视频。 import { _decorator, Node, Component, find, VideoPlayer } from 'cc'; const { ccclass, type } = _decorator; @ccclass('VideoPlayerCtrl') export class VideoPlayerCtrl extends Component { @type(VideoPlayer) videoPlayer = null; start () { let canvas = find('Canvas'); canvas.on(Node.EventType.TOUCH_START, this.playVideo, this); } playVideo () { this.videoplayer.play(); } } "},"ui-system/components/editor/safearea.html":{"url":"ui-system/components/editor/safearea.html","title":"SafeArea 组件参考","keywords":"","body":"SafeArea 组件参考 该组件会将所在节点的布局适配到 iPhone X 等异形屏手机的安全区域内，可适配 Android 和 iOS 设备，通常用于 UI 交互区域的顶层节点。 开发者只需要将 SafeArea 组件添加到节点上。该组件在启用时会通过 sys.getSafeAreaRect() 获取到当前 iOS 或 Android 设备的安全区域，并通过 Widget 组件（如果没有 Widget 组件会自动添加）实现适配。 SafeArea 脚本接口请参考 Mask API。 具体用法可参考官方范例 SafeArea（GitHub | Gitee）。 "},"ui-system/components/engine/usage-ui.html":{"url":"ui-system/components/engine/usage-ui.html","title":"UI 实践指南","keywords":"","body":"UI 实践指南 多分辨率适配方案 对齐策略 文字排版 自动布局容器 制作动态生成内容的列表 制作可任意拉伸的 UI 图像 "},"ui-system/components/engine/multi-resolution.html":{"url":"ui-system/components/engine/multi-resolution.html","title":"多分辨率适配方案","keywords":"","body":"多分辨率适配方案 Cocos Creator 3.0 在整体设计上沿用了 Cocos Creator 2D 一套资源适配多种分辨率屏幕的方案。简单概括来说，我们通过以下几个部分完成多分辨率适配解决方案： Canvas（画布） 组件随时获得设备屏幕的实际分辨率并对场景中所有渲染元素进行适当的缩放。 Widget（对齐挂件） 组件添加给 UI 节点，能够根据需要将元素对齐目标节点（默认是父节点）的不同参考位置。 Label（文字） 组件内置了提供各种动态文字排版模式的功能，当文字的约束框由于 Widget 对齐要求发生变化时，文字会根据需要呈现完美的排版效果。 Sliced Sprite（九宫格精灵图） 则提供了可任意指定尺寸的图像，同样可以满足各式各样的对齐要求，在任何屏幕分辨率上都显示高精度的图像。 接下来我们首先了解设计分辨率、屏幕分辨率的概念，才能理解 Canvas（画布） 组件的缩放作用。 设计分辨率和屏幕分辨率 设计分辨率 是内容生产者在制作场景时使用的分辨率蓝本，而 屏幕分辨率 是游戏在设备上运行时的实际屏幕显示分辨率。 通常设计分辨率会采用市场目标群体中使用率最高的设备的屏幕分辨率，比如目前安卓设备中 800 x 480 和 1280 x 720 两种屏幕分辨率，或 iOS 设备中 1136 x 640 和 960 x 640 两种屏幕分辨率。这样当美术或策划使用设计分辨率设置好场景后，就可以自动适配最主要的目标人群设备。 那么当设计分辨率和屏幕分辨率出现差异时，会如何进行适配呢？ 假设我们的设计分辨率为 800 x 480，美术制作了一个同样分辨率大小的背景图像。 设计分辨率和屏幕分辨率宽高比相同 在屏幕分辨率的宽高比和设计分辨率相同时，假如屏幕分辨率是 1600 x 960，正好将背景图像放大 1600/800 = 2 倍 就可以完美适配屏幕。这是最简单的情况，这里不再赘述。 设计分辨率宽高比大于屏幕分辨率，适配高度避免黑边 假设屏幕分辨率是 1024 x 768，在下图中以红色方框表示设备屏幕可见区域。我们使用菜单栏 项目 -> 项目设置 -> 项目数据 面板中的 适配高度（Fit Height）模式，将设计分辨率的高度自动撑满屏幕高度，也就是将场景图像放大到 768/480 = 1.6 倍。 这是设计分辨率宽高比大于屏幕分辨率时比较理想的适配模式，如上图所示，虽然屏幕两边会裁剪掉一部分背景图，但能够保证屏幕可见区域内不出现任何穿帮或黑边。之后可以通过 Widget（对齐挂件）调整 UI 元素的位置，来保证 UI 元素出现在屏幕可见区域里，我们在下一节 对齐策略 中将会详细介绍。 设计分辨率宽高比小于屏幕分辨率，适配宽度避免黑边 假设屏幕分辨率是 1920 x 960，同样在下图中以红色方框表示设备屏幕可见区域。我们使用菜单栏 项目 -> 项目设置 -> 项目数据 面板中的 适配宽度（Fit Width）模式，将设计分辨率的宽度自动撑满屏幕宽度，也就是将场景放大 1920/800 = 2.4 倍。 在设计分辨率宽高比较小时，使用这种模式会裁剪掉屏幕上下一部分背景图。 不管屏幕宽高比如何，完整显示设计分辨率中的所有内容，允许出现黑边 最后一个例子，我们屏幕分辨率假设为 640 x 960 的竖屏，如果要确保背景图像完整的在屏幕中显示，需要同时开启 适配高度 和 适配宽度，这时场景图像的缩放比例是按照屏幕分辨率中较小的一维来计算的，在下图的例子中，由于屏幕宽高比小于 1，就会以宽度为准计算缩放倍率，即 640/800 = 0.8 倍。 在这种显示模式下，屏幕上可能会出现黑边，或超出设计分辨率的场景图像（穿帮）。尽管一般情况下开发者会尽量避免黑边，但如果需要确保设计分辨率范围的所有内容都显示在屏幕上，也可以采用这种模式。 根据屏幕宽高比，自动选择适配宽度或适配高度 如果对于屏幕周围可能被剪裁的内容没有严格要求，也可以不开启任何适配模式，这时会根据屏幕宽高比自动选择 适配高度 或 适配宽度 来避免黑边。也就是说，设计分辨率宽高比大于屏幕分辨率时，会自动适配高度（上面第一张图）；设计分辨率宽高比小于屏幕分辨率时，会自动适配宽度（上面第二张图）。 设计分辨率只能在项目设置中统一配置 当前的设计模式并没有加入多分辨率适配方式，所以在同一个项目里的多个 Canvas 的设计分辨率仍然采用同一套设计分辨率以及适配方案，开发者可以通过 项目 -> 项目设置 -> 项目数据 页面配置。 "},"ui-system/components/engine/widget-align.html":{"url":"ui-system/components/engine/widget-align.html","title":"对齐策略","keywords":"","body":"对齐策略 要实现完美的多分辨率适配效果，UI 元素按照设计分辨率中规定的位置呈现是不够的，当屏幕宽度和高度发生变化时，UI 元素要能够智能感知屏幕边界的位置，才能保证出现在屏幕可见范围内，并且分布在合适的位置。我们通过 Widget（对齐挂件） 来实现这种效果。 下面我们根据要对齐元素的类别来划分不同的对齐工作流： 需要贴边对齐的按钮和小元素 对于暂停菜单、游戏金币这一类面积较小的元素，通常只需要贴着屏幕边对齐就可以了。这时只要几个简单的步骤： 在 层级管理器 中创建 2D 对象时会默认自动创建一个 Canvas 节点作为其父节点，这些元素节点都需要放在 Canvas 节点下 在元素节点上添加 Widget 组件 以对齐左下角为例，开启 Left 和 Bottom 的对齐。 然后设置好节点和屏幕边缘的距离，下图中左边距设为 40px，下边距设为 30px。 这样设置好 Widget 组件后，不管实际屏幕分辨率是多少，这个节点元素都会保持在屏幕左下角，而且节点约束框左边和屏幕左边距离保持 40px，节点约束框下边和屏幕下边距离保持 30px。 注意：Widget 组件提供的对齐距离是参照子节点和父节点相同方向的约束框边界的。比如上面例子里选择了 Left 对齐左边，那么子节点约束框左边和父节点，约束框左边的距离就是我们设置的 40px。其中父节点也就是 Canvas 节点，约束框永远等于屏幕大小，前提是在编辑器顶部菜单栏中的 项目 -> 项目设置 -> 项目数据 中只勾选 适配屏幕宽度 或者 适配屏幕高度。 嵌套对齐元素 上面介绍了对齐屏幕边缘的做法，由于 Widget 默认的对齐参照物是父节点，所以我们也可以添加不同的节点层级，并且让每一级节点都使用自动对齐的功能。 我们下面用一个简单的例子来说明，假设我们有这样的节点层级关系： 其中 parent 是一个面板，button 是一个按钮。我们可以分别为这两个节点添加 Widget 组件，并且分别设置对齐距离。 对于 parent 节点来说，对齐 Canvas 节点的左上角，距离都是 80px： 对于 button 节点来说，对齐 parent 节点的左上角，距离都是 50px： 依照这样的工作流程，就可以将 UI 元素按照显示区域或功能进行分组，并且不同级别的元素都可以按照设计进行对齐。 根据对齐需要自动缩放节点尺寸 以上我们展示的例子里，并没有同时对齐在同一轴向相反方向的两个边，如果我们要做一个占满整个屏幕宽度的面板，就可以同时勾选 Left 和 Right 对齐开关： 当同时勾选相反的两个方向的对齐开关时，Widget 就获得了根据对齐需要修改节点尺寸（Size）的能力，上图中我们勾选了左右两个方向并设置了边距，Widget 就会根据父节点的宽度来动态设置节点的 Width 属性，表现出来就是不管在多宽的屏幕上，我们的面板距离屏幕左右两边的距离永远保持 100px。 制作和屏幕大小保持一致的节点 利用自动缩放节点的特性，我们可以通过设置节点的 Widget 组件，使节点的尺寸和屏幕大小保持一致。 要制作这样的节点，首先要保证该节点的父节点尺寸能够保持和屏幕大小一致，Canvas 节点就是一个最好的选择。接下来按照下图的方式设置该节点的 Widget 组件： 就可以在运行时时刻保持该节点和 Canvas 节点的尺寸完全一致，也就是和屏幕大小一致。经过这样设置的节点，其子节点也可以使用同样的设置来传递屏幕实际尺寸。 注意：若要实现该功能，则需要在编辑器顶部菜单栏的 项目 -> 项目设置 -> 项目数据 中只勾选 适配屏幕宽度 或者 适配屏幕高度。 设置百分比对齐距离 Widget 组件上开启某个方向的对齐之后，除了指定以像素为单位的边距以外，我们还可以输入百分比数值（例如：通过 单击 方框内圈出的符号），这样 Widget 会以父节点相应轴向的宽度或高度乘以输入的百分比，计算出实际的边距值。 还是看看实际的例子，我们还是以一个直接放在 Canvas 下的子节点为例，我们希望这个节点面板保持在屏幕右侧，并且总是占据 60% 的屏幕总高度。那么按照下图所示设置 Widget 组件就可以实现这个效果： Widget 在对齐方向开启时输入边距值时，可以按照需要混合像素单位和百分比单位的使用。比如左边需要对齐屏幕中心，则 Left 方向输入 50%，右边需要对齐屏幕边缘，则 Right 方向输入 20px，最后计算子节点位置和尺寸时，所有的边距都会先根据父节点的尺寸换算成像素距离，然后再进行摆放。 利用百分比对齐距离，我们可以制作出根据屏幕大小无限缩放的 UI 元素，发挥你的想象力，一套资源适配数千种机型不是问题！ 运行时每帧更新对齐和优化策略 Widget 组件一般用于场景在目标设备上初始化时定位每个元素的位置，但一旦场景初始化完毕，很多时候我们就不需要 Widget 组件再进行对齐了。这里有个重要的属性 alignOnce 用于确保 Widget 组件只在初始化时执行对齐定位的逻辑，在运行时不再消耗时间来进行对齐。 若 对齐模式（AlignMode） 设置为 ONCE 或者 ON_WINDOW_RESIZE，且在组件初始化时执行过一次对齐定位，引擎就会自动将 Widget 组件的 enabled 属性设为 false，禁用 Widget 组件来关闭之后的每帧自动更新，避免重复定位。 若需要在运行时变更定位，则需要手动将 AlignMode 设置为 ALWAYS，或者在运行时需要进行每帧更新对齐时，手动遍历需要对齐的 Widget，并将它们的 enabled 属性设为 true。 对于有很多 UI 元素的场景，确保 Widget 组件的 AlignMode 属性设置为 ON_WINDOW_RESIZE，可以大幅提高场景运行性能。 对齐组件对节点位置、尺寸的限制 通过 Widget 组件开启一个或多个对齐设置后，节点的位置（position）和尺寸（width、height）属性可能会被限制，不能通过 API 或动画系统自由修改。如果需要在运行时修改对齐节点的位置或尺寸，请参考 Widget 组件参考：对节点位置、尺寸的限制 相关内容。 "},"ui-system/components/engine/label-layout.html":{"url":"ui-system/components/engine/label-layout.html","title":"文字排版","keywords":"","body":"文字排版 文字组件（Label） 是核心渲染组件之一，您需要了解如何设置文字的排版，才能在 UI 系统进行多分辨率适配和对齐设置时显示完美的效果。 文字在约束框中对齐 和其他渲染组件一样，Label 组件的排版也是基于 UITransform 组件所拥有的尺寸信息（contentSize），也就是约束框（Bounding Box）所规定的范围。 上图所示就是 Label 渲染的文字在蓝色约束框内显示的效果。Label 中以下的属性决定了文字在约束框中显示的位置： Horizontal Align（水平对齐）：文字在约束框中水平方向的对齐准线，可以从 Left、Right、Center 三种位置中选择。 Vertical Align（垂直对齐）：文字在约束框中垂直方向的对齐准线，可以从 Top、Bottom、Center 三种位置中选择。 上图中水平方向对齐位置设置为 Right，垂直方向的对齐位置设为了 Bottom，可以看到文字出现在约束框的底部且靠右对齐。开发者可以将以上两个属性修改为其他组合，文字会根据设置出现在蓝色约束框内相应的位置。 文字尺寸和行高 Font Size（文字尺寸）决定了文字的显示大小，单位是 Point（也称作“磅”），是大多数图像制作和文字处理软件中通用的字体大小单位。对于动态字体来说，Font Size 可以无损放大，但位图字体在将 Font Size 设置为超过字体标定的字号大小时，显示会变得越来越模糊。 Line Height（行高）决定了文字在多行显示时每行文字占据的空间高度，单位同样是 Point。多行文字显示可以通过两种方式实现： 在 String 属性中输入文字时，手动输入回车或换行符 开启 Enable Wrap Text（换行）属性，下文会详细介绍 文字尺寸和行高的关系： 如果 Font Size 和 Line Height 设为相同数值，文字正好占据一行大部分的空间高度。 如果 Font Size 小于 Line Height，多行文字之间间隔会加大 如果 Font Size 大于 Line Height，多行文字之间间隔会缩小，甚至出现文字相互重叠的情况。 排版模式（Overflow） Overflow（排版模式） 属性，决定了文字内容增加时，如何在约束框的范围内排布。共有 NONE、CLAMP、SHRINK、RESIZE_HEIGHT 四种模式，而只有在 后三种模式 下才能通过编辑器左上角的 矩形变换工具（也可以是按键盘按键 T）或者修改 属性检查器 中的 Size 大小或者添加 Widget 组件 来调整约束框的大小。 NONE 模式会自动根据文字尺寸、行高等固定约束框尺寸。 截断（Clamp） 截断模式下，文字首先按照对齐模式和尺寸的要求进行渲染，而超出约束框的部分会被隐藏（截断）。 自动缩小（Shrink） 自动缩小模式下，如果文字按照原定尺寸渲染会超出约束框时，会自动缩小文字尺寸以显示全部文字。 注意：自动缩小模式不会放大文字来适应约束框。 自动适应高度（Resize Height） 自动适应高度模式会保证文字的约束框贴合文字的高度，不管文字有多少行。这个模式非常适合显示内容量不固定的大段文字，配合 ScrollView 组件 可以在任意 UI 区域中显示无限量的文字内容。 自动换行（Enable Wrap Text） Label 组件中的 Enable Wrap Text（自动换行）属性，可以切换文字的自动换行开关。在自动换行开启的状态下，不需要在输入文字时手动输入回车或换行符，文字也会根据约束框的宽度自动换行。 注意：自动换行属性只有在文字排版模式的 截断（Clamp） 和 自动缩小（Shrink） 这两种模式下才有。自动适应高度（Resize Height） 模式下，自动换行属性是强制开启的。 截断（Clamp）模式自动换行 截断模式开启自动换行后，会优先在约束框允许的范围内换行排列文字，如果换行之后仍无法显示全部文字时才发生截断。 以下两幅图都是在 Clamp + Enable Wrap Text 开启情况下的，区别在于文字约束框的宽度不同： 在约束框宽度从左图变化到右图的过程中，文字将不断调整换行，最后由于约束框高度不足而产生了截断显示。 自动缩小（Shrink）模式自动换行 和截断模式类似，自动缩小模式下文字超出约束框宽度时也会优先试图换行，在约束框宽度和长度都已经完全排满的情况下才会自动缩小文字以适应约束框。 中文自动换行 中文自动换行的行为和英文不同，英文是以单词为单位进行换行的，必须有空格才能作为换行调整的最小单位。中文是以字为单位进行换行，每个字都可以单独调整换行。 文字节点的锚点 文字节点的锚点和文字在约束框中的对齐模式是需要区分的两个概念。在需要靠文字内容将约束框撑大的排版模式中（如 Resize Height），要正确设置锚点位置，才能让约束框向我们期望的方向调整。 例如，如果希望文字约束框向下扩展，需要将锚点（Anchor）的 y 属性设为 1。如下图所示： 文字配合对齐挂件（Widget） 在 Label 组件所在节点上添加一个 Widget（对齐挂件） 组件，就可以让文字节点相对于父节点进行各式各样的排版。 上图中我们在背景节点上添加了两个 Label 子节点，分别为它们添加 Widget 组件后，设置左边文字 Widget 的 Right 属性为 50%，右边文字 Widget 的 Left 属性为 60%，就可以实现图中所示的多列布局式文字。 而且通过 Widget 上设置边距，加上文字本身的排版模式，可以让我们在不需要具体微调文字约束框大小的情况下轻松实现灵活美观的文字排版。 查看组件参考 关于 Label 组件的属性，也可以查阅 Label 组件参考 文档。 "},"ui-system/components/engine/auto-layout.html":{"url":"ui-system/components/engine/auto-layout.html","title":"自动布局容器","keywords":"","body":"自动布局容器 Layout（自动布局）组件可以挂载在任何节点上，将节点变成一个有自动布局功能的容器。所谓自动布局容器，就是能够自动将子节点按照一定规律排列，并可以根据节点内容的约束框总和调整自身尺寸的容器型节点。 接下来说到的布局类型，节点结构都如下图： 布局类型 自动布局组件有几种基本的布局模式，可以通过 Type 属性进行设置，包括以下几种。 水平布局（Horizontal) Layout Type 设为 Horizontal 时，所有子节点都会自动横向排列，组件默认会修改节点在 y 轴上的位置或高度，如果子节点需要放置在 Layout 节点的约束框高度范围之外，可以取消勾选 AutoAlignment（如上图）。 水平排序下容易出现内容超出容器的情况，可以根据需要采取如下措施： 如果容器要自适应上内容的尺寸，可以通过设置 ResizeMode 为 Container，该模式会根据子节点的宽度（Width）总和设置 Layout 节点的宽度（下图左）。 如果内容对象始终要保持在容器内，可以通过设置 ResizeMode 为 Children，该模式会将内容对象的尺寸限制在容器内（下图右）。 如果需要子节点在 y 轴向上对齐，可以在子节点上添加 Widget 组件，并开启 Top 或 Bottom 的对齐模式。 水平排列方向（Horizontal Direction） 在水平布局下，可以通过 HorizontalDirection 设置水平朝向。朝向分为 LEFT_TO_RIGHT 和 RIGHT_TO_LEFT 两种，前者会按照节点在 层级管理器 中显示顺序从左到右排列；后者会按照节点显示从右到左排列。 垂直布局（Vertical） 垂直布局的布局方式和排列方向跟 水平布局 几乎一致，只是方向上的不同，这里就不再赘述。 网格布局（Grid） Layout Type 设为 GRID 会开始网格布局。网格布局会在固定容器大小内，根据 HorizontalDirection 和 VerticalDirection 组合决定布局起点，根据 StartAxis 属性决定布局方向。 网格排列方向（Grid Direction） Layout 排列子节点时，是以子节点在 层级管理器 中显示顺序为基准，加上开始点和 StartAxis 属性设置的排列方向来排列的。 开始轴向（Start Axis） 可以设置 HORIZONTAL 或 VERTICAL 两种方向。前者会进行横向排列，后者是纵向排列。 开始点 开始点是通过 HorizontalDirection 和 VerticalDirection 组合而成。 假设 HorizontalDirection 为 LEFT_TO_RIGHT，VerticalDirection 为 TOP_TO_BOTTOM，则开始点是 左上角 假设 HorizontalDirection 为 RIGHT_TO_LEFT，VerticalDirection 为 BOTTOM_TO_TOP，则开始点是 右下角 结合排列方向，举两个例子说明： 如果当前设置的 HorizontalDirection 为 LEFT_TO_RIGHT，VerticalDirection 为 TOP_TO_BOTTOM，StartAxis 为 HORIZONTAL，则是告知组件要的排序方式是从容器的 左上角 开始按水平方向排列（下图左）。 如果当前设置的 HorizontalDirection 为 RIGHT_TO_LEFT，VerticalDirection 为 BOTTOM_TO_TOP，StartAxis 为 VERTICAL，则是告知组件要的排序方式是从容器的 右下角 开始按垂直方向排列（下图右）。 Grid 排序也有可能出现内容超出容器的情况，可以参考上文中的 水平布局，通过调整 ResizeMode 属性解决。 关于 Layout 组件的属性的详细说明，请参考 Layout 组件 文档。 "},"ui-system/components/engine/list-with-data.html":{"url":"ui-system/components/engine/list-with-data.html","title":"制作动态生成内容的列表","keywords":"","body":"制作动态生成内容的列表 UI 界面只有静态页面内容是不够的，我们会遇到很多需要由一组数据动态生成多个元素组成的 UI 面板，比如选人界面、物品栏、选择关卡等等。 准备数据 以物品栏为例，我们要动态生成一个物品，大概需要这样的一组数据： 物品 id 图标 id，我们可以在另一张资源表中建立图标 id 到对应 spriteFrame 的索引 物品名称 出售价格 ... 下面我们将会结合脚本介绍如何定义和使用数据，如果您对 Cocos Creator 3.0 的脚本系统还不熟悉，可以先从 脚本开发指南 一章开始学习。 自定义数据类 对于大多数游戏来说，这些数据通常都来自于服务器或本地的数据库，现在我们为了展示流程，暂时把数据存在列表组件里就可以了。您可以新建一个脚本 ItemList.ts，并添加如下的属性： @ccclass('Item') export class Item { @property id = 0; @property itemName = ''; @property itemPrice = 0; @property(SpriteFrame) iconSF: SpriteFrame | null = null; } @ccclass export class ItemList extends Component { @property([Item]) items: Item[] = []; @property(Prefab) itemPrefab: Prefab | null = null; onLoad() { for (let i = 0; i 上面脚本的前半部分我们声明了一个叫做 Item 的数据类，用来存放我们展示物品需要的各种数据。注意这个类并没有继承 Component，因此它不是一个组件，但可以被组件使用。关于声明自定义类的更多内容，请查阅 装饰器 文档。 下半部分是正常的组件声明方式，这个组件中只有一个 items 属性，上面的声明方式将会给我们一个由 Item 类组成的数组，我们可以在 属性检查器 中为每个 Item 元素设置数据。 新建一个节点并将 ItemList.ts 添加上去，我们可以在 属性检查器 里找到 Items 属性，要开始创建数据，需要先将数组的容量设为大于 0 的值。让我们将容量设为 3，并将每个元素的数据如下图设置。 这样我们最基本的数据就准备好了，如果您在制作有很多内容的游戏，请务必使用 excel、数据库等更专业的系统来管理您的数据，将外部数据格式转化为 Cocos Creator 可以使用的 TypeScript 和 JSON 格式都非常容易。 制作表现：Prefab 模板 接下来我们还需要一个可以在运行时用来实例化每个物品的模板资源 —— Prefab 预制。这个 Prefab 的结构如下图所示： icon、name、price 子节点之后就会用来展示图标、物品名称和价格的数据。 模板组件绑定 您在拼装 Prefab 时可以根据自己的需要自由发挥，上图中展示的仅仅是一个结构的例子。有了物品的模板结构，接下来我们需要一个组件脚本来完成节点结构的绑定。新建一个 ItemTemplate.ts 的脚本，并将其添加到刚才制作的模板节点上。该脚本内容如下： @ccclass export class ItemTemplate extends Component { @property public id = 0; @property(Sprite) public icon: Sprite | null = null; @property(Label) public itemName: Label | null = null; @property(Label) public itemPrice: Label | null = null; } 接下来将对应的节点拖拽到该组件的各个属性上： 注意 id 这个属性我们会直接通过数据赋值，不需要绑定节点。 通过数据更新模板表现 接下来我们需要继续修改 ItemTemplate.ts，为其添加接受数据后进行处理的逻辑。在上述脚本后面加入以下内容： // data: { id, iconSF, itemName, itemPrice } init(data: Item) { this.id = data.id; this.icon.spriteFrame = data.iconSF; this.itemName.string = data.itemName; this.itemPrice.string = data.itemPrice; } init 方法接受一个数据对象，并使用这个对象里的数据更新各个负责表现组件的相应属性。现在我们可以将 Item 节点保存成一个 Prefab 了，这就是我们物品的模板。 根据数据生成列表内容 现在让我们回到 ItemList.ts 脚本，接下来要添加的是物品模板 Prefab 的引用，以及动态生成列表的逻辑。 //... @property(Prefab) itemPrefab: Prefab | null = null; onLoad () { for (let i = 0; i 在 onLoad 回调方法里，我们依次遍历 items 里存储的每个数据，以 itemPrefab 为模板生成新节点并添加到 ItemList.ts 所在节点上。之后调用 ItemTemplate.ts 里的 init 方法，更新每个节点的表现。 现在我们可以为 ItemList.ts 所在的节点添加一个 Layout 组件，通过 属性检查器 下方的 添加组件 -> UI -> Layout，然后设置 Layout 组件的以下属性： Type：HORIZONTAL Resize Mode：CONTAINER 别忘了把 item Prefab 拖拽到 ItemList 组件的 itemPrefab 属性里。您还可以为这个节点添加一个 Sprite 组件，作为列表的背景。 完成后的 itemList 节点属性如下： 预览效果 最后运行预览，可以看到类似这样的效果（具体效果和您制作的物品模板，以及输入的数据有关）： 注意前面步骤中添加 Layout 组件并不是必须的，Layout 能够帮助您自动排列列表中的节点元素，但您也可以用脚本程序来控制节点的排列。我们通常还会配合 ScrollView 滚动视图组件一起使用，以便在有限的空间内展示大量内容。可以配合 自动布局 和 滚动视图 一起学习。 "},"ui-system/components/engine/sliced-sprite.html":{"url":"ui-system/components/engine/sliced-sprite.html","title":"制作可任意拉伸的 UI 图像","keywords":"","body":"制作可任意拉伸的 UI 图像 UI 系统核心的设计原则是能够自动适应各种不同的设备屏幕尺寸，因此我们在制作 UI 时需要正确设置每个控件元素的尺寸（size），并且让每个控件元素的尺寸能够根据设备屏幕的尺寸进行自动的拉伸适配。为了实现这一点，就需要使用九宫格格式的图像来渲染这些元素。这样即使使用很小的原始图片也能生成覆盖整个屏幕的背景图像，一方面节约游戏包体空间，另一方面能够灵活适配不同的排版需要。 上图右边为原始贴图大小的显示，左边是选择 Sliced 模式并放大 size 属性后的显示效果。 编辑图像资源的九宫格切分 要使用可以无限放大的九宫格图像效果，我们需要先对图像资源进行九宫格切分。首先打开 Sprite 编辑器，在 资源管理器 中选中图像资源，然后点击 属性检查器 最下面的 编辑 按钮。如果您的窗口高度不够，可能需要向下滚动 属性检查器 才能看到下面的按钮。 打开 Sprite 编辑器 以后，可以看到图像周围有一圈绿色的线条，表示当前九宫格分割线的位置。将鼠标移动到分割线上，可以看到光标形状改变了，这时候就可以按下并拖拽鼠标来更改分割线的位置。 我们分别拖动上下左右四条分割线，将图像切分成九宫格，九个区域在 Sprite 尺寸（size）变化时会应用不同的缩放策略，见下图： 而下图中描述了不同区域缩放时的示意（图片来自 Yannick Loriot 的博客）： 完成切分后别忘记点击 Sprite 编辑器 右上角的绿色对勾来保存对资源的修改。 设置 Sprite 组件使用 Sliced 模式 准备好九宫格切分的资源后，就可以修改 Sprite 的显示模式并通过修改 size 来制作可任意指定尺寸的 UI 元素了。 首先选中场景中的 Sprite 节点，将 Sprite 的 Type 属性设为 Sliced。 然后通过 矩形变换工具 拖拽控制点使节点的 size 属性变大。您也可以直接在 属性检查器 中输入数值来修改 size 属性。如果图像资源是用九宫格的形式生产的，那么不管 Sprite 如何放大，都不会产生模糊或变形。 注意事项 在使用 矩形变换工具 或直接修改 Sliced Sprite 的 size 属性时，注意 size 的属性值不能为负数，否则不能以 Sliced 模式正常显示。 "},"animation/":{"url":"animation/","title":"动画系统","keywords":"","body":"动画系统 Cocos Creator 内置了通用的动画系统用以实现基于关键帧的动画。除了支持标准的位移、旋转、缩放动画和帧动画之外，还支持任意组件属性和用户自定义属性的驱动，再加上可任意编辑的时间曲线和创新的移动轨迹编辑功能，能够让内容生产人员不写一行代码就制作出细腻的各种动态效果。 注意：Cocos Creator 自带的动画编辑器适用于制作一些不太复杂的、需要与逻辑进行联动的动画，例如 UI 动画。如果要制作复杂的特效、角色动画、嵌套动画等，可以考虑改用 Spine、DragonBones 或者 3D 模型骨骼动画编辑器进行制作。 内容 动画剪辑（Animation Clip）：包含了动画数据的资源，可复用。动画剪辑可以通过 动画编辑器 产出，或者通过某些已经包含了骨骼动画的外部资源导入。 动画组件参考：动画组件可以以动画方式驱动所在节点和子节点上的节点/组件属性，包括用户自定义脚本中的属性。 使用动画编辑器：了解动画编辑器的使用，通过动画编辑器创建/修改/生成动画剪辑资源。 骨骼动画：常见但类型特殊的动画，本篇主要对其进行介绍及说明用法。 使用脚本控制动画：动画组件管理了一组动画状态，用于控制各动画的播放、暂停、继续、停止、切换等。 动画状态（Animation State）：动画剪辑的状态保存在称为动画状态的对象中，动画状态可以控制需要在对象上使用的动画剪辑。动画状态提供了更多动画控制接口，通过这些接口可以对动画进行播放、停止、变速、设置循环模式等更为细致的控制。 具体的动画实现根据不同的动画需求，操作步骤以及代码实现都不同，可参考官方范例 animation（GitHub | Gitee），主要介绍一些常见的编辑操作方法以及代码范例，以供参考。 "},"animation/animation-clip.html":{"url":"animation/animation-clip.html","title":"动画剪辑","keywords":"","body":"动画剪辑 动画剪辑（Animation Clip）是一份动画的声明数据，即包含动画数据的资源，是动画系统的核心之一。将动画剪辑挂载到 动画组件 上，就能够将这份动画数据应用到动画组件所在的节点上。 目前 Creator 支持从外部导入美术工具生产的骨骼动画资源，或者直接在 Creator 内部创建一个新的动画剪辑资源。 Creator 内部创建的动画 通过 动画编辑器 可以直接创建全新的动画剪辑，并进行编辑和预览，详情请参考 使用动画编辑器。 也可以通过脚本实现，详情请参考 使用动画曲线。 外部导入的骨骼动画 外部导入的动画大概包括以下几种： 第三方美术工具生产的骨骼动画； 模型导入后附带的骨骼动画。 带动画的模型导入后，会同时导入模型中包含的动画。这个动画和内部新建资源的使用方式是一样的，骨骼动画的裁剪可以参考 模型资源的动画模块介绍。 更多关于骨骼动画的设置等，详情请参考 骨骼动画。 注意：外部导入的骨骼动画不支持在 动画编辑器 中进行编辑，各节点也是锁住状态，只能在外部美术工具中进行编辑。 "},"animation/animation-comp.html":{"url":"animation/animation-comp.html","title":"动画组件参考","keywords":"","body":"动画组件参考 Animation（动画）组件可以以动画方式驱动所在节点和子节点上的节点和组件属性，包括用户自定义脚本中的属性。 添加动画组件有三种方式： 在 动画编辑器 中添加动画组件，详情请参考 创建 Animation 组件和动画剪辑。 在 层级管理器 中选中需要添加动画的节点，然后在 属性检查器 中选择 添加组件 -> Animation -> Animation 来添加一个动画组件到节点上。 通过脚本添加，详情请参考 使用脚本控制动画。 动画组件属性 属性 功能说明 Clips 添加的动画剪辑资源，默认为空，支持添加多个。在这里添加的 AnimationClip 可以直接在 动画编辑器 中进行编辑。 DefaultClip 默认的动画剪辑，若该项在挂载了动画剪辑的同时，还勾选了下方的 PlayOnLoad 属性，那么动画便会在加载完成后自动播放 Default Clip 的内容。 PlayOnLoad 布尔类型。若勾选该项，则动画加载完成后会自动播放 Default Clip 的内容。 说明 如果一个动画需要包含多个节点，那么一般会新建一个节点作为动画的 根节点，再将动画组件挂载到根节点上，则这个根节点下的其他子节点都会自动进入到这个动画剪辑中，并显示在 动画编辑器 的 节点列表 区域。详情可参考 熟悉动画编辑器 — 节点列表。 Animation 组件也提供了一些常用的动画控制函数，若要通过脚本程序化控制动画，请参考 使用脚本控制动画。 "},"animation/animation.html":{"url":"animation/animation.html","title":"使用动画编辑器","keywords":"","body":"动画编辑器 Creator 支持在 动画编辑器 中直接创建、编辑和预览动画剪辑，除了可以对节点基本属性进行动画化，还支持对材质和部分组件的属性进行动画化，并且可以通过调用 动画事件 的事件函数来充实动画剪辑。 在使用 动画编辑器 制作动画之前需要先为节点添加 动画组件，并为动画组件挂载 动画剪辑 后才可以进行编辑。详情请参考 创建 Animation 组件和动画剪辑。 动画编辑模式 只有在 动画编辑模式 下才可以编辑动画剪辑中的动画数据。在动画编辑模式下，无法对节点进行添加/删除/重命名等操作，并且没有记录在动画关键帧内的属性修改，在退出动画编辑模式后也会被还原。 当处于动画编辑模式时，不参与动画数据编辑的节点在 层级管理器 中为置灰状态。在 动画编辑器 中选中节点时，层级管理器 中也会相应地跳转到对应的节点，反之亦然。 打开编辑模式包括以下两种方式： 在 层级管理器 中选中一个带有 Animation 组件，并且组件中包含一个以上 clip 文件的节点，然后在 动画编辑器 中点击 进入动画编辑模式 按钮。 快捷键 Ctrl/Cmd + E 保存编辑后的动画数据包括以下三种方式： 点击 动画编辑器 右上角的 保存按钮 点击 场景编辑器 左上角的 保存 按钮 快捷键 Ctrl/Cmd + S 退出编辑模式包括以下三种方式： 点击 动画编辑器 右上角的 退出按钮 点击 场景编辑器 左上角的 关闭 按钮 快捷键 Ctrl/Cmd + E "},"animation/animation-create.html":{"url":"animation/animation-create.html","title":"创建 Animation 组件和动画剪辑","keywords":"","body":"创建动画组件和动画剪辑 在使用 动画编辑器 制作动画之前需要先在 层级管理器 或者 场景编辑器 中选择要添加动画的节点，然后添加 动画组件，并在组件上挂载 动画剪辑（Animation Clip），便可以编辑动画数据，编辑后的动画数据会保存在当前的动画剪辑中。没有挂载 Clip 的节点是无法编辑动画数据的。 如果当前选中节点没有动画组件，则 动画编辑器 的界面上会显示 添加 Animation 组件 按钮，点击即可在 属性检查器 上添加 动画组件。 继续点击 动画编辑器 中的 新建 AnimationClip 文件 按钮并命名（例如 animation）： 便可在 资源管理器 中自动创建一个动画剪辑（animation.anim）并挂载到 Animation 组件的 DefaultClip 属性上： 以上简单介绍了如何在 动画编辑器 中创建动画组件和动画剪辑，更多关于动画组件的创建和属性说明请参考 动画组件参考。更多创建动画剪辑的方法请参考文末部分的内容。 然后继续点击 进入动画编辑模式 即可开始 编辑动画剪辑。新建的空的动画剪辑在动画编辑器中显示如下： 挂载新动画剪辑 一个 Animation 组件可以挂载多份动画剪辑，若需要额外在已有动画剪辑的对象上创建并挂载新的动画剪辑，有以下几种方式： 在 资源管理器 中点击左上方的 + 按钮，或者右键点击空白区域，然后选择 Animation Clip，这时候会在 资源管理器 中生成一个动画剪辑文件（默认名为 animation）。 然后在 层级管理器 中选中对应节点，在 属性检查器 中找到 Animation 组件（cc.Animation），修改 Clips 属性的数值。例如原本只挂载了一个 clip 文件，现在想要再添加一个，那么就将原本的 1 改成 2。 最后将刚刚在 资源管理器 中创建的动画剪辑，拖拽到上图中的 cc.AnimationClip 选择框中即可。 在 属性检查器 中找到 Animation 组件（cc.Animation），修改 Clips 属性的数值。 然后点击新出现的空的 cc.AnimationClip 选择框后面的查找按钮，在弹出的搜索窗口中点击右上方的 创建 按钮，即可自动在 资源管理器 中创建动画剪辑并挂载到 cc.AnimationClip 选择框中。 通过脚本动态创建动画剪辑，详情请参考 使用动画曲线。 可以在 动画编辑器 左上角的 Clips 下拉列表切换需要编辑的动画剪辑。 "},"animation/animation-editor.html":{"url":"animation/animation-editor.html","title":"动画编辑器面板介绍","keywords":"","body":"熟悉动画编辑器 动画编辑器 面板用于编辑和预览当前所选节点的动画剪辑。编辑动画数据或者相关属性时，鼠标焦点离开后会立即生效。 Cocos Creator 的默认布局中已经包含了 动画编辑器，也可以通过点击编辑器上方主菜单的 面板 -> 动画 -> 动画编辑器 打开 动画编辑器。 面板介绍 动画编辑器 面板可以划分为以下几个主要部分： 菜单工具栏：放置一些常用的功能按钮，例如播放/暂停/停止动画、添加事件帧、保存动画、退出编辑等。 节点列表：用于显示/设置当前选中节点及其子节点。 动画时间轴与关键帧预览：用于显示/设置当前节点（及其子节点）添加的事件帧以及所添加的动画属性上所有关键帧的预览。 动画属性列表：用于显示/设置当前选中的节点在当前编辑的动画剪辑中包含的所有动画属性。 动画属性关键帧预览：用于显示/设置当前选中节点的各动画属性上的所有关键帧。 设置当前动画剪辑的相关属性：用于设置当前动画剪辑的播放模式、播放速度等。 更多具体内容请参考下文介绍。 1. 菜单工具栏 菜单工具栏 中的功能按钮从左到右依次为： 图标 功能说明 快捷键 切换动画剪辑。当动画组件上挂载了多个动画剪辑时，可通过该按钮切换进行编辑。 - 将红色的时间控制线移动到当前动画剪辑的开头 Ctrl/Cmd + ← 将时间控制线移动到上一帧 ← 播放/暂停当前动画 Ctrl/Cmd + P 将时间控制线移动到下一帧 → 将时间控制线移动到当前动画剪辑的结尾 Ctrl/Cmd + → 点击停止当前动画，停止后时间控制线将会移动到第一帧 Ctrl/Cmd + S 时间轴的刻度单位显示方式，包括三种：时间：0-00帧：0时间（s）：0 s详情可参考下文 时间轴的刻度单位显示 部分的内容。 - 用于设置同时生成多个关键帧时，关键帧之间的间隔大小。 - 间隔排列同时选中的多个关键帧。选中的关键帧将会以第一个帧为基准，以 Spacing 输入框中的数值作为间隔大小依次排列 - 添加事件帧，点击该按钮即可在当前时间线上方的位置添加事件帧 - 保存当前编辑的动画数据。 - 点击该按钮即可跳转到官方手册文档关于动画编辑器部分的内容 Ctrl/Cmd + S 打开快捷键面板，支持自定义快捷键。详情可参考下文 快捷键 部分的内容 - 退出动画编辑模式 Ctrl + Q 2. 节点列表 该区域会显示当前选中的动画节点及其子节点，并以与 层级管理器 中的节点树一一对应的方式排列。可点击上方的 按钮来隐藏/显示无动画数据的节点，或者直接在输入框中输入节点名称来快速查找节点。 目前支持右键点击节点来选择清空节点数据、迁移节点数据、复制粘贴节点数据。具体内容请参考 节点数据常见操作。 3. 动画时间轴与关键帧预览 动画时间轴主要用于显示/设置当前节点添加的自定义 事件帧、节点（及其子节点）添加的所有动画属性上的 关键帧（蓝色菱形）并显示预览。 时间控制线（红色竖线）表示当前动画所处的时间节点，可通过以下几种方式更改当前选中时间： 直接拖拽时间控制线 双击关键帧 在菜单工具栏中使用相关移动控制按钮 使用快捷键，具体控制键可查询下文 快捷键 部分的内容 在动画时间轴上方区域内点击任意位置 移动时间控制线则 场景编辑器 中的节点也会根据动画轨迹进行相应的移动。 时间轴的刻度单位显示 菜单工具栏 中的 按钮可用于切换动画时间轴的刻度显示方式。输入框中的数值会随着时间控制线的移动而变化，支持手动输入，输入完成后时间控制线会自动定位到相应的位置。 目前支持以下三种显示方式： 时间：0-00（默认）：以秒和帧组合为单位的方式来显示动画时间轴的刻度。输入框前面的数值表示 秒，后面的数值表示 帧，例如 01-05 表示 1 秒又 5 帧。 帧：0：以帧为单位的方式来显示动画时间轴的刻度。 时间（s）：0 s：以秒为单位的方式来显示动画时间轴的刻度。 我们一般用帧率（Sample）来表示一秒要划分为多少帧，可以在 动画编辑器 底部的 Sample 选项中进行调整。当时间轴的刻度单位显示方式不同时，受影响程度也不同。 当刻度单位设置为 帧 时，以帧数为单位，不受帧率影响。 当设置为 时间 或者 时间（s） 时，同一个刻度表示的时间点会随着帧率的变化而有所不同，这两者之间的转换计算方式如下： 帧率（Sample） 时间：00-00 时间（s）：0 s 30 01-05 1 + 5/30 = 1.17 s 10 01-05 1 + 5/10 = 1.5 s 例如将帧率设置为 30，在 01-05 刻度上添加了一个关键帧，则该关键帧位于动画开始后的第 35 帧。然后把帧率修改为 10，该关键帧所在的总帧数并没有发生变化，仍然处在动画开始后的第 35 帧，而此时关键帧所在位置的刻度读数变成了 03-05，换算成时间（s）以后正好是之前的 3 倍。 更改动画时间轴缩放比例 在操作中如果觉得 动画编辑器 显示的范围太小，需要按比例缩小，让更多的关键帧显示到编辑器内怎么办？ 在 动画时间轴 和 动画属性关键帧预览 任一区域内滚动鼠标滚轮，即可放大或者缩小时间轴的显示比例。 移动动画时间轴显示区域 在 动画时间轴 或者 动画属性关键帧预览 任一区域按下鼠标中键/右键进行拖拽，即可查看动画时间轴左/右侧超出显示区域而被隐藏的关键帧。 4. 动画属性列表 该区域主要用于显示/添加/设置当前选中的节点在当前动画剪辑中的动画属性。点击右上角的 + 按钮即可添加动画属性，动画属性包括了节点自有的属性、组件属性（包含用户自定义脚本组件中的属性）。组件包含的属性前会加上组件的名字，比如 cc.Sprite.spriteFrame。 右键点击动画属性或者单击动画属性右侧的 按钮即可选择 移除当前属性轨道、清空关键帧，或者 复制粘贴当前属性轨道。具体内容请参考 动画属性数据常见操作。 5. 动画属性关键帧预览 该区域主要用于显示当前选中节点在各动画属性上具体的关键帧设置情况，也是关键帧编辑的主要区域。可以直接在右侧的动画属性上点击右键来添加关键帧。同时在该区域也支持框选、点选关键帧来进行移动、复制、粘贴等操作。详情请参考 关键帧常见操作。 单击选中某一关键帧，关键帧会由蓝色变成白色并且该区域上方会显示当前关键帧的相关信息，若双击关键帧还会将时间控制线移动到当前关键帧所在位置。 6. 设置当前动画剪辑的相关属性 当前动画剪辑在动画编辑器上可直接设置的属性包括：WrapMode、Sample、Speed 和 Duration。具体内容请参考 动画剪辑属性设置。 调整动画编辑器布局 节点列表与时间轴之间的分界线，以及属性列表与时间轴之间的分界线都是可以用于拖拽更改布局的，通过拖拽可以自由地将 动画编辑器 调整成适合编辑的布局效果。 快捷键 点击菜单工具栏的 按钮，即可打开快捷键面板： 支持开发者自定义 动画编辑器 的快捷键，直接点击要修改的功能的快捷键组合，会出现如下图所示的提示，即可直接修改快捷键。 默认快捷键汇总 功能 快捷键 说明 进入/退出动画编辑器 Ctrl/Cmd + E - 保存动画数据 Ctrl/Cmd + S - 向前移动一帧 ← 如果已经在第 0 帧，则忽略当前操作。未选中关键帧时移动的是时间控制线，选中关键帧时移动的是关键帧 向后移动一帧 → 未选中关键帧时移动的是时间控制线，选中关键帧后移动的是关键帧 移动到第一帧 Ctrl/Cmd + ← 将红色的时间控制线移动到当前动画剪辑的开头 移动到最后一帧 Ctrl/Cmd + → 将时间控制线移动到当前动画剪辑的结尾 删除当前选中关键帧 Delete / Cmd + Backspace - 播放/暂停动画 P - 停止动画 Alt + S 当前时间将变为 0，且时间控制线将会移动到第一帧 添加关键帧 K 选中任一动画属性后，将会在时间控制线所在位置添加关键帧，没有选中动画属性则忽略 跳到上一个关键帧 Ctrl/Cmd + Shift + ← 将时间控制线移动到左侧最近的一个关键帧（在选中的属性轨道上或选中的节点上） 跳到下一个关键帧 Ctrl/Cmd + Shift + → 将时间控制线移动到右侧最近的一个关键帧（选中的属性轨道上或选中的节点上） 多选关键帧 Ctrl 按住 Ctrl 点击关键帧可多选关键帧 全选动画属性关键帧 Ctrl/Cmd + A 全选选中的动画属性上的所有关键帧 复制选中的动画数据 Ctrl/Cmd + C 支持复制选中的关键帧、属性轨道、节点数据，同时只能复制一种数据，且按照这个顺序来决定复制优先级 粘贴上一次复制的动画数据 Ctrl/Cmd + V 支持跨编辑器（限 v3.x）粘贴上一次复制的动画数据（例如动画关键帧数、动画属性、动画节点数据，并按照该排序依次检查当前可粘贴的数据）。 取消选中的关键帧/事件帧/属性轨道 Esc - 注意：目前除了 进入/退出动画编辑器、保存动画 的快捷键是全局可用以外，其他快捷键都需要鼠标焦点在动画编辑器面板时才生效。 "},"animation/edit-animation-clip.html":{"url":"animation/edit-animation-clip.html","title":"编辑动画剪辑","keywords":"","body":"编辑动画剪辑 在节点的动画组件上挂载了动画剪辑后，点击 进入动画编辑模式 或者使用快捷键 Ctrl/Cmd + E 进入动画编辑模式，便可以在动画剪辑中添加关键帧数据，以此实现节点的动画化。在编辑动画剪辑之前请先 熟悉动画编辑器。 一个动画剪辑内可能包含了多个节点（节点及其子节点），每个节点上可挂载多个动画属性。通过对节点进行移动、旋转、缩放等操作，便会在当前选中节点相对应的动画属性上添加关键帧，动画属性上添加的所有关键帧在对应的动画属性中显示为线性轨迹的清单模式，我们可以称之为动画曲线。 创建动画曲线 在添加关键帧之前需要先了解一下动画属性，动画属性包括了节点自有的 position、rotation、scale 等属性，也包含了组件 Component 中自定义的属性。组件包含的属性前会加上组件的名字，比如 cc.Sprite.spriteFrame。 点击 属性列表 区域右上角的 + 按钮即可根据需要添加动画属性，根据节点类型的不同，可添加的动画属性也有所不同。已添加的动画属性则为置灰状态，不可重复添加。 添加了动画属性后便可以在右侧的属性轨道上添加关键帧了。当节点及其动画属性在列表中显示为蓝色时，表示确定该节点的属性为当前创建关键帧的目标对象。然后在 动画编辑器 / 属性检查器 / 场景编辑器 中修改对应属性时，便会在动画属性右侧时间轴的时间控制线所在位置上生成一个蓝色实心的菱形，便是关键帧。（也可以通过该方法修改选中的关键帧数据） 更多关于动画曲线的设计以及如何通过脚本代码控制，请参考 使用动画曲线。 编辑 Sprite 动画 接下来我们以创建 Sprite 动画为例，来看一下具体的操作流程。 创建 Sprite 节点 在 层级管理器 中创建一个 Sprite 节点。或者在节点上添加 Sprite 组件，选中节点后在 属性检查器 中点击 添加组件 按钮，选择 2D -> Sprite 即可。 在节点上添加 Animation 组件，并挂载 Clip 文件，然后进入动画编辑模式。详情可参考 创建 Animation 组件和动画剪辑。 在属性列表中添加 cc.Sprite.spriteFrame 动画属性 点击属性列表右上角的 + 按钮，然后选择 cc.Sprite -> spriteFrame 即可添加一个 cc.Sprite.spriteFrame 动画属性。 添加关键帧 从 资源管理器 中将 spriteFrame 资源拖拽到 cc.Sprite.spriteFrame 动画属性右侧的属性轨道上，再将下一关键帧需要显示的 spriteFrame 拖到指定位置，或者在属性轨道上方的属性框中选择所需的 spriteFrame。然后点击播放就可以预览刚刚创建的动画了。 关键帧常见操作 在编辑动画剪辑的过程中，经常会有一些对关键帧的操作处理，这里集合了动画编辑器中对关键帧的各种操作方法，了解这些方法技巧可以更快更方便地编辑动画剪辑。 选中关键帧 选中的关键帧会由蓝色变成白色，包括以下几种： 单击动画属性轨道上的关键帧即可选中 双击关键帧则会在选中关键帧的同时将时间控制线移动到当前关键帧所在位置 单击节点在动画时间轴中的关键帧，即可同时选中节点的各动画属性在同一位置上的所有关键帧。 同时也支持多选关键帧，包括以下几种方式： 按住 Ctrl 的同时点击多个关键帧 通过框选的方式选择多个连续的关键帧，方框左右两侧会分别显示首尾关键帧在动画时间轴中的帧数。 选中任一属性轨道 后，按下 Ctrl/Cmd + A 即可全选当前动画属性轨道上的所有关键帧。 添加关键帧 除了 创建动画曲线 中介绍的通过修改属性的方式来添加关键帧，还可以通过以下几种方式添加： 选中动画属性，使用快捷键 K，将会在在时间控制线所在位置添加关键帧，若没有选中动画属性则忽略。 移动时间控制线到需要添加关键帧的位置，点击动画属性右侧的 按钮即可在当前动画属性轨道上添加关键帧。 右键点击动画属性轨道中需要添加关键帧的位置，然后在弹出的菜单中选择 添加关键帧 即可，菜单上同时也会显示当前添加关键帧位置的帧数。 将动画属性对应的资源批量从 资源管理器 拖拽到属性轨道上时，将会按照工具栏中 设置的数值为间隔大小，以资源被选中的顺序依次排列添加关键帧。 移除关键帧 选中需要删除的关键帧（可多选），按下 Delete 键（Windows）或者 Cmd + Backspace（macOS）即可。 选中需要删除的关键帧（可多选），然后点击右键，在弹出的菜单中选择 移除关键帧 即可。 拖动时间控制线到需要移除的关键帧的位置或者直接 双击 关键帧，然后在动画属性列表中点击对应轨道右侧的 按钮即可。 移动关键帧 在选中关键帧的同时拖动，即可将关键帧移动到想要的位置。 当拖动单个关键帧时，关键帧下方会出现一个白色小方框，显示移动过程中的帧数以及移动的距离。 当拖动多个关键帧时，方框左右两侧会分别显示移动过程中首尾关键帧在动画时间轴中的帧数。 缩放关键帧 当选中多个关键帧时，首尾关键帧会显示两条控制辅助杆，拖动任意一个控制杆移动即可对选中的关键帧进行整体缩放。 间隔排列关键帧 选中多个关键帧后，点击上方菜单栏中的 间隔排列关键帧按钮，选中的关键帧便会以第一个关键帧为基准，以 输入框中设置的数值为间隔帧数依次排列。 复制/粘贴关键帧 关键帧数据的复制和粘贴，支持跨节点、跨 Clip 使用。包括以下两种使用方式： 选中关键帧后（可多选），使用快捷键 Ctrl + C 和 Ctrl + V 即可进行复制粘贴。需要注意的是快捷键粘贴的位置将会以当前时间控制线所在的位置为起点。 选中关键帧后（可多选），右键点击（任一）关键帧，在弹出的菜单中选择 复制关键帧，然后在目标动画属性轨道上点击右键，选择 粘贴关键帧 即可在当前动画属性轨道上粘贴关键帧。 以上两种粘贴方式在复制粘贴多个属性轨道数据时有所差异，区别主要在于： 使用快捷键粘贴关键帧数据时，将会在复制关键帧的动画属性轨道上按照复制的关键帧顺序一一粘贴。 在目标属性轨道上点击右键选择粘贴时，只有目标属性轨道上会被粘贴上复制的数据。 分量属性轨道（例如动画属性轨道 position 下的 x、y、z 属性轨道）作为单独的属性轨道也会遵循这个规则。如果在主轨道（例如动画属性轨道 position）上复制了关键帧数据后，在目标分量轨道上点击右键进行粘贴，那么只有目标分量轨道才会粘贴上关键帧数据。请务必根据实际需要粘贴的位置来复制对应数据，以免产生预期之外的结果。 节点数据常见操作 动画剪辑通过节点的名字定义动画数据的位置，本身忽略了根节点，其余的子节点通过与根节点的相对路径索引找到对应的数据。 目前支持在 动画编辑器 的 节点列表 区域右键点击节点来选择清空节点数据、迁移节点数据，以及复制粘贴节点数据。 清空节点数据 右键点击需要清空所有动画数据（关键帧）的节点，然后选择 清空数据，在弹出的窗口中点击 清除 即可。 迁移节点数据 右键点击需要迁移所有动画数据的节点，然后选择 迁移数据，节点便会显示动态的虚线外框，当鼠标移动到其他节点时，便会显示“迁移数据到该节点”的提示，单击后在弹出的窗口选择 迁移 即可，若不需要迁移则选择 取消 即可。 注意：节点数据迁移默认会覆盖原节点上的数据 因为动画剪辑会记录所有参与动画数据编辑的节点路径信息，所以当节点信息发生变化（例如节点重命名/删除/移动位置），与原本保存在动画剪辑中的不一致时，动画编辑器 便会将其在节点列表中显示为黄色的不可编辑的丢失状态，关键帧也是置灰的不可编辑状态。此时便可以通过节点的 迁移数据 功能将丢失节点的动画数据迁移到其他节点上。 复制粘贴节点数据 节点动画数据的复制和粘贴，支持跨编辑器（v3.x）使用。 复制：在节点列表中选中要复制数据的节点，点击右键并选择 复制数据，或者直接使用快捷键 Ctrl/Cmd + C 即可。 粘贴：在节点列表中选中要粘贴动画数据的目标节点，点击右键并选择 粘贴数据，或者直接使用快捷键 Ctrl/Cmd + V 即可。 注意：粘贴功能不支持自动创建动画属性，因此复制和粘贴的节点至少要有一个相同的动画属性，如果没有，请预先创建。当在同一个节点上粘贴多个节点的动画数据时，重叠部分的动画数据会被后者覆盖，差异部分则会互相融合。 编辑同名子节点数据 在父节点的动画剪辑中编辑动画数据时也可以对子节点进行动画编辑，动画数据都会保存到父节点的动画剪辑中，用于实现类似人物模型的手以不同的速度跟随身体一起移动等效果。但若父节点下同时包含多个同名子节点，只支持对第一个同名子节点进行编辑，其他的同名字节点会置灰为不可编辑状态。 但分别为同名子节点添加动画组件和动画剪辑并单独进行编辑是支持的。 动画属性数据常见操作 右键点击动画属性或者单击轨道右侧的 按钮即可选择 移除当前属性轨道、清空关键帧，或者 复制粘贴当前属性轨道。 移除当前动画属性：移除当前选中的动画属性，包括该轨道上的所有关键帧。或者也可以使用快捷键 Delete 键（Windows）或者 Cmd + Backspace（macOS）。 清空关键帧数据：删除当前选中的动画属性上的所有关键帧 复制/粘贴当前动画属性：复制当前选中的动画属性上的所有动画数据，并粘贴到目标动画属性上，支持使用快捷键 Ctrl/Cmd + C 和 Ctrl/Cmd + V。粘贴时，重叠部分的关键帧会被后者覆盖，差异部分则会互相融合。 目前支持在不同编辑器（v3.x）之间复制/粘贴动画属性数据。动画数据的复制粘贴仅支持 ccType 同类型数据。 与节点一样，动画属性也存在丢失的可能。例如在 属性检查器 中移除了与动画属性对应的属性，则在动画属性列表中便会将其显示为黄色的不可编辑的丢失状态，关键帧也是置灰的不可编辑状态。在这种情况下可以退出编辑模式后为对应节点添加相关属性或是直接移除该丢失的属性轨道。 动画剪辑属性设置 当前动画剪辑在 动画编辑器 上可直接设置的属性包括：WrapMode、Sample、Speed 和 Duration。 WrapMode：用于设置当前动画剪辑播放的循环模式，目前包括： Default：效果与 Normal 一致 Normal：正向单次播放 Loop：循环正向播放 PingPong：以先正向播放再逆向播放的方式循环播放 Reverse：反向单次播放 LoopReverse：循环反向播放 更多关于如何通过脚本代码设置循环模式，请参考 循环模式。 Sample：定义当前动画数据每秒的帧率，也就是一秒要划分为多少帧，默认为 60。详情请参考上文 时间轴的刻度单位显示 部分的内容。 Speed：用于设置当前动画的播放速度，默认为 1，值越小播放速度越慢。 Duration：前面的数字表示当动画播放速度为 1 的时候，动画的持续时间，根据最后一个关键帧所在位置决定。后面括号中的数字表示实际运行的持续时间，当调整 Speed 时，会随之变化。 动画剪辑是可以复用的，其状态保存在称为动画状态的对象中，通过动画状态的接口我们可以对动画进行播放、暂停、停止、变速等控制。详情请参考 动画状态。 "},"animation/animation-curve.html":{"url":"animation/animation-curve.html","title":"编辑动画缓动曲线","keywords":"","body":"编辑动画缓动曲线 在创建了基本的动画剪辑之后，有时候会需要在两个关键帧之间实现 EaseInOut 等缓动效果，那么在 动画编辑器 中如何实现呢？ 首先需要添加一条动画属性轨道，并在轨道上创建两个不相等的关键帧。例如在动画属性 position 的轨道上创建两个关键帧，从 (0, 0, 0) 到 (100, 100, 100)，此时两个关键帧之间会出现一条蓝色的连接线，双击连接线，即可打开曲线编辑器，面板默认设置如下所示： 动画曲线的修改都是实时的，无需点击保存，修改完点击右上角的关闭按钮即可。 使用预设缓动曲线 缓动曲线编辑器在左上角的预设菜单中按照 Linear、Static、Ease In、Ease Out、Ease In Out、User 对预设的缓动效果做了分类，每种分类下都有若干对应类型的缓动曲线预设。其中 User 是自定义的曲线预设类别，用于存储自定义的一些曲线效果，详情可参考下文 自定义缓动曲线 部分的内容。 点击左侧预设的曲线即可直接应用到当前的动画曲线上，而左侧被使用的预设会有金黄色边框的选中效果。 自定义缓动曲线 若预设的缓动曲线无法满足动画需求，可以直接在右侧的曲线预览区域修改缓动曲线。 在曲线编辑器的预览曲线图中有两个灰色的控制点，拖拽控制点即可更改曲线轨迹。如果控制点需要超出视野外，可以通过鼠标滚轮缩放预览图。 修改过程中的曲线数据会实时地显示在曲线预览区域左上角的输入框中，同时还支持在输入框 手动输入曲线数据以生成曲线。曲线数据的格式必须是 由四个数字组成并用逗号隔开，否则无法正常应用。 保存自定义曲线 若自定义的曲线数据需要保存以便复用，可以将其保存在 User 的预设库中。 自定义的曲线编辑完成后，在左上方的预设菜单中选择 User，然后在下方的输入框中输入希望保存的曲线数据名称，点击 Add 按钮即可将自定义曲线保存到 User 的预设库中。 注意：同名曲线会做覆盖处理，自定义曲线的保存是无法撤销的，所以如果被覆盖了就需要再重新添加。 保存在 User 预设库中的自定义曲线，和其他库的预设曲线一样，点击即可直接应用。同时，当鼠标移动到自定义曲线，右下角会出现一个删除的图标按钮，点击即可删除对应的缓动曲线数据。 "},"animation/animation-event.html":{"url":"animation/animation-event.html","title":"添加动画事件","keywords":"","body":"添加动画事件 通过在动画时间轴的指定帧调用 动画事件 函数可以更好地充实动画剪辑。在动画时间轴某一帧上添加 事件帧 后，动画系统将会在动画执行到该帧时，根据事件帧中设置的触发函数名称去匹配动画根节点中对应的函数方法并执行。 若要通过脚本添加动画事件，详情请参考 帧事件。 添加事件帧 在 动画编辑器 中添加事件帧包括以下两种方式： 将时间控制线拖动到需要添加事件帧的位置，然后点击 菜单工具栏 中的 按钮，即可在 动画时间轴 上方添加事件帧。 在动画时间轴上方区域点击右键，然后选择 新建事件帧 即可。 事件帧添加完成后，将鼠标移动到事件帧，颜色会从白色变成黄色。右键点击事件帧即可执行 编辑、删除、复制粘贴 等操作。同时也支持批量操作事件帧，在按住 Ctrl 的同时点击多个事件帧即可。 编辑：用于打开事件编辑器，添加事件函数 删除：用于删除事件帧 复制/粘贴：事件帧数据的复制和粘贴，支持跨编辑器（v3.x）使用。 编辑事件帧 右键点击添加的事件帧并选择 编辑 或者直接双击，即可打开事件编辑器。在事件编辑器中可以手动输入需要触发的事件函数名称，触发时会根据这个函数名，去动画根节点的各个组件内匹配相应的函数方法，并对其进行调用，传入参数。 1 — 用于添加新的触发函数 2 — 用于保存事件函数 3 — 填写需要触发的函数名称 4 — 用于删除当前事件函数 5 — 用于添加传入的参数，目前支持 String、Number、Boolean 三种类型 1 — 用于添加传入的参数，可根据需要选择参数类型 2 — 用于删除下方所有已添加的传入参数 3 — 当鼠标移动到某一参数上时，便会出现该按钮，点击即可删除当前选中的参数 删除事件帧 在动画时间轴上方右键点击已经添加的事件帧（可多选），然后选择 删除 或者使用快捷键 Delete 即可删除该事件帧及所有的事件函数。 复制粘贴事件帧 事件帧及其事件函数的复制和粘贴，支持跨编辑器（v3.x）使用。复制粘贴包括以下两种使用方式： 选中事件帧后（可多选），使用快捷键 Ctrl + C 和 Ctrl + V 即可进行复制粘贴。需要注意的是快捷键粘贴的位置将会以当前时间控制线所在的位置为起点。 选中事件帧后（可多选），右键点击（任一）事件帧，在弹出的菜单中选择 复制，然后在动画时间轴上方点击右键，选择 粘贴事件帧 即可。 "},"animation/use-animation-curve.html":{"url":"animation/use-animation-curve.html","title":"使用动画曲线","keywords":"","body":"使用动画曲线 动画剪辑中某一节点的某一动画属性上添加的所有关键帧，在对应的动画属性轨道中显示为线性轨迹，便是动画曲线。也就是说动画曲线描述了某一对象上某一动画属性随着时间推移而发生的变化。 动画曲线在内部存储了一系列时间点，每个时间点都对应着一个（曲线）值，称为一帧（关键帧）。当动画系统运行时，动画组件会根据当前动画状态计算出指定时间点应有的（结果）值并赋值给对象，完成属性变化，这一计算过程称为采样。 以下代码片段演示了如何程序化地创建动画剪辑： import { AnimationClip, animation, js } from 'cc'; const animationClip = new AnimationClip(); animationClip.duration = 1.0; // 整个动画剪辑的周期，任何关键帧的帧时间都不应该大于此属性 animationClip.keys = [ [ 0.3, 0.6, 0.9 ] ]; // 该动画剪辑所有曲线共享的帧时间 animationClip.curves = [{ // 动画组件上的动画曲线 modifiers: [ // 从当前节点对象寻址到目标对象。具体可查看下文“目标对象”部分的内容 // 目标对象为当前节点的 “Body” 子节点 new animation.HierarchyPath('Body'), // “Body” 子节点上的 “MyComponent” 组件 new animation.ComponentPath(js.getClassName(MyComponent)), // “MyComponent” 组件上的 “value” 属性 'value', ], data: { // 索引至 ‘animationClip.keys’，即 [ 0.3, 0.6, 0.9 ] keys: 0, // 关键帧数据 values: [ 0.0, 0.5, 1.0 ], }, }]; 上述动画剪辑包含了一条动画曲线，用于控制 Body 子节点中 MyComponent 组件的 value 属性。该动画曲线包括三个关键帧，使 value 属性在 0.3 秒时变为 0.0，在 0.6 秒时变为 0.5，在 0.9 秒时变为 1.0。 注意：动画曲线上关键帧的帧时间是以引用方式索引到 AnimationClip.keys 数组中的。如此一来，多条曲线可以共享帧时间，这将带来额外的性能优化。 目标对象（modifiers） 动画曲线的目标可以是任意 JavaScript 对象。modifiers 字段指定了在 运行时 如何从当前节点对象寻址到目标对象。 modifiers 是一个数组，它的每一个元素都表达了如何从上一级的对象寻址到另一个对象，最后一个元素寻址到的对象就作为曲线的目标对象。这种行为就好像文件系统的路径，因此每个元素都被称为“目标路径”。 当目标路径是 string 或者 number 时，表示寻址到上一级对象的属性，其本身就指定了属性名。否则，目标路径必须是实现接口 animation.TargetPath 的对象。 Cocos Creator 内置了以下几个实现自接口 animation.TargetPath 的类： animation.HierarchyPath 将上一级的对象视为节点，并寻址到它的某个子节点 animation.ComponentPath 将上一级的对象视为节点，并寻址到它的某个组件 目标路径可以任意组合，只要它们具有正确的含义： // 目标对象是 modifiers: [ // \"nested_1\" 子节点的 \"nested_2\" 子节点的 \"nested_3\" 子节点上的 new animation.HierarchyPath('nested_1/nested_2/nested_3'), // “BlahBlahComponent” 组件的 new animation.ComponentPath(js.getClassName(BlahBlahComponent)), // “names” 属性的 'names', // 第一个元素 0, ] 当目标对象不是一个属性，而是必须从一个方法返回时，自定义目标路径就很有用： class BlahBlahComponent extends Component { public getName(index: number) { return _names[index]; } private _names: string[] = []; } // 目标对象是 modifiers: [ // \"nested_1\" 子节点的 \"nested_2\" 子节点的 \"nested_3\" 子节点上的 new animation.HierarchyPath('nested_1/nested_2/nested_3'), // BlahBlahComponent 组件的 new animation.ComponentPath(js.getClassName(BlahBlahComponent)), // 第一个 \"name\" { get: (target: BlahBlahComponent) => target.getName(0), }, ] 如果希望自定义目标路径是可序列化的，可以将它们声明为类： @ccclass class MyPath implements animation.TargetPath { @property public index = 0; constructor(index: number) { this.index = index; } get (target: BlahBlahComponent) { return target.getName(this.index); } } // 目标对象是 modifiers: [ // \"nested_1\" 子节点的 \"nested_2\" 子节点的 \"nested_3\" 子节点的 new animation.HierarchyPath('nested_1/nested_2/nested_3'), // BlahBlahComponent 组件的 new animation.ComponentPath(js.getClassName(BlahBlahComponent)), // 第一个 \"name\" new MyPath(0), ] 目标对象的寻址是在运行时完成的，这种特性使得动画剪辑可以复用到多个对象上。 赋值 当采样出值后，默认情况下将使用赋值操作符 = 将值设置给目标对象。 然而有时候，并不能用赋值操作符来完成设置。例如，当想要设置材质对象的 Uniform 时，就无法通过赋值操作符来完成。因为材质对象仅提供了 setUniform(uniformName, value) 方法来改变 Uniform。对于这种情况，曲线字段 valueAdapter 提供了一种机制，可以自定义将值设置到目标对象。 示例： class BlahBlahComponent { public setUniform(index: number, value: number) { /* */ } } { // 曲线 valueAdapter: { // 在实例化曲线时调用 forTarget(target: BlahBlahComponent) { // 在这里做一些有用的事 return { // 在每一次设置目标对象的值时调用 set(value: number) { target.setUniform(0, value); } }; } }, }; 如果希望“自定义赋值”是可序列化的，那么可以将它们声明为类： @ccclass class MyValueProxy implements animation.ValueProxyFactory { @property public index: number = 0; constructor(index: number) { this.index = index; } // 在实例化曲线时调用 public forTarget(target: BlahBlahComponent) { // 在这里做一些有用的事 return { // 在每一次设置目标对象的值时调用 set(value: number) { target.setUniform(0, value); } }; } } animation.UniformProxyFactory 就是这样一种 自定义赋值 的类，它实现了设置材质的 uniform 值： { // 目标对象是 modifiers: [ // MeshRenderer 组件的 new animation.ComponentPath(js.getClassName(MeshRenderer)), // sharedMaterials 属性的 'sharedMaterials', // 第一个材质 0, ], valueAdapter: new animation.UniformProxyFactory( 0, // Pass 索引 'albedo', // Uniform 名称 ), }; 采样 若采样时间点恰好就等于某一关键帧的时间点，则使用该关键帧上的动画数据。否则当采样时间点居于两帧之间时，结果值会同时受两帧数据的影响，采样时间点在两处关键帧的时刻区间上的比例（[0, 1]）则反应了影响的程度。 Cocos Creator 允许将该比例映射为另一个比例，以实现不同的“渐变”效果。这些映射方式，在 Creator 中称为 渐变方式。在比例确定之后，再根据指定的 插值方式 计算出最终的结果值。 注意：渐变方式和插值方式都影响着动画的平滑度。 渐变方式 可以为每一帧指定渐变方式，也可以为所有帧指定统一的渐变方式。渐变方式可以是内置渐变方式的名称或贝塞尔控制点。 以下列出了几种常用的渐变方式： linear：保持原有比例，即线性渐变，当未指定渐变方式时默认使用该方式 constant：始终使用比例 0，即不进行渐变，与插值方式 Step 类似 quadIn：渐变由慢到快 quadOut：渐变由快到慢 quadInOut：渐变由慢到快再到慢 quadOutIn：渐变由快到慢再到快 展开对比 曲线值与插值方式 有些插值算法需要在每一帧的曲线值中存储额外的数据，因此曲线值与目标属性的值类型不一定相同。对于数值类型或值类型，Cocos Creator 提供了几种通用的插值方式。同时，也可以定义自己的插值方式。 当曲线数据的 interpolate 属性为 true 时，曲线将尝试使用插值函数： 若曲线值的类型为 number、Number，将应用线性插值； 若曲线值继承自 ValueType，将调用 ValueType 的 lerp 函数完成插值。Cocos Creator 内置的大多数值类型的 lerp 方法都是实现为线性插值，例如 Vec3 、vec4 等； 若曲线值是 可插值的，将调用曲线值的 lerp 函数完成插值1。 若曲线值不满足上述任何条件，或当曲线数据的 interpolate 属性为 false 时，将不会进行插值操作，而是永远使用前一帧的曲线值作为结果。 import { AnimationClip, color, IPropertyCurveData, SpriteFrame, Vec3 } from 'cc'; const animationClip = new AnimationClip(); const keys = [ 0, 0.5, 1.0, 2.0 ]; animationClip.duration = keys.length === 0 ? 0 : keys[keys.length - 1]; animationClip.keys = [ keys ]; // 所有曲线共享一列帧时间 // 使用数值的线性插值 const numberCurve: IPropertyCurveData = { keys: 0, values: [ 0, 1, 2, 3 ], /* interpolate: true, */ // interpolate 属性默认打开 }; // 使用值类型 Vec3 的 lerp() const vec3Curve: IPropertyCurveData = { keys: 0, values: [ new Vec3(0), new Vec3(2), new Vec3(4), new Vec3(6) ], interpolate: true, }; // 不插值（因为显式禁用了插值） const colorCuve: IPropertyCurveData = { keys: 0, values: [ color(255), color(128), color(61), color(0) ], interpolate: false, // 不进行插值 }; // 不插值（因为 SpriteFrame 无法进行插值） const spriteCurve: IPropertyCurveData = { keys: 0, values: [ new SpriteFrame(), new SpriteFrame(), new SpriteFrame(), new SpriteFrame() ], }; 自定义插值算法 范例代码如下： import { ILerpable, IPropertyCurveData, Quat, quat, Vec3, vmath } from 'cc'; class MyCurveValue implements ILerpable { public position: Vec3; public rotation: Quat; constructor(position: Vec3, rotation: Quat) { this.position = position; this.rotation = rotation; } /** 将调用此方法进行插值 * @param this 起始曲线值 * @param to 目标曲线值 * @param t 插值比率，取值范围为 [0, 1] * @param dt 起始曲线值和目标曲线值之间的帧时间间隔 */ lerp (to: MyCurveValue, t: number, dt: number) { return new MyCurveValue( // 位置属性不插值 this.position.clone(), // 旋转属性使用 Quat 的 lerp() 方法 this.rotation.lerp(to.rotation, t), // ); } /** 此方法在不插值时调用 * 它是可选的，若未定义此方法，则使用曲线值本身（即 this）作为结果值 */ getNoLerp () { return this; } } /** * 创建了一条曲线，它实现了在整个周期内平滑地旋转但是骤然地变换位置。 */ function createMyCurve (): IPropertyCurveData { const rotation1 = quat(); const rotation2 = quat(); const rotation3 = quat(); vmath.quat.rotateY(rotation1, rotation1, 0); vmath.quat.rotateY(rotation2, rotation2, Math.PI); vmath.quat.rotateY(rotation3, rotation3, 0); return { keys: 0 /* 帧时间 */, values: [ new MyCurveValue(new Vec3(0), rotation1), new MyCurveValue(new Vec3(10), rotation2), new MyCurveValue(new Vec3(0), rotation3), ], }; } 循环模式 可以通过设置 AnimationClip.wrapMode 为动画剪辑设置不同的循环模式。以下列出了几种常用的循环模式： AnimationClip.wrapMode 说明 WrapMode.Normal 播放到结尾后停止 WrapMode.Loop 循环播放 WrapMode.PingPong 从动画开头播放到结尾后，从结尾开始反向播放到开头，如此循环往复 更多循环模式，详情请参考 API WrapMode 以及文档 循环模式与循环次数。 1. 对于数值、四元数以及各种向量，Cocos Creator 提供了相应的可插值类以实现 三次样条插值。 ↩ "},"animation/skeletal-animation.html":{"url":"animation/skeletal-animation.html","title":"骨骼动画组件","keywords":"","body":"骨骼动画 骨骼动画是一种常见但类型特殊的动画。 骨骼动画组件 导入带有动画文件的 模型资源 后，若模型网格中带有蒙皮信息，在使用模型时，SkeletalAnimation 组件便会自动添加到模型节点上。 或者在 层级管理器 中选中需要添加骨骼动画组件的节点，然后在 属性检查器 中选择 添加组件 -> Animation -> SkeletalAnimation 即可。 属性 说明 Clips、DefaultClip、PlayOnLoad 与动画组件的属性功能一致，详情请参考 动画组件属性。 Sockets 用于将某些外部节点挂到指定的骨骼关节上，属性的值表示挂点的数量。详情请参考下文 挂点系统 部分的内容。 useBakedAnimation 该项用于切换使用 预烘焙骨骼动画 或 实时计算骨骼动画，详情请参考下文 骨骼动画系统 部分的内容。 骨骼动画的组件接口请参考 SkeletalAnimation API。 挂点系统 如果需要将某些外部节点挂到指定的骨骼关节上，使其在动画过程中随骨骼关节一起运动变换，需要使用骨骼动画组件的 挂点（Socket）系统。下面通过一个范例来介绍如何使用骨骼挂点。 将骨骼动画资源导入到 资源管理器 中，然后将其拖拽到 层级管理器 中，生成骨骼动画节点（例如下图中的 Fox 节点）； 在 Fox 节点下新建一个空子节点 Node； 在 层级管理器 中选中 Fox 节点，在 属性检查器 中将 SkeletalAnimation 组件的 Sockets 属性设置为 1（Sockets 属性的值代表了挂点的数量）。然后设置 Sockets 中的 Path 和 Target 属性： Path 的下拉框中会列出所有的骨骼，选择想要挂载的目标骨骼，这里以 Fox 的尾巴为例 将刚才创建的子节点 Node 拖拽到 Target 属性框中，可以看到 层级管理器 中的子节点 Node 根据所选的目标骨骼名称被自动重命名了。 这样子节点就成为目标挂点了，接下来我们在子节点下创建一个 Torus（圆环）节点，即可在 场景编辑器 中看到圆环套在了狐狸尾巴上。 Torus 节点可以根据自己的需要调整其位置大小等属性，也可以在作为目标节点的子节点下添加多个节点，都会跟随指定骨骼的变换而变换。 保存场景，点击编辑器上方的预览按钮，可以看到圆环套在狐狸的尾巴上，并随着狐狸的尾巴一起晃动。 注意：若要设置多个挂点，则相对应地，也需要在骨骼动画节点下创建多个空的子节点作为目标挂点。如下图： FBX 或 glTF 资源内的挂点模型会自动对接挂点系统，无需任何手动操作。 骨骼动画系统 Creator 提供了 预烘焙骨骼动画 和 实时计算骨骼动画 两套系统，针对不同方向的需求，分别优化。 这两套系统的唯一开关是 SkeletalAnimation 组件中的 useBakedAnimation 属性，运行时也可以无缝切换。 启用 useBakedAnimation 时会使用预烘焙骨骼动画系统 禁用 useBakedAnimation 后会使用实时计算骨骼动画系统 预烘焙骨骼动画系统 这个系统的压倒性目的是性能，因此部分表现力的牺牲被认为是可以接受的。我们针对性地做了很多底层优化，目前的运行时流程大致如下： 所有动画数据都会按照指定帧率提前预采样、烘焙到全局复用的骨骼动画贴图合集上； 根据运行平台是否支持浮点纹理，对应使用 RGBA32F 或 RGBA8 格式的备用方案（该步骤流程用户不必关心，不会对最终表现有影响，只是低端平台最后的保底策略）； 每个 骨骼动画组件（SkeletalAnimation）负责维护当前的播放进度，以 UBO（一个 Vec4）的形式存储； 各 蒙皮网格渲染器组件（SkinnedMeshRenderer）持有预烘焙蒙皮模型类（BakedSkinningModel），根据同样提前烘焙好的包围盒信息计算 Culling，更新 UBO，在 GPU 上从贴图合集内取到当前数据完成蒙皮。 实时计算骨骼动画系统 这个系统的压倒性目的是表现力，确保所有细节的正确显示，以及完整的程序控制能力。 目前的运行时流程大致如下： 所有动画数据根据当前全局时间动态插值计算； 动画数据会输出到场景的骨骼节点树中； 用户和其他任何系统都可以通过操纵这个骨骼节点树对蒙皮效果产生影响； 各蒙皮网格渲染器组件（SkinnedMeshRenderer）持有普通蒙皮模型类（SkinningModel），每帧提取骨骼节点树信息计算 culling，将当前帧完整骨骼变换信息上传 UBO，在 GPU 内完成蒙皮。更多关于蒙皮的介绍，请参考下文 蒙皮算法 部分的内容。 这为以下所有功能提供了最基础的支撑： blendshape 支持 任意数量动画片段的混合和 masking IK、二级物理影响 纯程序控制关节位置 两套系统的选择与最佳实践 目前所有模型资源在导入后，Prefab 中全部默认使用 预烘焙系统，以达到最佳性能。建议只在明显感到预烘焙系统的表现力无法达标的情况下，再使用 实时计算系统。 注意：虽然两套系统可以在运行时无缝切换，但尽量不要高频执行，因为每次切换都涉及底层渲染数据的重建。 蒙皮算法 Creator 内置了两种常见标准蒙皮算法，它们性能相近，只对最终表现有影响： LBS（线性混合蒙皮）：骨骼信息以 3 x 4 矩阵形式存储，直接对矩阵线性插值实现蒙皮。目前有体积损失等典型已知问题。 DQS（双四元数蒙皮）：骨骼信息以 双四元数 形式插值，对不含有缩放变换的骨骼动画效果更精确自然，但出于性能考虑，对所有缩放动画有近似简化处理。 引擎默认使用 LBS，可以通过修改引擎 skeletal-animation-utils.ts 的 updateJointData 函数引用与 cc-skinning.chunk 中的头文件引用来切换蒙皮算法。 推荐对蒙皮动画质量有较高追求的项目可以尝试启用 DQS，但因 GLSL 400 之前都没有 fma 指令，例如 cross 等操作在某些 GPU 上无法绕过浮点抵消问题，误差较大，可能引入部分可见瑕疵。 关于动态 Instancing 基于 预烘焙系统 的框架设计，蒙皮模型的 instancing 也成为了触手可及的功能，但要保证正确性还需要收集一些比较底层的信息。 这里的根本问题是，同一个 Drawcall 内的各个模型使用的骨骼贴图必须是同一张，如果不是同一张，显示效果会完全错乱。所以如何将动画数据分配到每张骨骼贴图上，就成为了一个需要用户自定义的信息，可以在编辑器菜单栏 面板 -> 动画 的 骨骼贴图布局面板 进行配置。 注意： 只有 预烘焙系统 下支持 instancing。我们虽然没有严格禁止在 实时计算框架 下启用 instancing（只有编辑器内的警告），但动画效果一定会有问题，取决于模型实际的材质分配情况。最好的情况是不同 instance 间显示完全一致的动画，最坏情况下会导致模型完全错乱。 对于材质中已经开启 instancing 的模型，平面阴影系统也会自动同步使用 instancing 绘制。特别地，蒙皮模型的阴影合批对骨骼贴图布局的要求更高一些，因为阴影的管线状态是统一的，所有开启阴影的蒙皮模型的动画 都需要保证在同一张贴图上（相比绘制模型本身，只需要相同 Drawcall 内的 instance 之间保持骨骼贴图一致）。 BatchedSkinnedMeshRenderer 组件 目前底层上传 GPU 的骨骼纹理已做到全局自动合批复用，上层数据目前可以通过使用 批量蒙皮网格渲染器组件（BatchedSkinnedMeshRenderer） 将同一个骨骼动画组件控制的所有子蒙皮模型合并。 批量蒙皮网格渲染器组件 相关，详情请参考文档 BatchedSkinnedMeshRenderer。 合批版 effect 书写相对复杂一点，但基本可以基于子材质使用的普通 effect 加入一些相对直接的预处理和接口改动即可。可参考编辑器 资源管理器 面板中 internal -> effects -> util 目录下的内置 effect 资源 batched-unlit，batched-unlit 是合批版的 builtin-unlit。 注意：只有预烘焙系统下使用批量蒙皮网格渲染器组件可以保证正确性，实时计算框架下虽然也能使用，但当合并后的骨骼数量超过 30 个（Uniform 数组最大数量限制）时会有渲染问题。 "},"animation/joint-texture-layout.html":{"url":"animation/joint-texture-layout.html","title":"骨骼贴图布局设置","keywords":"","body":"骨骼贴图布局设置 要确保 骨骼动画 也能够完全正确地参与 动态 Instancing，需要用户手动指定每张骨骼贴图的数据分配方式。 比如一个场景中要绘制大量相同的人物角色，每个角色可能在走/跳/攻击。如果希望一个 Drawcall 就能够正确完成所有角色的绘制，一个重要的前提条件是 这三个动画（走、跳、攻击）的数据都储存在同一张骨骼贴图内。 目前在默认的 预烘焙骨骼动画模式 下，骨骼贴图已经做到全局自动复用，但每张贴图的大小和它们各储存哪些动画是不可预知的。如果不做任何处理直接开启蒙皮模型的 instancing 的话，最终的运行时效果可能会出现有的动画效果正确，有的动画效果完全错乱，并且完全无法预测。 因此我们在编辑器菜单栏 面板 -> 动画 中增加了 骨骼贴图布局设置 面板，用于手动指定每张骨骼贴图中要存储哪些骨骼的哪些动画信息。 注意：骨骼贴图布局设置面板提供的，本质上是运行时的 内存分配指导规则。对于指定的骨骼和动画资源，会保证按照指定规则分配。但如果运行时用到了并未指定规则的资源，还是会回到全局复用的自动分配模式上去。 骨骼贴图布局设置 下面我们以范例工程 show-cases 中的 instanced-skinning 场景（GitHub | Gitee）为例，来看一下骨骼贴图布局具体的设置流程以及实际效果。 下图中展示了一个示例场景，有多个来自同一模型的实例，同时播放完全不同的动画。这些模型使用实时计算动画模式，并没有开启 instancing。可以看到，当前场景加上 UI，总 Drawcall 为 60，instance 计数为 0。这个状态将作为后面改动的基础，以对照使用。 要创建开启 instancing 版本的模型，需要以下步骤： 在 属性检查器 中，勾选骨骼动画组件 (SkeletalAnimation) 中的 UseBakedAnimation 属性（使用预烘焙动画模式） 对所有蒙皮模型 (SkinningModel) 使用的材质，勾选 USE INSTANCING 在我们的示例场景中实际是制作了两套 Prefab，并在开启 instancing 的版本中将材质漫反射颜色设为蓝色，以便同时观察和区分两套系统的表现。可以看到效果已完全正确，并且只用了 5 个 Drawcall（每个模型分为 5 个部分），instance 数量为 45。 注意：这里能够正确渲染所有模型的原因是，动画数据量相对还比较小，通用的骨骼贴图全局复用逻辑就已经把所有动画数据写入了同一张贴图，因此效果是正确的。但随时可能加入的新动画如果超出了默认骨骼贴图的大小（360 * 360），动画效果就一定会出问题，这也就是为什么骨骼贴图布局面板必须存在的原因。 骨骼贴图布局效果 出于展示目的，我们可以在 骨骼贴图布局设置 面板故意将每个动画都单独放到一张贴图上，看看最后的渲染效果。 首先，打开 骨骼贴图布局设置 面板： 面板中三个 + 的用法如下： ① — 用于增加 Texture 单元，一个 Texture 单元由多个 Skeleton 单元组成。 ② — 用于增加 Skeleton 单元，一个 Skeleton 单元由一个 Skeleton 资源和一至多个 AnimationClip 资源组成。 ③ — 用于增加 AnimationClip 资源槽。 这里我们将 9 个不同的动画分开放在 9 个 Texture 单元内： 重新运行场景，效果变为： 可以看到此时动画效果出现了问题，所有动画都变成了执行 attack 动作，并且不时地出现模型消失的问题。这背后的原因可以精确地分析清楚： 每个 Drawcall 绘制 9 个实例，分别在播 9 个不同的动画。 但骨骼动画贴图每个 Drawcall 只能用一张，这里明显使用了 Texture 单元 0，只有一个 attack 动画。 而不同动画片段的长度不同，有些长度超过 attack 片段，那么在最后一段时间便会读到 Texture 单元 0 的有效区域之外，这里的数据并未定义（一般是默认全 0），不是有效的骨骼变换数据，自然无法正确渲染了。 注意：这里的 9 张贴图上都只有同一个骨骼的动画信息，所以最终效果哪怕贴图已经错了，渲染出来也只是动作错了而已；但如果一张贴图内有多个骨骼的动画信息，同时出现贴图不匹配情况的话，渲染效果就会完全错乱。 对于上面的示例场景，因为这个模型的确需要同时同屏播放这 9 个动画片段，所以正确的骨骼贴图布局设置应该为： 这样就能够 保证 正确渲染了。观察面板上相关数据的变化： Texture 单元 0 总大小为 276 x 276（由算法自动生成的，足够存放指定的所有动画数据的最小尺寸）。 指定的 9 组动画数据占了这张贴图的 94.41%，有 5.59% 的多余空间（这部分空间在运行时并不会参与全局复用）。 另外，贴图尺寸旁的图标颜色表示当前贴图的设备适配情况： 绿色（边长 1024 以下）：所有设备都确保有效。 黄色（边长 1024 ~ 2048）：某些不支持浮点贴图的移动设备或小游戏平台可能会不支持。 红色（边长 2048 以上）：许多移动设备上都不支持。 注意：这里只是在一张贴图上放了一套骨骼的 9 个动画，但只要总大小没有超过设备上限，每张贴图上便可以放 任意多套骨骼 的任意数量动画。通常一张贴图放多套骨骼是更为常见的情况，比如对于 蒙皮模型的平面阴影。 我们继续在场景中增加更多的实例数量，可以看到 Drawcall 数量并不会改变，只有 instance 数量的增加： "},"animation/animation-component.html":{"url":"animation/animation-component.html","title":"使用脚本控制动画","keywords":"","body":"使用脚本控制动画 动画组件 动画组件管理了一组动画状态，用于控制各动画的播放、暂停、继续、停止、切换等。动画组件会为每一个动画剪辑都创建相应的 动画状态 对象，动画状态用于控制需要在对象上使用的动画剪辑。 在动画组件中，动画状态是通过名称来标识的，每个动画状态的默认名称就是其动画剪辑的名称。 在脚本中为节点添加动画组件的方式如下： import { Animation, Node } from 'cc'; function (node: Node) { const animationComponent = node.addComponent(Animation); } 动画的播放与切换 播放动画 动画组件通过 play() 控制指定动画的播放，例如： // 播放动画状态 'idle' animationComponent.play('idle'); // 指定从 1s 开始播放 'idle' 动画 animationComponent.play('idle', 1); 使用 play 播放动画时若未指定具体动画，并且设置了 defaultClip，则会播放 defaultClip 动画。若动画组件的 playOnLoad 也设置为 true，则动画组件将在第一次运行时自动播放 defaultClip 的内容。 // 未指定播放的动画，并且设置了 defaultClip 的话，则会播放 defaultClip 动画 animationComponent.play(); 切换动画 使用 play 接口播放一个动画时，如果此时还有其他的动画正在播放，则会立即停止其他动画的播放。这种切换是非常突兀的，在某些情况下，我们希望这种切换是“淡入淡出”的效果，那么便可以使用 crossFade()，在指定的周期内平滑地完成切换。例如： // 播放动画状态 ‘walk’ animationComponent.play('walk'); /* ... */ // 在 0.3 秒内平滑地从走的动画切换为跑的动画 animationComponent.crossFade('run', 0.3); crossFade() 的这种淡入淡出机制使得同一时刻可能有不止一个动画状态在播放。因此，动画组件没有 当前动画 的概念。 即便如此，动画组件仍提供了 pause()、resume()、stop() 方法，这些方法在暂停、继续以及停止正在播放的所有动画状态的同时，也暂停、继续以及停止动画的切换。 关于动画组件更多相关的控制接口，详情请参考 类 Animation。 动画状态 动画组件只提供了一些简单的控制函数，大部分情况下是足够和易于使用的，但若想要得到更多的动画信息以及动画控制接口，需要使用 动画状态。 帧事件 动画编辑器支持可视化编辑 事件帧，也可以直接在脚本里添加帧事件。 AnimationClip 的 events 包含了此动画所有的帧事件，每个帧事件都具有以下属性： { frame: number; func: string; params: any[]; } frame：表示事件触发的时间点，单位为秒。例如 0.618 就表示当动画到达第 0.618 秒时将触发事件。时间轴刻度单位之间的转换，详情请参考 时间轴的刻度单位显示。 func：表示事件触发时回调的函数名称。事件触发时，动画系统会搜索 动画根节点中的所有组件，若组件中有实现动画事件 func 中指定的函数，便会对其进行调用，并传入 params 中的参数。 例如，在动画时间轴的第 0.5s 添加了一个事件帧： 那么在脚本中实现的代码如下： { frame: 0.5; func: 'onTrigger'; params: [ 0 ]; } 示例 以下代码表示 MyScript 脚本组件所在节点的动画组件的默认动画剪辑在进行到第 0.5 秒时，将调用 MyScript 组件的 onTriggered() 方法并传递参数 0。 import { Animation, Component } from 'cc'; class MyScript extends Component { constructor() { } public start() { const animationComponent = this.node.getComponent(Animation); if (animationComponent && animationComponent.defaultClip) { const { defaultClip } = animationComponent; defaultClip.events.push({ frame: 0.5, // 第 0.5 秒时触发事件 func: 'onTriggered', // 事件触发时调用的函数名称 params: [ 0 ], // 向 `func` 传递的参数 }); defaultClip.updateEventDatas(); } } public onTriggered(arg: number) { console.log('I am triggered!'); } } 动画事件 除了 动画编辑器 中的帧事件提供了回调，动画系统还提供了动画事件回调方式。目前支持的回调事件包括： play：开始播放时触发 stop：停止播放时触发 pause：暂停播放时触发 resume：恢复播放时触发 lastframe：假如动画循环次数大于 1，当动画播放到最后一帧时触发。 finished：动画播放完成时触发 更多内容请参考 Animation.EventType。 "},"animation/animation-state.html":{"url":"animation/animation-state.html","title":"动画状态","keywords":"","body":"动画状态 动画剪辑仅描述某一类对象的动画数据，例如角色的跑、走、跳等，但并未绑定具体要执行动画的对象。动画状态便是用于控制在某个对象上使用的动画剪辑，类似于播放机，除了提供动画组件也有的简单的控制函数外，还提供了更多的动画信息以及动画控制接口，允许对动画播放进行调速、设置循环模式等控制。一个动画剪辑可以同时被多个动画状态使用。 动画状态由 类 AnimationState 管理。 设置播放速度 首先可以通过 getState() 获取动画状态： // 获取动画组件 const animationComponent = node.getComponent(Animation); // 获取动画组件上的动画剪辑 const [ idleClip, runClip ] = animationComponent.clips; // 获取 `idleClip` 的动画状态 const idleState = animationComponent.getState(idleClip.name); 然后设置动画播放的速度： // 以二倍速播放 `idleClip` 动画 animationComponent.getState('idle').speed = 2.0; // speed 值越大速度越快，值越小则速度越慢 动画状态也提供了 play()、pause()、resume()、stop() 等用于播放控制的方法，详情可参考下文 播放状态 部分的内容。 播放时间 动画状态记录了动画的 累计播放时间。初始时累计播放时间为 0。当动画自然播放时，时间会不断累计。例如，当动画循环播放时，刚好第二次循环完毕后，累计播放时间将为 动画周期 * 2。 任意时刻动画所处的播放位置称为 进度时间，因此进度时间总是在 [0, 动画周期] 范围内。 累计播放时间 由 AnimationState 的 time 字段获取，并且可以显式设置。 进度时间 由 AnimationState 的 current 字段获取，是 只读 的。 动画播放的循环模式与循环次数决定了累计播放至某一时间时动画的进度时间，不管 累计播放时间 因为时间的推移而增加还是因为直接设置而更改，进度时间 都会相应发生改变。 循环模式与循环次数 动画可以播放到结尾就停止，或者一直循环播放，或者也可以先播放到结尾再从结尾播放到开头如此循环，这些统称为循环模式，由枚举 AnimationClip.WrapMode 表示，包括以下几种： 循环模式 说明 AnimationClip.WrapMode.Normal 从开头播放至结尾后停止。 AnimationClip.WrapMode.Loop 不断地从开头播放至结尾。 AnimationClip.WrapMode.PingPong 从开头播放至结尾后，再从结尾反向播放至开头，如此循环往复。 除此之外，上表中的每种循环模式还存在对应的 反向 循环模式： 循环模式 说明 AnimationClip.WrapMode.Reverse 从结尾播放至开头后停止。 AnimationClip.WrapMode.LoopReverse 不断地从结尾播放至开头。 AnimationClip.WrapMode.PingPongReverse 从结尾播放至开头后，再从开头反向播放至结尾，如此循环往复。 动画状态的初始循环模式将从动画剪辑中读取。需要改变动画状态的循环模式时，简单地设置动画状态的 wrapMode 字段即可。 注意：设置循环模式时会重置动画状态的 累计播放时间。 除 AnimationClip.WrapMode.Normal 和其对应的 AnimationClip.WrapMode.Reverse 外（它们可以理解为单次循环），其余的循环模式执行的都是无限次循环。无限次循环需要与 AnimationState 的 repeatCount 配合使用才能达到效果，并且可以通过 repeatCount 字段来设置和获取循环的次数。 当动画循环模式为： 单次循环模式：repeatCount 将被设置为 1。 无限次循环模式：repeatCount 将被设置为 Number.Infinity，即无限循环。 注意：设置循环次数应该在设置循环模式之后进行，因为重新设置循环模式时会重置循环次数。 播放控制 动画状态提供了以下几种方法用于控制动画的播放、暂停、恢复和停止： 方法 说明 play() 重置播放时间为 0 并开始播放动画。 pause() 暂停动画。 resume() 从当前时间开始继续播放动画。 stop() 停止播放动画。 也可以通过以下字段查询动画的播放状态： 字段（只读） 说明 isPlaying 动画是否处于播放状态。 isPaused 动画是否处于暂停状态。 isMotionless 动画是否处于暂停状态或者已被停止。 播放控制与播放状态之间的关系如下图所示： 通过动画状态可以获取到所有动画的信息，以便利用这些信息来判断需要做哪些事，更多接口请参考 类 AnimationState。 "},"audio-system/overview.html":{"url":"audio-system/overview.html","title":"音频系统","keywords":"","body":"音频系统 音乐是游戏中不可或缺的一部分，好的音乐能让游戏更加真实、富有沉浸感。Cocos Creator 的音频系统支持导入并播放大多数常见的音频文件格式，具体内容请参考： 音频资源 AudioSource 组件参考 AudioSource 播放示例 兼容性说明 "},"audio-system/audiosource.html":{"url":"audio-system/audiosource.html","title":"AudioSource 组件参考","keywords":"","body":"AudioSource 组件参考 AudioSource 组件用于控制音乐和音效的播放。 在 层级管理器 中选中节点，然后点击 属性检查器 下方的 添加组件 按钮，选择 Audio -> AudioSource 即可添加 AudioSource 组件到节点上。 AudioSource 属性 属性 说明 Clip 添加的用于播放的 音频资源，默认为空，点击后面的箭头按钮即可选择 Loop 是否循环播放 PlayOnAwake 是否在游戏运行（组件激活）时自动播放音频 Volume 音量大小，范围在 0~1 之间 音频播放 Cocos Creator 3.x 使用 AudioSource 控制音频的播放。AudioSource 是组件，可以添加到场景中，由 编辑器 设置，也可以在 脚本 中进行调用。 另外，Creator 根据音频的长短将其分为较长的 音乐 和短的 音效 两种： 若通过编辑器控制音频播放，则播放音乐和音效没有区别，但推荐使用长音乐。详情可参考下文 通过编辑器播放 部分的内容。 若通过脚本控制音频播放，则 AudioSource 组件额外提供了 playOneShot 接口用于播放短音效，详情请参考下文 音效播放 部分的内容。 注意：Cocos Creator 3.x 移除了 v2.x 中的 audioEngine API，统一使用 AudioSource 组件播放音频。 通过编辑器 在节点上添加 AudioSource 组件。 将所需的音频资源从 资源管理器 拖拽到 AudioSource 组件的 Clip 属性框中，如下所示： 根据需要对 AudioSource 组件的其他属性进行设置即可。 通过脚本 如果要更灵活地控制 AudioSource 播放音频，可以将自定义脚本添加到 AudioSource 组件 所在的节点，然后调用相应的 API 来控制音频播放。 在节点上添加 AudioSource 组件并指定音频资源。 在 资源管理器 中 创建脚本 并命名（例如 AudioController），然后双击打开脚本进行编写，内容如下： import { _decorator, Component, Node, AudioSource, assert } from 'cc'; const { ccclass, property } = _decorator; @ccclass(\"AudioController\") export class AudioController extends Component { @property(AudioSource) public _audioSource: AudioSource = null!; onLoad () { // 获取 AudioSource 组件 const audioSource = this.node.getComponent(AudioSource)!; // 检查是否含有 AudioSource，如果没有，则输出错误消息 assert(audioSource); // 将组件赋到全局变量 _audioSource 中 this._audioSource = audioSource; } play () { // 播放音乐 this._audioSource.play(); } pause () { // 暂停音乐 this._audioSource.pause(); } } 在 层级管理器 选中节点，然后将 资源管理器 中的脚本拖拽到 属性检查器 即可添加脚本组件到节点。如下所示： 音效播放 相较于长的音乐播放，音效播放具有以下特点： 播放时间短 同时播放的数量多 AudioSource 组件提供了 playOneShot 接口来播放音效。具体代码实现如下： // AudioController.ts import { AudioClip, AudioSource, Component, _decorator } from 'cc'; const { ccclass, property } = _decorator; @ccclass(\"AudioController\") export class AudioController extends Component { @property(AudioClip) public clip: AudioClip = null!; @property(AudioSource) public audioSource: AudioSource = null!; playOneShot () { this.audioSource.playOneShot(this.clip, 1); } } 注意：playOneShot 是一次性播放操作，播放后的音效无法暂停或停止播放，也无法监听播放结束的事件回调。 更多音频相关的脚本接口请参考 AudioSource API。 更多对音频的播放控制，可以参考文档 AudioSource 播放示例。 Web 平台的播放限制 目前 Web 平台的音频播放需要遵守最新的 Audio Play Police，即使 AudioSource 组件设置了 playOnAwake，也需要在触摸事件中手动播放音频，如下所示： // AudioController.ts import { _decorator, Component, Node, AudioSource, find } from 'cc'; const { ccclass, property } = _decorator; @ccclass(\"AudioController\") export class AudioController extends Component { @property(AudioSource) public audioSource: AudioSource = null!; start () { let btnNode = find('BUTTON_NODE_NAME'); btnNode!.on(Node.EventType.TOUCH_START, this.playAudio, this); } playAudio () { this.audioSource.play(); } } "},"audio-system/audioExample.html":{"url":"audio-system/audioExample.html","title":"音频播放示例","keywords":"","body":"音频播放示例 由于 Cocos Creator 3.x 移除了 v2.x cc.audioEngine 系列的 API，统一使用 AudioSource 控制音频播放，因此我们需要在项目中将 AudioSource 组件 声明为常驻根节点，并封装一个管理器使用。可参考以下代码： import { assert, AudioSource, Component, game } from 'cc'; const { ccclass, property } = _decorator; @ccclass('GameRoot') export class GameRoot extends Component { @property(AudioSource) _audioSource: AudioSource = null!; onLoad () { const audioSource = this.node.getComponent(AudioSource)!; assert(audioSource); this._audioSource = audioSource; // 声明常驻根节点，该节点不会在场景切换中被销毁。目标节点必须是根节点，否则无效。 game.addPersistRootNode(this.node); // 将节点封装到管理器中 audioManager.instance.init(this._audioSource); } } 音频管理的具体实现，可参考以下代码： import { AudioClip, AudioSource, assert, warn, clamp01, resources } from \"cc\"; export class audioManager { private static _instance: audioManager; private static _audioSource?: AudioSource; static get instance () { if (this._instance) { return this._instance; } this._instance = new audioManager(); return this._instance; } /**管理器初始化*/ init (audioSource: AudioSource) { audioManager._audioSource = audioSource; } /** * 播放音乐 * @param {Boolean} loop 是否循环播放 */ playMusic (loop: boolean) { const audioSource = audioManager._audioSource!; assert(audioSource, 'AudioManager not inited!'); audioSource.loop = loop; if (!audioSource.playing) { audioSource.play(); } } /** * 播放音效 * @param {String} name 音效名称 * @param {Number} volumeScale 播放音量倍数 */ playSound (name: string, volumeScale: number = 1 ) { const audioSource = audioManager._audioSource!; assert(audioSource, 'AudioManager not inited!'); // 注意：第二个参数 “volumeScale” 是指播放音量的倍数，最终播放的音量为 “audioSource.volume * volumeScale” audioSource.playOneShot(audioClip, volumeScale); } // 设置音乐音量 setMusicVolume (flag: number) { const audioSource = audioManager._audioSource!; assert(audioSource, 'AudioManager not inited!'); flag = clamp01(flag); audioSource.volume = flag; } } 特别需要注意的是常驻节点在切换场景时会 暂停音乐，需要在 onEnable 中继续播放操作，代码示例如下： import { _decorator,Component} from 'cc'; const { ccclass, property } = _decorator; @ccclass('GameRoot') export class GameRoot extends Component { onEnable () { audioManager.instance.playMusic(true); } } 注意：该问题将在 v3.3 中解决，请关注版本公告。 以上代码片段只是举例了 AudioSource 组件播放的一种使用方式，并不完整。Creator 在范例项目 快上车（GitHub | Gitee）中提供了完整的封装好的音频播放管理器的使用示例。开发者可打开 Dashboard 的 项目 页面，点击右下角的 新建 按钮，进入新建项目页面，即可看到 Example Taxi Game 范例，根据需要填写项目名称和项目位置后即可创建并打开： "},"audio-system/audioLimit.html":{"url":"audio-system/audioLimit.html","title":"兼容性说明","keywords":"","body":"兼容性说明 Web 平台音频资源的加载模式 Web 平台上的音频资源比较特别，因为 Web 标准支持以两种不同的方式加载音频资源，分别是： Web Audio：提供相对更加现代化的声音控制接口，在引擎内是以一个 audio buffer 的形式缓存的。这种方式的优点是兼容性好，问题比较少。 DOM Audio：通过生成一个标准的 audio 元素来播放音频资源，在引擎内缓存的就是这个 audio 元素。使用标准的 audio 元素播放音频资源时，在某些浏览器上可能会遇到一些兼容性问题，比如 iOS 上的浏览器不支持调整音量大小，所有 volume 相关属性将不会生效。 目前 Creator 默认以 Web Audio 的方式加载音频资源，但如果检测到当前浏览器不支持加载 Web Audio，则会切换使用 DOM Audio 的方式加载音频。 如果项目需要强制通过 DOM Audio 的方式加载音频资源，请使用以下方式动态加载： assetManager.loadRemote('http://example.com/background.mp3', { audioLoadMode: AudioClip.AudioType.DOM_AUDIO, }, callback); "},"physics/":{"url":"physics/","title":"物理系统","keywords":"","body":"物理系统 Cocos Creator 的物理系统提供了高效的组件化工作流程和便捷的使用方法。目前支持刚体、碰撞组件、触发和碰撞事件、物理材质、射线检测等等特性。 开发者可在 Creator 主菜单栏的 项目 -> 项目设置 -> 功能裁剪 中根据需要配置 2D 或者 3D 物理系统： 更多具体内容请参考： 2D 物理系统 3D 物理系统 "},"physics-2d/physics-2d.html":{"url":"physics-2d/physics-2d.html","title":"2D 物理","keywords":"","body":"2D 物理简介 Cocos Creator 3.0 支持内置的轻量 Builtin 物理系统和强大的 Box2D 物理系统。Builtin 物理系统只提供了碰撞检测的功能，对于物理计算较为简单的情况，我们推荐使用 Builtin 物理模块，这样可以避免加载庞大的 Box2D 物理模块并构建物理世界的运行时开销。而 Box2D 物理模块提供了更完善的交互接口和刚体、关节等已经预设好的组件。 你可以根据需要来选择适合自己的物理模块，通过编辑器主菜单中的 项目 -> 项目设置 -> 功能裁剪 切换物理模块的使用。 详细介绍 2D 物理系统 2D 刚体组件 2D 碰撞组件 2D 碰撞回调 2D 物理关节 2D 物理示例 请参考范例 physics-samples（GitHub | Gitee）。 "},"physics-2d/physics-2d-system.html":{"url":"physics-2d/physics-2d-system.html","title":"2D 物理系统","keywords":"","body":"2D 物理系统 物理系统隐藏了大部分物理模块（Box2D 和 Builtin 模块）实现细节（比如创建刚体，同步刚体信息到节点中等）。 可以通过物理系统访问一些物理模块常用的功能，比如点击测试、射线测试、设置测试信息等。 物理系统相关设置 开启物理系统 物理系统默认是开启的，代码如下： PhysicsSystem2D.instance.enable = true; 绘制物理调试信息 物理系统默认是不绘制任何调试信息的，如果需要绘制调试信息，请使用 debugDrawFlags。 物理系统提供了各种各样的调试信息，可以通过组合这些信息来绘制相关的内容。 PhysicsSystem2D.instance.debugDrawFlags = EPhysics2DDrawFlags.Aabb | EPhysics2DDrawFlags.Pair | EPhysics2DDrawFlags.CenterOfMass | EPhysics2DDrawFlags.Joint | EPhysics2DDrawFlags.Shape; 设置绘制标志位为 EPhysics2DDrawFlags.None，即可以关闭绘制。 PhysicsSystem2D.instance.debugDrawFlags = EPhysics2DDrawFlags.None; 物理单位到世界坐标系单位的转换 一般物理模块（Box2D）都是使用 米 - 千克 - 秒（MKS） 单位制，Box2D 在这样的单位制下运算的表现是最佳的。但是我们在 2D 游戏运算中一般使用 世界坐标系中的单位（简称世界单位）来作为长度单位制，所以我们需要一个比率来进行物理单位到世界单位上的相互转换。 一般情况下我们把这个比率设置为 32，这个值可以通过 PHYSICS_2D_PTM_RATIO 获取，并且这个值是只读的。通常用户是不需要关心这个值的，物理系统内部会自动对物理单位与世界单位进行转换，用户访问和设置的都是进行 2d 游戏开发中所熟悉的世界单位。 设置物理重力 重力是物理表现中非常重要的一点，大部分物理游戏都会使用到重力这一物理特性。默认的重力加速度是 (0, -10) 米/秒^2，按照上面描述的转换规则，即 (0, -320) 世界单位/秒^2。 如果希望重力加速度为 0，可以这样设置： PhysicsSystem2D.instance.gravity = v2(); 如果希望修改重力加速度为其他值，比如每秒加速降落 20m/s，那么可以这样设置： PhysicsSystem2D.instance.gravity = v2(0, -20 * PHYSICS_2D_PTM_RATIO); 设置物理步长 物理系统是按照一个固定的步长来更新物理世界的，默认的步长是 1/60。但是有的游戏可能会不希望按照这么高的频率来更新物理世界，毕竟这个操作是比较消耗时间的，可以通过降低步长来达到这个效果。 const system = PhysicsSystem2D.instance; // 物理步长，默认 fixedTimeStep 是 1/60 system.fixedTimeStep = 1/30; // 每次更新物理系统处理速度的迭代次数，默认为 10 system.velocityIterations = 8; // 每次更新物理系统处理位置的迭代次数，默认为 10 system.positionIterations = 8; 注意：降低物理步长和各个属性的迭代次数，都会降低物理的检测频率，所以会更有可能发生刚体穿透的情况，使用时需要考虑到这个情况。 查询物体 通常你可能想知道在给定的场景中都有哪些实体。例如，一个炸弹爆炸了，在范围内的物体都会受到伤害，或者在策略类游戏中，可能会希望让用户选择一个范围内的单位进行拖动。 物理系统提供了几个方法方便用户高效快速地查找某个区域中有哪些物体，每种方法通过不同的方式来检测物体，基本满足游戏所需。 点测试 点测试将测试是否有碰撞体会包含一个世界坐标系下的点，如果测试成功，则会返回一个包含这个点的碰撞体。注意，如果有多个碰撞体同时满足条件，下面的接口只会返回一个随机的结果。 const collider = PhysicsSystem2D.instance.testPoint(point); 矩形测试 矩形测试将测试世界坐标系下指定的一个矩形，如果一个碰撞体的包围盒与这个矩形有重叠部分，则这个碰撞体会被添加到返回列表中。 const colliderList = PhysicsSystem2D.instance.testAABB(rect); 射线测试 Box2D 物理模块（Builtin 模块没有）提供了射线检测来检测给定的线段穿过哪些碰撞体，我们还可以获取到碰撞体在线段穿过碰撞体的那个点的法线向量和其他一些有用的信息。 const results = PhysicsSystem2D.instance.rayCast(p1, p2, type, mask); for (const i = 0; i 射线检测的第三个参数指定检测的类型，射线检测支持四种类型。这是因为 Box2D 的射线检测不是从射线起始点最近的物体开始检测的，所以检测结果不能保证结果是按照物体距离射线起始点远近来排序的。Cocos Creator 物理系统将根据射线检测传入的检测类型来决定是否对 Box2D 检测结果进行排序，这个类型会影响到最后返回给用户的结果。 ERaycast2DType.Any 检测射线路径上任意的碰撞体，一旦检测到任何碰撞体，将立刻结束检测其他的碰撞体，最快。 ERaycast2DType.Closest 检测射线路径上最近的碰撞体，这是射线检测的默认值，稍慢。 ERaycast2DType.All 检测射线路径上的所有碰撞体，检测到的结果顺序不是固定的。在这种检测类型下，一个碰撞体可能会返回多个结果，这是因为 Box2D 是通过检测夹具（fixture）来进行物体检测的，而一个碰撞体中可能由多个夹具（fixture）组成的，慢。 ERaycast2DType.AllClosest 检测射线路径上所有碰撞体，但是会对返回值进行删选，只返回每一个碰撞体距离射线起始点最近的那个点的相关信息，最慢。 射线检测的结果 射线检测的结果包含了许多有用的信息，你可以根据实际情况来选择如何使用这些信息。 collider 指定射线穿过的是哪一个碰撞体。 point 指定射线与穿过的碰撞体在哪一点相交。 normal 指定碰撞体在相交点的表面的法线向量。 fraction 指定相交点在射线上的分数。 可以通过下面这张图更好的理解射线检测的结果。 "},"physics-2d/physics-2d-rigid-body.html":{"url":"physics-2d/physics-2d-rigid-body.html","title":"2D 刚体组件","keywords":"","body":"2D 刚体 刚体是组成物理世界的基本对象，你可以将刚体想象成一个你不能看到（绘制）也不能摸到（碰撞）的带有属性的物体。 由于 Builtin 2D 物理系统只带有碰撞检测的功能，所以刚体对于 Builtin 2D 物理系统是不生效的，本篇设置只对其他 2D 物理系统产生作用。 刚体属性 质量 刚体的质量是通过 碰撞组件 的 密度 与 大小 自动计算得到的。若需要计算物体应该受到多大的力，可能需要使用到这个属性。 // 获取刚体质量 const mass = rigidbody.getMass(); 移动速度 // 获取移动速度 const velocity = rigidbody.linearVelocity; // 设置移动速度 rigidbody.linearVelocity = velocity; 移动速度衰减系数，值越大物体移动越慢，可以用来模拟空气摩擦力等效果。 // 获取移动速度衰减系数 const damping = rigidbody.linearDamping; // 设置移动速度衰减系数 rigidbody.linearDamping = damping; 如果要获取刚体上某个点的移动速度，可以通过 getLinearVelocityFromWorldPoint 来获取。比如一个盒子旋转着往前飞，碰到了墙，这时候可能会希望获取盒子在发生碰撞的点的速度。 const velocity = rigidbody.getLinearVelocityFromWorldPoint(worldPoint); 或者传入一个 Vec2 对象作为第二个参数来接收返回值，这样你可以使用你的缓存对象来接收这个值，避免创建过多的对象来提高效率。 刚体的 get 方法都提供了 out 参数来接收函数返回值。 const velocity = new Vec2(); rigidbody.getLinearVelocityFromWorldPoint(worldPoint, velocity); 旋转速度 // 获取旋转速度 const velocity = rigidbody.angularVelocity; // 设置旋转速度 rigidbody.angularVelocity = velocity; 旋转速度衰减系数，与移动衰减系数相同。 // 获取旋转速度衰减系数 const damping = rigidbody.angularDamping; // 设置旋转速度衰减系数 rigidbody.angularDamping = damping; 旋转、位移与缩放 旋转、位移与缩放是游戏开发中最常用的功能，几乎每个节点都会对这些属性进行设置。而在物理系统中，系统会自动将节点的这些属性与 Box2D 中对应属性进行同步。 注意： Box2D 中只有旋转和位移，并没有缩放，所以如果设置节点的缩放属性时，会重新构建这个刚体依赖的全部碰撞体。一个有效避免这种情况发生的方式是将渲染的节点作为刚体节点的子节点，只对这个渲染节点作缩放，尽量避免对刚体节点进行直接缩放。 在物理系统每次迭代（物理系统是在 postUpdate 进行迭代的）的最后会把所有刚体信息同步到对应节点上去，而出于性能考虑，只有当开发者对刚体所在节点的相关属性进行显示设置时，节点的信息才会同步到刚体上，并且刚体只会监视他所在的节点，也就是说，如果修改了节点的父节点的旋转位移，是不会同步这些信息的。 固定旋转 做平台跳跃游戏时通常都不会希望主角的旋转属性也被加入到物理模拟中，因为这样会导致主角在移动过程中东倒西歪，这时可以设置刚体的 fixedRotation 为 true，固定旋转。 rigidbody.fixedRotation = true; 开启碰撞监听 只有开启了刚体的碰撞监听，刚体发生碰撞时才会回调到对应的组件上。 rigidbody.enabledContactListener = true; 刚体类型 Box2D 原本的刚体类型是三种：Static、Dynamic、Kinematic。在 Cocos Creator 3.0 里多添加了一个类型：Animated。 Animated 是从 Kinematic 类型衍生出来的，一般的刚体类型修改 旋转 或 位移 属性时，都是直接设置的属性，而 Animated 会根据当前旋转或位移属性，与目标旋转或位移属性计算出所需的速度，并且赋值到对应的移动或旋转速度上。 添加 Animated 类型主要是防止对刚体做动画时可能出现的奇怪现象，例如穿透。 RigidBodyType.Static 静态刚体，零质量，零速度，即不会受到重力或速度影响，但是可以设置他的位置来进行移动。 RigidBodyType.Dynamic 动态刚体，有质量，可以设置速度，会受到重力影响。 RigidBodyType.Kinematic 运动刚体，零质量，可以设置速度，不会受到重力的影响，但是可以设置速度来进行移动。 RigidBodyType.Animated 动画刚体，在上面已经提到过，从 Kinematic 衍生的类型，主要用于刚体与动画编辑结合使用。 刚体方法 获取或转换旋转位移属性 使用这些 API 来获取世界坐标系下的旋转和位移会比通过节点来获取更快，因为节点中还需要通过矩阵运算得到结果，而使用 API 是直接得到结果的。 本地坐标与世界坐标转换 // 世界坐标转换到本地坐标 const localPoint = rigidbody.getLocalPoint(worldPoint); // 或者 localPoint = new Vec2(); rigidbody.getLocalPoint(worldPoint, localPoint); // 本地坐标转换到世界坐标 const worldPoint = rigidbody.getWorldPoint(localPoint); // 或者 worldPoint = new Vec2(); rigidbody.getLocalPoint(localPoint, worldPoint); // 本地向量转换为世界向量 const worldVector = rigidbody.getWorldVector(localVector); // 或者 worldVector = new Vec2(); rigidbody.getWorldVector(localVector, worldVector); // 世界向量转换为本地向量 const localVector = rigidbody.getLocalVector(worldVector); // 或者 localVector = new Vec2(); rigidbody.getLocalVector(worldVector, localVector); 获取刚体质心 当对一个刚体施加力的时候，一般会选择刚体的质心作为施加力的作用点，这样能保证力不会影响到旋转值。 // 获取本地坐标系下刚体的质心 const localCenter = rigidbody.getLocalCenter(); // 或者通过参数来接收返回值 localCenter = new Vec2(); rigidbody.getLocalCenter(localCenter); // 获取世界坐标系下的刚体质心 const worldCenter = rigidbody.getWorldCenter(); // 或者通过参数来接收返回值 worldCenter = new Vec2(); rigidbody.getWorldCenter(worldCenter); 力与冲量 移动一个物体有两种方式： 可以施加一个力或者冲量到这个物体上。力会随着时间慢慢修改物体的速度，而冲量会立即修改物体的速度。 直接修改物体的位置，只是这看起来不像真实的物理，你应该尽量去使用力或者冲量来移动刚体，这会减少可能带来的奇怪问题。 // 施加一个力到刚体上指定的点，这个点是世界坐标系下的一个点 rigidbody.applyForce(force, point); // 或者直接施加力到刚体的质心上 rigidbody.applyForceToCenter(force); // 施加一个冲量到刚体上指定的点，这个点是世界坐标系下的一个点 rigidbody.applyLinearImpulse(impulse, point); 力与冲量也可以只对旋转轴产生影响，这样的力叫做扭矩。 // 施加扭矩到刚体上，因为只影响旋转轴，所以不再需要指定一个点 rigidbody.applyTorque(torque); // 施加旋转轴上的冲量到刚体上 rigidbody.applyAngularImpulse(impulse); 其他 如果要获取刚体在某一点上的速度时，可以通过 getLinearVelocityFromWorldPoint 来获取，比如当物体碰撞到一个平台时，需要根据物体碰撞点的速度来判断物体相对于平台是从上方碰撞的还是下方碰撞的。 rigidbody.getLinearVelocityFromWorldPoint(worldPoint); "},"physics-2d/physics-2d-collider.html":{"url":"physics-2d/physics-2d-collider.html","title":"2D 碰撞体","keywords":"","body":"2D 碰撞组件 物理碰撞组件属性 sensor - 指明碰撞体是否为传感器类型，传感器类型的碰撞体会产生碰撞回调，但是不会发生物理碰撞效果。 density - 碰撞体的密度，用于刚体的质量计算 friction - 碰撞体摩擦力，碰撞体接触时的运动会受到摩擦力影响 restitution - 碰撞体的弹性系数，指明碰撞体碰撞时是否会受到弹力影响 Box2D 物理碰撞组件内部细节 Box2D 物理碰撞组件内部是由 Box2D 的 b2Fixture 组成的，由于 Box2D 内部的一些限制，一个多边形物理碰撞组件可能会由多个 b2Fixture 组成。 这些情况为： 当多边形物理碰撞组件的顶点组成的形状为凹边形时，物理系统会自动将这些顶点分割为多个凸边形。 当多边形物理碰撞组件的顶点数多于 b2.maxPolygonVertices（一般为 8）时，物理系统会自动将这些顶点分割为多个凸边形。 一般情况下这些细节是不需要关心的，但是当使用射线检测并且检测类型为 ERaycast2DType.All 时，一个碰撞体就可能会检测到多个碰撞点，原因即是检测到了多个 b2Fixture。 编辑碰撞组件 当添加了一个碰撞组件后，可以通过点击 属性检查器 中的 editing 来开启碰撞组件的编辑，如下图。 多边形碰撞组件 如果编辑的是 多边形碰撞组件 的话，则会出现类似下图所示的 多边形编辑区域。区域中的这些绿色点都是可以拖动的，拖动的结果会反映到 多边形碰撞组件 的 points 属性中。 当鼠标移动到两点连成的线段上时，鼠标指针会变成 添加 样式，这时点击鼠标左键会在这个地方添加一个点到 多边形碰撞组件 中。 多边形碰撞组件还有一个 Regenerate Points 的功能，这个功能可以根据组件依附的节点上的 Sprite 组件的贴图的像素点来自动生成相应轮廓的顶点。 Threshold 指明生成贴图轮廓顶点间的最小距离，值越大则生成的点越少，可根据需求进行调节。 圆形碰撞组件 如果编辑的是 圆形碰撞组件 的话，则会出现类似下图所示的 圆形编辑区域： 鼠标左键拖动显示的点可以修改 圆形碰撞组件 的半径大小，拖动圆内的区域可以拖动圆形区域。 矩形碰撞组件 如果编辑的是 矩形碰撞组件 的话，则会出现类似下图所示的 矩形编辑区域： 当鼠标悬浮在 矩形碰撞区域 的顶点上时，点击鼠标左键拖拽可以同时修改 矩形碰撞组件 的长宽； 当鼠标悬浮在 矩形碰撞区域 的区域内时，点击鼠标左键拖拽将修改 矩形碰撞组件 的偏移量。 按住 Alt 按键拖拽时，在拖拽过程中将会保持 矩形中心点位置 不变。 修改碰撞组件偏移量 在所有的碰撞组件调整中，都可以在各自的 碰撞中心区域 点击鼠标左键拖拽来快速编辑碰撞组件的 偏移量 "},"physics-2d/physics-2d-contact-callback.html":{"url":"physics-2d/physics-2d-contact-callback.html","title":"2D 碰撞回调","keywords":"","body":"2D 碰撞回调 当物体在场景中移动并碰撞到其它物体时，物理引擎会处理大部分必要的碰撞检测，我们一般不需要关心这些情况。但是制作物理游戏最主要的点是有些情况下物体碰撞后应该发生些什么，比如角色碰到怪物后会死亡，或者球在地上弹动时应该产生声音等。 我们需要一个方式来获取到这些碰撞信息，物理引擎提供的方式是在碰撞发生时产生回调，在回调里我们可以根据产生碰撞的两个碰撞体的类型信息来判断需要作出什么样的动作。 注意： Box2D 物理模块需要先在 Rigidbody 中 开启碰撞监听，才会有相应的回调产生。Builtin 物理模块只需要有碰撞体组件就可以产生碰撞回调。 回调中的信息在物理引擎都是以缓存的形式存在的，所以信息只有在这个回调中才是有用的，不要在你的脚本里直接缓存这些信息，但可以缓存这些信息的副本。 在回调中创建的物理物体，比如刚体，关节等，这些不会立刻就创建出对应的物体，会在整个物理系统更新完成后再进行这些物体的创建。 注册回调函数 注册一个碰撞回调函数有两种方式，一种是通过指定的 collider 注册；另一种是通过 2D 物理系统注册一个全局的回调函数。 注意：Builtin 2D 物理模块只会发送 BEGIN_CONTACT 和 END_CONTACT 回调消息。 @ccclass('TestContactCallBack') export class TestContactCallBack extends Component { start () { // 注册单个碰撞体的回调函数 let collider = this.getComponent(Collider2D); if (collider) { collider.on(Contact2DType.BEGIN_CONTACT, this.onBeginContact, this); collider.on(Contact2DType.END_CONTACT, this.onEndContact, this); collider.on(Contact2DType.PRE_SOLVE, this.onPreSolve, this); collider.on(Contact2DType.POST_SOLVE, this.onPostSolve, this); } // 注册全局碰撞回调函数 if (PhysicsSystem2D.instance) { PhysicsSystem2D.instance.on(Contact2DType.BEGIN_CONTACT, this.onBeginContact, this); PhysicsSystem2D.instance.on(Contact2DType.END_CONTACT, this.onEndContact, this); PhysicsSystem2D.instance.on(Contact2DType.PRE_SOLVE, this.onPreSolve, this); PhysicsSystem2D.instance.on(Contact2DType.POST_SOLVE, this.onPostSolve, this); } } onBeginContact (selfCollider: Collider2D, otherCollider: Collider2D, contact: IPhysics2DContact | null) { // 只在两个碰撞体开始接触时被调用一次 console.log('onBeginContact'); } onEndContact (selfCollider: Collider2D, otherCollider: Collider2D, contact: IPhysics2DContact | null) { // 只在两个碰撞体结束接触时被调用一次 console.log('onEndContact'); } onPreSolve (selfCollider: Collider2D, otherCollider: Collider2D, contact: IPhysics2DContact | null) { // 每次将要处理碰撞体接触逻辑时被调用 console.log('onPreSolve'); } onPostSolve (selfCollider: Collider2D, otherCollider: Collider2D, contact: IPhysics2DContact | null) { // 每次处理完碰撞体接触逻辑时被调用 console.log('onPostSolve'); } } 上面的代码示例演示了如何在脚本中添加所有的碰撞回调函数。回调一共有四种，每种回调函数都有三个参数，详情可查看下方的 回调参数 说明。每种回调函数的作用如注释所示，开发者可以根据自己的需求实现相应的回调函数。 Box2D 物理模块碰撞回调的顺序 Box2D 物理模块模拟碰撞的过程是比较复杂的，我们可以通过拆分一个简单示例的碰撞过程来查看碰撞回调函数的回调顺序和回调的时机。假设有两个刚体正相互移动，三角形往右运动，方块往左运动，它们即将碰撞到一起。 碰撞的过程 碰撞 1 碰撞 2 碰撞 3 当两个碰撞体相互覆盖时，Box2D 默认的行为是给每个碰撞体一个冲量将它们分开，但是这个行为不一定能在一个物理周期内完成。像这里显示的一样，示例中的碰撞体会在三个物理周期内相互覆盖直到“反弹”完成并且它们相互分离。在这个时间里可以定制我们想要的行为，onPreSolve 会在每次物理引擎处理碰撞前回调，可以在这个回调里修改碰撞信息； onPostSolve 会在处理完成这次碰撞后回调，可以在这个回调中获取到物理引擎计算出的碰撞的冲量信息。 下面给出的输出信息能使我们更清楚回调的顺序。 ... Step Step BeginContact PreSolve PostSolve Step PreSolve PostSolve Step PreSolve PostSolve Step EndContact Step Step ... 回调的参数 回调的参数包含了所有的碰撞接触信息，每个回调函数都提供了三个参数： selfCollider：指的是回调脚本的节点上的碰撞体； otherCollider：指的是发生碰撞的另一个碰撞体； contact：是一个 IPhysicsContact 类型的接口。包含碰撞最主要的信息。其中比较常用的信息就是碰撞的位置和法向量，contact 内部是按照刚体的本地坐标来存储信息的，而我们一般需要的是世界坐标系下的信息，我们可以通过 contact.getWorldManifold 来获取这些信息。注意，在 Builtin 物理模块这个参数为空。 worldManifold const worldManifold = contact.getWorldManifold(); const points = worldManifold.points; const normal = worldManifold.normal; worldManifold 包括以下成员： points 碰撞点数组，它们不一定会精确地在碰撞体碰撞的地方上，如下图所示（除非你将刚体设置为子弹类型，但是会比较耗性能），但实际上这些点在使用时一般都是够用的。 注意：不是每一个碰撞都会有两个碰撞点，在模拟的更多的情况下只会产生一个碰撞点，下面列举一些其它的碰撞示例。 normal 碰撞点上的法向量，由自身碰撞体指向对方碰撞体，指明解决碰撞最快的方向。 上图所示的线条即碰撞点上的法向量，在这个碰撞中，解决碰撞最快的途径是添加冲量将三角形往左上推，将方块往右下推。需要注意的是这里的法向量只是一个方向，并不带有位置属性，也不会连接到这些碰撞点中的任何一个。 你还需要注意的是 碰撞法向量并不是碰撞体碰撞的角度，它只会指明可以解决两个碰撞体相互覆盖这一问题最短的方向。比如上面的例子中如果三角形移动得更快一点，覆盖的情形像下图所示的话： 那么最短的方式将会是把三角形往右上推，所以使用法向量来作为碰撞角度不是一个好主意。如果想要知道碰撞的真正方向，可以使用以下方式获取两个碰撞体相互碰撞时在碰撞点上的相对速度。 const vel1 = triangleBody.getLinearVelocityFromWorldPoint(worldManifold.points[0]); const vel2 = squareBody.getLinearVelocityFromWorldPoint(worldManifold.points[0]); const relativeVelocity = vel1.sub(vel2); 禁用 contact contact.disabled = true; 禁用 contact 会使物理引擎在计算碰撞时会忽略掉这次碰撞，禁用将会持续到碰撞完成，除非在其它回调中再将这个 contact 启用。 或者如果只想在本次物理处理步骤中禁用 contact，可以使用 disabledOnce。 contact.disabledOnce = true; 修改 contact 信息 前面有提到我们在 onPreSolve 中修改 contact 的信息，因为 onPreSolve 是在物理引擎处理碰撞信息前回调的，所以对碰撞信息的修改会影响到后面的碰撞计算。 // 修改碰撞体间的摩擦力 contact.setFriction(friction); // 修改碰撞体间的弹性系数 contact.setRestitution(restitution); 注意：这些修改只会在本次物理处理步骤中生效。 "},"physics-2d/physics-2d-joint.html":{"url":"physics-2d/physics-2d-joint.html","title":"2D 物理关节","keywords":"","body":"2D 关节组件 物理系统包含了一系列用于链接两个刚体的关节组件。关节组件可以用来模拟真实世界物体间的交互，比如铰链，活塞、绳子、轮子、滑轮、机动车、链条等。学习如何使用关节组件可以创建一个真实有趣的场景。 注意：关节组件在 Builtin 2D 物理模块中是无效的。 目前物理系统中提供了以下可用的关节组件： Distance Joint - 距离关节，将关节两端的刚体约束在一个最大范围内。 Fixed Joint - 固定关节，根据两个物体的初始角度将两个物体上的两个点固定在一起。 Hinge Joint - 铰链关节，可以看做一个铰链或者钉，刚体会围绕一个共同点来旋转。 Relative Joint - 相对关节，控制两个刚体间的相对运动。 Slider Joint - 滑动关节，两个刚体位置间的角度是固定的，它们只能在一个指定的轴上滑动。 Spring Joint - 弹簧关节，将关节两端物体像弹簧一样连接在一起。 Wheel Joint - 轮子关节，用于模拟机动车车轮。 关节的共同属性 虽然每种关节都有不同的表现，但是它们也有一些共同的属性： connectedBody - 关节链接的另一端的刚体 anchor - 关节本端链接的刚体的锚点 connectedAnchor - 关节链接另一端刚体的锚点 collideConnected - 关节两端的刚体是否能够互相碰撞 每个关节都需要链接两个刚体才能够发挥它的功能，我们把和关节挂在同一节点下的刚体视为关节的本端，把 connectedBody 视为另一端的刚体。通常情况下，每个刚体会选取自身周围的某个位置设定成锚点。根据关节组件类型的不同，锚点决定了物体的旋转中心，或者是用来保持一定距离的坐标点，等等。 collideConnected 属性用于确定关节两端的刚体是否需要继续遵循常规的碰撞规则。 如果你现在准备制作一个布娃娃，你可能会希望大腿和小腿能够部分重合，然后在膝盖处链接到一起，那么就需要设置collideConnected 属性为 false。如果你准备做一个升降机，希望升降机平台和地板能够碰撞，那么就需要设置 collideConnected 属性为 true。 "},"physics/physics.html":{"url":"physics/physics.html","title":"3D 物理","keywords":"","body":"3D 物理简介 Cocos Creator 3.0 目前支持轻量的碰撞检测系统 builtin 和具有物理模拟的物理引擎 cannon.js，以及功能完善强大的 bullet 的 asm.js/wasm 版本（ammo.js），并为开发者提供了高效统一的组件化工作流程和便捷的使用方法。 物理世界和元素 物理世界中的元素可以分为一个个的 刚体，在 Cocos Creator 中加入物理元素可以通过为游戏对象添加碰撞器（Collider）或者刚体（RigidBody）组件，物理系统将为这些元素进行物理计算，使其表现出真实世界下的行为。 注：此处的“刚体”不是指刚体组件，刚体组件用于控制刚体物理行为相关的属性。 添加物理元素 在世界中添加一个物理元素可以分为以下步骤： 新建一个形状 Cube； 在右侧 属性检查器 面板下方点击 添加组件 按钮； 在 Physics 目录下选择 BoxCollider，并调整参数； 为了使它具有物理行为，接着添加一个 RigidBody 组件。 这样，便有了一个 既有碰撞器又有物理行为 的一个物理元素。 完善物理世界 接着，完善物理世界，可以为世界添加一个地面，仿照 1，2，3 步骤，可以再添加一个 只有碰撞器 的 Plane； 然后，再调整摄像机的角度（选中摄像机，执行 Ctrl + Shift + F 可以对齐到屏幕）； 最后，点击运行按钮，便可以看到物理元素在场景世界上的变化，最后的场景如下图所示： 物理元素的组成 在 Cocos Creator 中，一个物理元素可以由以下几种方式组成： 一个刚体组件 一个或多个碰撞器组件 一个刚体加一个或多个碰撞器组件 更详细的模块 Cocos Creator 的物理系统的更多内容将通过以下模块来进行更详细的介绍： 模块 描述 物理选项 介绍了 Cocos Creator 中可选的底层物理引擎选项 物理系统 介绍了物理系统，以及物理系统的一系列属性和接口 物理组件 介绍了一些物理组件以及面板上的一系列属性 物理使用 进一步介绍了物理相关的使用、事件、分组掩码等 "},"physics/physics-item.html":{"url":"physics/physics-item.html","title":"物理选项","keywords":"","body":"选择适合你项目的物理系统 在编辑器上方的菜单栏中选择 项目 -> 项目设置 -> 功能裁剪 -> 物理系统，您可以选择适合项目需求的物理引擎进行开发。默认物理引擎为 bullet（ammo.js），开发过程中可随意切换物理引擎。 若不需要用到任何物理相关的组件和接口，可以取消 物理系统 的勾选，这样在发布时包体将会更小。但需要注意的是若取消勾选，则项目不可以使用物理相关的组件和接口，否则运行时将会报错。 碰撞检测：builtin builtin 仅有碰撞检测的功能，相对于其它的物理引擎，它没有复杂的物理模拟计算。如果您的项目不需要这一部分的物理模拟，那么可以考虑使用 builtin，这将使得游戏的包体更小。 若使用 builtin 进行开发，请注意以下几点： builtin 只有 trigger 类型的事件。 Collider 中的 isTrigger 无论值真假，都为运动学类型的触发器。 物理引擎：cannon.js cannon.js（GitHub | Gitee）是一个开源的物理引擎，它使用 js 语言开发并实现了比较全面的物理功能，如果您的项目需要更多复杂的物理功能，那么您可以考虑使用它。 cannon.js 模块大小约为 141KB。 物理引擎：bullet（ammo.js） ammo.js（GitHub | Gitee）是 bullet 物理引擎的 asm.js/wasm 版本，由 emscripten 工具编译而来。 Bullet 具有完善的物理功能，以及更佳的性能，未来我们也将在此投入更多工作。 需要注意的是，目前 ammo.js 模块具有 1.5MB 左右的大小。 不使用物理 若不需要用到任何物理相关的组件和接口，可以取消黄色框的勾选，这样在发布时将有更小的包体。 注意：若处于取消勾选的状态，项目将不可以使用物理相关的组件和接口，否则运行时将会报错。 "},"physics/physics-system.html":{"url":"physics/physics-system.html","title":"物理系统","keywords":"","body":"物理系统 物理系统（PhysicsSystem）用于管理所有物理相关的功能，目前它负责同步物理元素、触发物理事件和调度物理世界的迭代。 物理世界 物理世界迭代时会对物理元素进行物理计算，比如计算各物体是否产生碰撞，以及物体的受力情况。当计算完成后，物理系统会将物理世界更新到场景世界中，从而使游戏对象产生相应的物理行为。 注：目前只有单一的物理世界，后续会探讨多物理世界的功能支持。 场景世界与物理世界： 部分属性 目前物理系统的属性暂时只能通过代码进行设置，后续将会增加设置面板，请留意更新公告。 注意：获取物理系统实例：PhysicsSystem.instance 属性 说明 enable 是否开启物理系统，默认为 true gravity 物理世界的重力值，默认为 (0, -10, 0) allowSleep 是否允许物理系统自动休眠，默认为 true maxSubSteps 每帧模拟的最大子步数，默认为 2 fixedTimeStep 每次子步进消耗的时间，默认为 1/60 sleepThreshold 进入休眠的默认速度临界值 autoSimulation 是否开启自动模拟，默认为 true defaultMaterial 获取默认物理材质（只读） raycastResults 获取 raycast 的检测结果（只读） raycastClosestResult 获取 raycastClosest 的检测结果（只读） collisionMatrix 获取碰撞矩阵，仅用于初始化 部分接口 接口 签名 说明 resetAccumulator (time = 0) => void 重置累计的时间总量（可以考虑在切换场景时进行重置） "},"physics/physics-component.html":{"url":"physics/physics-component.html","title":"物理组件","keywords":"","body":"物理组件 Cocos Creator 目前为用户提供了多种碰撞器组件和通用的刚体组件，以及工具类的恒力组件。 注意：更多功能组件将会在后续版本持续发布，请留意版本更新公告。 碰撞器组件 碰撞器组件用于表示刚体的碰撞体形状，不同的几何形状拥有不同的属性。 注意： 以下属性名称的首字母在实际代码中都为小写。 目前在 builtin 中只支持盒、球、胶囊体。 盒碰撞器组件 BoxCollider 属性 解释 material 碰撞器引用的 物理材质（为空时引用物理系统的默认物理材质） isTrigger 是否为触发器，触发器不会产生物理反馈 center 本地坐标系下形状的原点 size 盒的大小，即长、宽、高 盒碰撞器组件接口请参考 BoxCollider API。 球碰撞器组件 SphereCollider 属性 解释（其它参考盒碰撞器） radius 球的半径 球碰撞器组件接口请参考 SphereCollider API。 圆柱碰撞器组件 CylinderCollider 属性 解释（其它参考盒碰撞器） direction 圆柱延申方向的参考轴 height 圆柱的总高度 radius 圆柱两端圆面的半径 圆柱碰撞器组件接口请参考 CylinderCollider API。 胶囊碰撞器组件 CapsuleCollider 属性 解释（其它参考圆柱和盒碰撞器） cylinderHeight 胶囊中圆柱的高度 radius 胶囊中球体的半径 胶囊碰撞器组件接口请参考 CapsuleCollider API。 注意：cannon.js 不支持胶囊组件，建议使用两个球和圆柱拼凑。 圆锥碰撞器组件 ConeCollider 属性 解释（其它参考圆柱和盒碰撞器） radius 圆锥中底面圆的半径 height 圆锥的高度 圆锥碰撞器组件接口请参考 ConeCollider API。 平面碰撞器组件 PlaneCollider 属性 解释（其它参考盒碰撞器） normal 平面的法向量 constant 平面沿着法向量移动的距离 平面碰撞器组件接口请参考 PlaneCollider API。 网格碰撞器组件 MeshCollider 属性 解释（其它参考盒碰撞器） mesh 网格碰撞器引用的网格资源，用于初始化网格碰撞体 convex 是否使用网格的凸包近似，网格顶点数应尽量小于255（通过它可以支持任意凸类碰撞体和动力学刚体） 注意： cannon.js 对网格碰撞器组件支持程度很差，只允许与少数碰撞器（球、平面）产生检测。 convex 功能目前仅 ammo.js 后端支持。 网格碰撞器组件接口请参考 MeshCollider API。 单纯形碰撞器组件 SimplexCollider 属性 解释（其它参考盒碰撞器） shapeType 单纯形类型，包括四种：点、线、三角面、四面体 vertex0 单纯形的顶点 0，点（由 0 组成） vertex1 单纯形的顶点 1，线（由 0、1 组成） vertex2 单纯形的顶点 2，三角面（以此类推） vertex3 单纯形的顶点 3，四面体 注：cannon.js 对线和三角面的支持目前还不完善。 单纯形碰撞器组件接口请参考 SimplexCollider API。 刚体组件 RigidBody 为了更便捷的模拟物理行为，Cocos Creator 为用户提供了刚体组件，预览图如下： 属性 解释（上图的属性值都是默认值） group 分组 type 刚体类型（下方属性仅对 DYNAMIC 类型的刚体有用） mass 质量，该值应大于 0 allowSleep 是否允许休眠 linearDamping 线性阻尼，用于减小物体的线性速率 angularDamping 角阻尼，用于减小物体的旋转速率 useGravity 是否受重力影响 linerFactor 线性因数，可影响每个轴向的线性速度的变化 angularFactor 旋转因数，可影响每个轴向的旋转速度的变化 刚体组件接口请参考 RigidBody API。 恒力组件 ConstantForce 这是一个工具组件，它依赖刚体组件，将会在每帧对一个刚体施加给定的力和扭矩。 属性 解释 force 在世界坐标系中对刚体施加的力 localForce 在本地坐标系中对刚体施加的力 torque 在世界坐标系中对刚体施加的扭矩 localTorque 在本地坐标系中对刚体施加的扭矩 恒力组件接口请参考 ConstantForce API。 "},"physics/physics-use.html":{"url":"physics/physics-use.html","title":"使用物理","keywords":"","body":"使用物理 为了更好的介绍如何使用物理，将通过以下模块进行介绍： 模块 描述 碰撞组件 介绍了 Collider 组件的设计，以及与 RigidBody 组件的关系 物理配置 物理配置用于配置各种常用属性，以及设置碰撞矩阵等 物理材质 介绍了 Cocos Creator 中的物理材质资源 刚体组件 介绍了 RigidBody 组件的一些代码使用示例 物理事件 介绍了 Cocos Creator 中的物理事件 分组掩码 介绍了物理过滤检测中分组掩码的使用 射线检测 介绍了对物理碰撞器的射线检测功能 "},"physics/physics-collider.html":{"url":"physics/physics-collider.html","title":"使用碰撞器","keywords":"","body":"碰撞组件 获取碰撞器组件 Cocos Creator 目前支持两种语言进行开发，分别为 JavaScript 和 TypeScript。 注：TypeScript 具有良好的语法分析和类型提示，推荐使用。 以获取 BoxCollider 组件为例： this.getComponent('BoxCollider') // Or import { BoxCollider } from 'cc' this.getComponent(BoxCollider) // 推荐使用 注：若无智能导入提示，请参考 代码编辑环境配置。 碰撞器和触发器 Collider 组件具有 isTrigger 属性，当 isTrigger 为 true 时，表示为触发器，反之为碰撞器。关于碰撞器和触发器的详细内容，可参考 物理事件。 Collider 和 RigidBody 的关系 Collider 和 RigidBody 组件都是服务于物理元素，分别操控着物理元素上的一部分属性。了解它们之间的关系，需要先了解 Cocos Creator 中的物理元素是如何构成的。 物理元素的构成 在物理简介中，介绍了一个物理元素是由 Collider 和 RigidBody 组件相互组合而成的，其中指出了物理元素只能有一个或零个 RigidBody 组件，并且可以有多个 Collider 组件。 单个节点是很容易看出是否有物理元素的，但如果以节点链为单位，则很难看出物理元素是由哪些节点以及哪些组件组成的。 对于节点树的情况，目前有两个思路： 每个节点只要有 物理组件，就是一个元素，这样父子节点之间的组件没有依赖关系。若节点需要多个碰撞体形状，往该节点上添加相应的 Collider 组件即可。 缺点： 不够直观，多个形状只能往一个节点上加，显示形状需要增加子节点模型，并且不好支持碰撞体的局部旋转。 调整参数时，需要调整两个地方，分别为子节点的位置信息和父节点上对应 Collider 组件的数据信息。 从自身节点开始往父链节点上搜索，如果找到了 RigidBody 组件，则将自身的 Collider 组件绑定到该节点上，否则整条链上的 Collider 组件将共享一个 RigidBody 组件，元素对应的节点是最顶层的 Collider 组件所对应的节点。 缺点： 增加了节点耦合，节点更新时，需要更新相应的依赖节点。 在节点链被破坏时，需要维护内容更多，节点链在反复被破坏时需要处理复杂的逻辑。 注：目前使用的是思路一，后续可能会进行调整，请留意版本更新公告。 attachedRigidbody 属性 在 Collider 组件中具有 attachedRigidbody 属性，此属性可获得当前 Collider 组件所绑定的 RigidBody 组件，但是请注意以下几点： 在自身节点无 RigidBody 组件时，该属性返回为 null。 attachedRigidbody 是一个只读的属性。 自动缩放 每一个组件都会绑定一个节点，有些组件会根据绑定的节点动态更新数据。其中碰撞体组件会根据节点信息自动更新相应的形状数据，让碰撞体可以更贴合渲染模型。 更新数据，以模型组件举例： 模型组件会根据绑定节点自动更新模型的世界矩阵，从而实现改变节点的位置、缩放、旋转等信息，可以使渲染的模型有相应仿射变换。 但碰撞体的有些性质导致缩放的处理不太一样： 碰撞体一般用几何结构来描述 碰撞体大部分都是凸包类型 这些性质限制了切变、非均一缩放等变换，以球举例： 假设绑定节点的缩放信息是 (1,2,1)(非均一缩放)，由于模型和碰撞体描述的结构不一样，球模型使用多个基础图元（如三角面）来表示，缩放后会形变成类似于鹅卵石的形状；但球碰撞体的使用半径大小来描述，缩放时会取数值最大的维度来缩放半径（这样是为了碰撞体尽可能的包围住模型），但缩放后还是一个球。 实现鹅软石 对于此类情况，可以用网格碰撞体来代替基础的碰撞体。 注：若需要支持动力学刚体，则必须开启 convex 功能。 物理材质 碰撞体拥有物理材质属性，相关内容在 物理材质 中有详细介绍，这里主要介绍共享和非共享的接口区别。 目前 Collider 组件提供了两个属性去访问和设置，分别为 material 和 sharedMaterial，它们的区别主要如下： 设置 sharedMaterial 或者 material 是一样的效果，在没有调用这些接口之前是共享状态，当发现设置的与当前引用不是同一实例时，后面获取 material 将不会生成新的材质实例，此时是非共享状态。 在共享状态前提下，获取 material 将会生成新的材质实例，以确保只有当前碰撞体引用了该材质，这样修改时不会影响到其他的碰撞体，之后就是非共享状态了。 获取 sharedMaterial 不会生成新的，而是直接返回引用。 "},"editor/project/physics-configs.html":{"url":"editor/project/physics-configs.html","title":"物理配置","keywords":"","body":"物理配置 物理配置用于配置各种常用属性，目前 2D/3D 共用一个配置。 属性说明 gravity 重力矢量，默认值 { x: 0, y: -10, z: 0 } allowSleep 是否允许系统进入休眠状态，默认值 true sleepThreshold 进入休眠的默认速度临界值，默认值 0.1，最小值 0 autoSimulation 是否开启自动模拟, 默认值 true fixedTimeStep 每步模拟消耗的固定时间，默认值 1/60，最小值 0 maxSubSteps 每步模拟的最大子步数，默认值 1，最小值 0 friction 摩擦系数，默认值 0.5 rollingFriction 滚动摩擦系数，默认值 0.1 spinningFriction 自旋摩擦系数，默认值 0.1 restitution 弹性系数，默认值 0.1 collisionMatrix 碰撞矩阵，仅用于初始化 碰撞矩阵 碰撞矩阵是物理分组掩码功能的进一步封装，它用于初始化物理元素的分组和掩码。 默认情况下只有一个 DEFAULT 分组，新建分组默认不与其它组碰撞。 分组的概念 在编辑器中，碰撞矩阵分组的存储格式为 {index, name}，index 是从 0 到 31 的位数，而 name 是该组的名称，新项目工程会有一个默认分组：{index: 0, name: 'DEFAULT'}。 点击 + 按钮可以新增分组。 注：新增分组的 index 和 name 均不能为空，且不能与现有项重复。 注：分组不可以删除，但可以修改分组的名称。 如何配置 以新增一个 water 分组为例： 这张表列出了所有的分组，你可以通过勾选来决定哪两组会进行碰撞检测。 如上图所示，DEFAULT和water是否会进行碰撞检测将取决于是否选中了对应的复选框。 根据上面的规则，在这张表里产生的碰撞对有： DEFAULT - water DEFAULT - DEFAULT 而不进行碰撞检测的分组对有： water - water 配置物理组件的分组 通过刚体组件上的 Group 属性来配置对应的物理元素的分组： "},"physics/physics-material.html":{"url":"physics/physics-material.html","title":"物理材质","keywords":"","body":"物理材质 在 Cocos Creator 中物理材质是一种资源，它记录了物体的表面信息，这些信息用来计算碰撞物体受到的摩擦力和弹力等。 属性 物理材质属性如下图所示： 属性 解释 friction 摩擦系数 restitution 回弹系数 当与其它表面接触时，这些系数用于计算相应的摩擦力和弹力。 创建 物理材质可以通过两种方式创建： 编辑器内创建 代码实例化 用编辑器创建的方式如下图所示： 代码中实例化： let newPmtl = new PhysicMaterial(); newPmtl.friction = 0.1; newPmtl.restitution = 0.1; 应用 目前物理材质以碰撞体为单位进行设置，每个 Collider 都具有一个 material 的属性（不设置时，Collider 将会引用物理系统中的默认物理材质）。 应用到 Collider 同样也分编辑器操作和代码操作两种方式。 编辑器内操作，只需要将资源拖入到cc.PhysicMaterial属性框中即可，如下图所示： 代码中操作： const collider = this.node.getComponent(Collider); collider.material = newPmtl; 因为材质共享的设计，实际在代码中可以直接这样操作（因为在获取 material 时会创建一个实例） collider.material.friction = 0.1; collider.material.restitution = 0.1; "},"physics/physics-rigidbody.html":{"url":"physics/physics-rigidbody.html","title":"使用刚体","keywords":"","body":"刚体组件 刚体是组成物理世界的基本对象，可以让一个节点受到物理影响并产生反应。 刚体组件用于控制模拟相关的部分属性： 点击 属性检查器 下方的 添加组件 -> Physics -> RigidBody，即可添加刚体组件到节点上。 刚体属性 属性 功能说明 Type 刚体类型，目前包括 DYNAMIC、STATIC 和 KINEMATIC，详情可查看下方介绍。 Mass 刚体的质量 AllowSleep 是否允许刚体进入休眠状态 Linear Damping 线性阻尼，用于减小刚体的线性速率，值越大物体移动越慢 Angular Damping 角阻尼，用于减小刚体的旋转速率，值越大刚体旋转越慢 Use Gravity 如果开启，刚体会受到重力影响 Linear Factor 线性因子，可影响刚体在每个轴向的线性速度变化，值越大刚体移动越快 Angular Factor 旋转因子，可影响刚体在每个轴向的旋转速度变化，值越大刚体旋转越快 刚体的 API 接口请参考 Class RigidBody。 获取刚体组件 // TypeScript const rigidBody = this.getComponent(RigidBody); 刚体类型 目前刚体类型包括 STATIC、DYNAMIC 和 KINEMATIC 三种。 STATIC，表示静态刚体，可用于描述静止的建筑物，若物体需要持续运动，应设置为 KINEMATIC 类型； DYNAMIC，表示动力学刚体，能够受到力的作用，请通过物理规律来运动物体，并且请保证质量大于 0； KINEMATIC，表示运动学刚体，通常用于表达电梯这类平台运动的物体，请通过 Transfrom 控制物体运动； 刚体质心 目前质心固定在刚体组件绑定的节点上，质心和碰撞体是相对关系。通过调整形状的偏移 center，可以使质心在形状上进行偏移。 注：为了使碰撞体更贴合模型，未来会增加改变质心的方法，以及动态计算质心的机制。 休眠和唤醒 休眠刚体 休眠刚体时，会将刚体所有的力和速度清空，使刚体停下来。 // 休眠 if (rigidBody.isAwake) { rigidBody.sleep(); } 唤醒刚体 // 唤醒 if (rigidBody.isSleeping) { rigidBody.wakeUp(); } 让刚体运动起来 针对不同的类型，让刚体运动的方式不同： 对于静态刚体，应当尽可能保持物体静止，但仍然可以通过 Transform 来改变物体的位置。 对于运动学刚体，应当通过改变 Transform 使其运动。 对于动力学刚体，需要改变其速度，有以下几种方式： 通过重力 刚体组件提供了 useGravity 属性，将 useGravity 属性设置为 true。 通过施加力 刚体组件提供了 applyForce 接口，签名为： applyForce (force: Vec3, relativePoint?: Vec3) 根据牛顿第二定律，可对刚体某点上施加力来改变物体的原有状态。 rigidBody.applyForce(new Vec3(200, 0, 0)); 通过扭矩 力与冲量也可以只对旋转轴产生影响，使刚体发生转动，这样的力叫做扭矩。 刚体组件提供了 applyTorque 接口，签名为： applyTorque (torque: Vec3) 通过此接口可以施加扭矩到刚体上，因为只影响旋转轴，所以不需要指定作用点。 通过施加冲量 刚体组件提供了 applyImpulse 接口，签名为： applyImpulse (impulse: Vec3, relativePoint?: Vec3) 根据动量守恒，对刚体某点施加冲量，由于物体质量恒定，从而使刚体改变原有状态。 rigidBody.applyImpulse(new Vec3(5, 0, 0)); 通过改变速度 线性速度 刚体组件提供了 setLinearVelocity 接口，可用于改变线性速度，签名为： setLinearVelocity (value: Vec3) 示例： rigidBody.setLinearVelocity(new Vec3(5, 0, 0)); 刚体组件提供了 setAngularVelocity 接口，可用于改变旋转速度，签名为： setAngularVelocity (value: Vec3) 示例： rigidBody.setAngularVelocity(new Vec3(5, 0, 0)); 限制刚体的运动 通过休眠 休眠刚体时，会将刚体所有的力和速度清空，使刚体停下来。 通过阻尼 刚体组件提供了 linearDamping 和 angularDamping 属性： linearDamping 属性用于设置线性阻尼。 angularDamping 属性用于设置旋转阻尼。 阻尼参数的范围建议在 0 到 1 之间，0 意味着没有阻尼，1 意味着满阻尼。 注：执行部分接口，例如施加力或冲量、改变速度、分组和掩码会尝试唤醒刚体。 通过因子 刚体组件提供了 linearFactor 和 angularFactor 属性: linearFactor 属性用于设置线性因子。 angularFactor 属性用于设置旋转因子。 因子是 Vec3 的类型，相应分量的数值用于缩放相应轴向的速度变化，默认值都为 1，表示缩放为 1 倍，即无缩放。 注意： 将因子某分量值设置为0，可以固定某个轴向的移动或旋转。 在 cannon 和 ammo 后端中，因子作用的物理量不同，cannon 中作用于速度，ammo 中作用于力。 "},"physics/physics-event.html":{"url":"physics/physics-event.html","title":"物理事件","keywords":"","body":"物理事件 Cocos Creator 3.0 的物理事件包括 触发事件 和 碰撞事件，分别由 触发器 和 碰撞器 产生。 触发器和碰撞器 触发器是 Is Trigger 属性为 true 的碰撞组件。当发生碰撞时，触发器不会产生碰撞效果，所以触发器只用于碰撞检测。 碰撞器是 Is Trigger 属性为 false 的碰撞组件。当发生碰撞时，碰撞器会产生碰撞效果，所以碰撞器既可以进行碰撞检测，又可以产生物理效果。 两者的区别如下： 触发器不会与其它触发器或者碰撞器做更精细的检测。 碰撞器与碰撞器会做更精细的检测，并会产生碰撞数据，如碰撞点、法线等。 触发事件和碰撞事件 触发事件和碰撞事件两者的区别在于： 触发事件由触发器生成，碰撞事件根据碰撞数据生成。 触发事件可以由触发器和另一个触发器/碰撞器产生。 碰撞事件需要由两个碰撞器产生，并且至少有一个是动力学刚体。 触发事件 触发事件目前包括以下三种： 事件 说明 onTriggerEnter 触发开始 onTriggerStay 触发保持 onTriggerExit 触发结束 其中可产生触发事件的碰撞对为： 类型 静态刚体 运动学刚体 动力学刚体 静态刚体 ✔ ✔ 运动学刚体 ✔ ✔ ✔ 动力学刚体 ✔ ✔ ✔ 注意：前提是两者都必须带有碰撞组件，并且至少有一个是触发器类型。 监听触发事件 需要通过注册事件来添加相应的回调： 通过this.getComponent(Collider)获取到 Collider 通过 Collider 的 on 或者 once 方法注册相应事件的回调 注：Collider 是所有碰撞组件的父类。 代码示例： public start () { let Collider = this.getComponent(Collider); Collider.on('onTriggerStay', this.onTrigger, this); } private onTrigger (event: ITriggerEvent) { console.log(event.type, event); } 碰撞事件 碰撞事件根据碰撞数据生成，静态类型的刚体之间不会产生碰撞数据。 目前碰撞事件包括以下三种： 事件 说明 onCollisionEnter 碰撞开始 onCollisionStay 碰撞保持 onCollisionExit 碰撞结束 其中可产生碰撞事件的碰撞对为： 类型 静态刚体 运动学刚体 动力学刚体 静态刚体 ✔ ✔ 运动学刚体 ✔ ✔ ✔ 动力学刚体 ✔ ✔ ✔ 注意：前提是两者都必须带有碰撞组件，并且都必须是碰撞器类型。 监听碰撞事件 监听碰撞事件需要通过注册事件来添加相应的回调： 通过 this.getComponent(Collider) 获取到 Collider 通过 Collider 的 on 或者 once 方法注册相应事件的回调 代码示例： public start () { let Collider = this.getComponent(Collider); Collider.on('onCollisionStay', this.onCollision, this); } private onCollision (event: ICollisionEvent) { console.log(event.type, event); } 注意：目前碰撞事件以物理元素为单位，所有该元素上的碰撞器组件都会接收到碰撞事件。 "},"physics/physics-group-mask.html":{"url":"physics/physics-group-mask.html","title":"分组和掩码","keywords":"","body":"分组掩码 在 Cocos Creator 中，部分物理组件（目前有刚体组件和碰撞器组件）提供了设置分组和掩码的接口。 共享 在 Cocos Creator 中，目前物理元素和节点是一对一的关系，分组和掩码是属于物理元素的，单个节点上的物理组件修改的都是节点对应物理元素的分组和掩码。 原理 只要以下条件为真就会进行检测 (GroupA & MaskB) && (GroupB & MaskA) 例如：两个物理元素 A 和 B。 A 的分组值为 1，掩码值为 3 B 的分组值为 2，掩码值为 2 算式 (1 & 2) && (2 & 3) 为假，所以这里 A 不会和 B 进行检测。 这里通过 B 的掩码值为 2，可以知道 B 可检测的组是 1，而 A 在的组是 0，所以不检测。 注：表达式依赖位运算，JavaScript中位运算的操作数为32位，且最后一位是符号位，为避免超出运算范围，建议组的范围为[0, 31)。 分组 设置分组值 以下分组值为 3，二进制为 11，表示在第 0，1 组（从 0 开始） const group = (1 获取分组值 Collider.getGroup(); 添加分组值 上述代码基础上，经过以下代码后，分组值为 7，二进制为 111，所以表示在 0，1，2组。 const group = 1 减少分组值 上述代码基础上，经过以下代码后，分组值为 3，所以在 0，1 组。 const group = 1 注：推荐分组固定为一个位，并通过掩码来控制可检测的分组。 注：上述方法接收参数均为十进制数字，为方便理解，此处用二进制解释，开发者熟悉后也可直接传入十进制数字进行分组操作。 掩码 设置掩码值 以下 mask 的值 3，二进制为 11，表示可检测的组为 0，1。 const mask = (1 获取掩码值 console.log(Collider.getMask()); 添加掩码值 上述代码的基础上，经过以下代码后，增加了一个可检测组 3。 const mask = 1 减少掩码值 以下代码去掉了一个可检测组 3。 const mask = 1 注：加减符号的优先级高于位移符号。 注：灵活使用分组和掩码可以减少额外检测的消耗。 举例 以下列举了一个简单的使用示例： 定义分组 方式一：定义在一个 object 中 export const PHY_GROUP = { Group0: 1 方式二：定义在一个 enum 中（typescript only） enum PHY_GROUP { Group0 = 1 为了能够在面板上设置分组，需要通过 cc 模块导出的 Enum 函数，将定义好的分组注册到编辑器中 Enum(PHY_GROUP)。 注：由于历史原因，Enum 函数对 -1 有特殊处理，如果不熟悉，请勿定义值为 -1 的属性。 使用掩码 掩码可以根据分组进行定义，例如以下示例 定义一个只检测 Group1 的掩码 const maskForGroup1 = PHY_GROUP.Group1; 定义一个可检测 Group0 和 Group1 的掩码 const maskForGroup01 = PHY_GROUP.Group0 + PHY_GROUP.Group1; 定义一个所有组都不检测的掩码 const maskForNone = 0; 定义一个所有组都检测的掩码 const maskForAll = 0xffffffff; 查看二进制 在 JavaScript 的运行环境中通过执行 (value >>> 0).toString(2)，可以看到二进制的字符串表示。 碰撞矩阵 碰撞矩阵是对分组掩码配置的进一步封装，它提供了一种更加统一的管理方式，用于初始化刚体的分组和掩码，同时也无需书写任何代码即可完成初始化配置。 具体请参考碰撞矩阵设置。 "},"physics/physics-raycast.html":{"url":"physics/physics-raycast.html","title":"射线检测","keywords":"","body":"射线检测 射线检测是非常重要的功能，常常用来判断各种情况。其本质是对一条射线和另一个形状进行 相交性判断，如下图所示。 构造射线 射线 ray 处于 cc 模块的 geometry 命名空间下，因此访问 ray 需要先导入 geometry： import { geometry } from 'cc'; 射线 ray 由 起点 和 方向 组成，构造一条射线有以下几种比较常见的方法： 通过 起点 + 方向，ray 的构造函数或静态接口 create： import { geometry } from 'cc'; const { ray } = geometry; // 构造一条从（0，-1，0）出发，指向 Y 轴的射线 // 前三个参数是起点，后三个参数是方向 const outRay = new ray(0, -1, 0, 0, 1, 0); // 或者通过静态方法 create const outRay2 = ray.create(0, -1, 0, 0, 1, 0); 通过 起点 + 射线上的另一点，ray 的静态接口 fromPoints: import { geometry, Vec3 } from 'cc'; // 构造一条从原点出发，指向 Z 轴的射线 const outRay = new geometry.ray(); geometry.ray.fromPoints(outRay, Vec3.ZERO, Vec3.UNIT_Z); 用相机构造一条从相机原点到屏幕某点发射出的射线： import { geometry, Camera } from 'cc'; const { ray } = geometry; // 此处假设已经有 cameraCom 的引用了 const cameraCom: Camera; // 获得一条途径屏幕坐标（0，0）发射出的一条射线 const outRay = new ray(); cameraCom.screenPointToRay(0, 0, outRay); 注意： 首先需要获取一个相机组件或者相机实例的引用。 相机组件和相机实例两者暴露的接口参数顺序不一样。 接口介绍 Cocos Creator 提供了一套基于物理引擎的射线检测功能。 但需要注意的是，检测的对象是物理碰撞器，在场景面板上与之对应的是碰撞器组件，例如 BoxCollider。 目前接口由 PhysicsSystem 提供，有以下两类： raycast : 检测所有的碰撞体，返回布尔值, 表示是否检测成功。 raycastClosest：检测所有的碰撞体，同样返回布尔值。 参数说明： worldRay：世界空间下的射线 mask：用于过滤的掩码，可以传入需要检测的分组 maxDistance：最大检测距离，目前请勿传入 Infinity 或 Number.MAX_VALUE queryTrigger：是否检测触发器 获取结果 获取以上接口的检测结果，需分别通过以下方式： 获取 raycastAll 的检测结果：PhysicsSystem.instance.raycastResults 获取 raycastClosest 的检测结果：PhysicsSystem.instance.raycastClosestResult 注意：返回对象是只读并且复用的，每次调用检测接口后会更新相应结果。 结果存储的信息 信息由 PhysicsRayResult 进行存储，主要有以下信息： collider：击中的碰撞器 distance：击中点与射线起点的距离 hitPoint：击中点（世界坐标系中） hitNormal：击中点所处面的法线（世界坐标系中) "},"particle-system/":{"url":"particle-system/","title":"粒子系统","keywords":"","body":"粒子系统 粒子系统是游戏引擎特效表现的基础，它可以用于模拟的火、烟、水、云、雪、落叶等自然现象，也可用于模拟发光轨迹、速度线等抽象视觉效果。 Creator 目前支持 2D/3D 粒子系统，详情请参考： 2D 粒子 3D 粒子 "},"particle-system/2d-particle/2d-particle.html":{"url":"particle-system/2d-particle/2d-particle.html","title":"2D 粒子","keywords":"","body":"ParticleSystem2D 组件参考 2D 粒子组件（ParticleSystem2D）用于读取粒子资源数据，并对其进行一系列例如播放、暂停、销毁等操作。粒子资源支持 plist 文件和图片，这两个资源建议放在同一个文件夹下。 点击 属性检查器 下方的 添加组件 按钮，然后从 Effects 中选择 ParticleSystem2D，即可添加 ParticleSystem2D 组件到节点上。 ParticleSystem2D 的脚本接口请参考 ParticleSystem API。 ParticleSystem2D 属性 属性 功能说明 CustomMaterial 自定义材质，使用方法可参考 自定义材质 SrcBlendFactor 源混合因子。可参考 SrcBlendFactor API DstBlendFactor 目标混合因子。可参考 DstBlendFactor API Color 粒子颜色 Preview 在编辑器模式下预览粒子，启用后选中粒子时，粒子将在 场景编辑器 中自动播放 PlayOnLoad 若勾选该项，则运行时会自动发射粒子 AutoRemoveOnFinish 粒子播放完毕后自动销毁所在的节点 File Plist 格式的粒子配置文件 Custom 自定义粒子属性。开启该属性后可自定义以下部分的粒子属性 SpriteFrame 自定义的粒子贴图 Duration 粒子系统运行时间，单位为 秒，-1 表示持续发射 EmissionRate 每秒发射的粒子数目 Life 粒子的运行时间以及变化范围 TotalParticle 粒子最大数量 StartColor 粒子初始颜色 EndColor 粒子结束颜色 Angle 粒子角度及变化范围 StartSize 粒子的初始大小及变化范围 EndSize 粒子结束时的大小及变化范围 StartSpin 粒子开始自旋角度及变化范围 EndSpin 粒子结束自旋角度及变化范围 PosVar 发射器位置的变化范围（横向和纵向） PositionType 粒子位置类型，包括 FREE、RELATIVE、GROUPED 三种。详情可参考 PositionType API EmitterMode 发射器类型，包括 GRAVITY、RADIUS 两种。详情可参考 EmitterMode API Gravity 重力。仅在 Emitter Mode 设为 GRAVITY 时生效 Speed 速度及变化范围。仅在 Emitter Mode 设为 GRAVITY 时生效 TangentialAccel 每个粒子的切向加速度及变化范围，即垂直于重力方向的加速度。仅在 Emitter Mode 设为 GRAVITY 时生效 RadialAccel 粒子径向加速度及变化范围，即平行于重力方向的加速度。仅在 Emitter Mode 设为 GRAVITY 时生效 RotationIsDir 每个粒子的旋转是否等于其方向。仅在 Emitter Mode 设为 GRAVITY 时生效 StartRadius 初始半径及变化范围，表示粒子发射时相对发射器的距离。仅在 Emitter Mode 设为 RADIUS 时生效 EndRadius 结束半径及变化范围。仅在 Emitter Mode 设为 RADIUS 时生效 RotatePerS 粒子每秒围绕起始点的旋转角度及变化范围。仅在 Emitter Mode 设为 RADIUS 时生效 更多具体的使用方式可参考官方范例 ui/25.particle（GitHub | Gitee）。 "},"particle-system/overview.html":{"url":"particle-system/overview.html","title":"3D 粒子","keywords":"","body":"3D 粒子系统 粒子系统是游戏引擎特效表现的基础，它可以用于模拟的火、烟、水、云、雪、落叶等自然现象，也可用于模拟发光轨迹、速度线等抽象视觉效果。 基本结构 粒子系统的基本单元是粒子，一个粒子一般具有位置、大小、颜色、速度、加速度、生命周期等属性。在每一帧中，粒子系统一般会执行如下步骤： 产生新的粒子，并初始化 删除超过生命周期的粒子 更新粒子的动态属性 渲染所有有效的粒子 粒子系统一般由以下几个部分组成： 发射器，用于创建粒子，并初始化粒子的属性 影响器，用于更新粒子的属性 渲染器，渲染粒子 粒子类，存储粒子的属性 粒子系统类，管理上面的模块 添加 3D 粒子系统 在编辑器中添加粒子系统组件有以下两种方式： 在 层级管理器 中选中节点，然后点击右侧 属性检查器 面板上的 添加组件 按钮添加粒子，如下图： 在左侧的 层级管理器 面板中点击鼠标右键，然后选择 创建 -> 特效 -> 粒子系统，即可创建一个带有粒子系统组件的节点，如下图： 添加完成后，粒子在 场景编辑器 中显示如下： 右下角的粒子系统控制面板用于控制粒子的播放暂停等，详情请参考 粒子控制面板。 内容 粒子系统主要包括以下两部分内容： 粒子系统模块 粒子属性编辑 "},"particle-system/module.html":{"url":"particle-system/module.html","title":"粒子系统模块","keywords":"","body":"粒子系统模块介绍 Cocos Creator 的 粒子系统 存储了粒子发射的初始状态以及粒子发射后的状态更新子模块。 粒子系统在 属性检查器 中的属性如下： 粒子系统可设置的属性较多，我们使用“模块”来组织分类功能，包括以下模块： 模块 说明 Node 粒子节点，用于设置粒子发射器的位置、方向、大小、渲染层级等属性。 ParticleSystem（主模块） 用于存储在 属性检查器 中显示的所有数据，管理粒子生成、播放、更新，以及销毁相关模块资源。 ShapeModule（发射器模块） 用于控制粒子发射，包括发射方向与速度，支持预定义的发射方向，包括盒子、圆、锥体、球和半球。 AnimatorModule（状态更新模块） 用于控制粒子发射后的状态更新。已支持的功能包括：速度模块（VelocityOvertimeModule）加速模块（ForceOvertimeModule）大小模块（SizeOvertimeModule）旋转模块（RotationOvertimeModule）颜色模块（ColorOvertimeModule）贴图动画模块（TextureAnimationModule）限速模块（LimitVelocityOvertimeModule）拖尾模块（TrailModule） Renderer（渲染模块） 用于生成粒子渲染所需要的数据。 "},"particle-system/main-module.html":{"url":"particle-system/main-module.html","title":"主模块","keywords":"","body":"主模块（ParticleSystem） 粒子系统主模块用于存储在 属性检查器 中显示的所有数据，管理粒子生成、播放、更新，以及销毁。 属性 功能 Duration 粒子系统单次运行一个周期的时间（s），也就是产生第一个粒子到最后一个粒子之间的时间 Capacity 粒子系统能生成的最大粒子数量 Loop 粒子系统是否循环播放 PlayOnAwake 粒子系统加载后是否自动开始播放 Prewarm 是否启用预热模式。若勾选该项，粒子系统会以已播放完一轮之后的状态开始播放（仅当勾选 Loop 时生效） SimulationSpace 控制粒子系统所在的坐标系。Local：基于本地坐标系World：基于世界坐标系 SimulationSpeed 控制整个粒子系统的运行速度 StartDelay 粒子系统开始运行后，粒子延迟发射的时间（仅当不勾选 Prewarm 时生效） StartLifetime 粒子生命周期（s），单个粒子从产生到消失的时间 StartColor 粒子初始颜色 ScaleSpace 粒子缩放时所在的坐标系：Local：基于本地坐标系的缩放World：基于世界坐标系的缩放Custom（目前暂不支持）：自定义缩放，不受节点的 scale 属性影响 StartSize3D 分别设置粒子 X、Y、Z 轴的初始大小。一般情况下，只需要设置 X 和 Y 轴即可。只有当粒子 Renderer 模块 的 RenderMode 属性设置为 Mesh 时，设置 Z 轴才有必要 StartSize 粒子在 X、Y 方向的初始大小，与 StartSize3D 属性二者只能选其一。若在勾选了 StartSize3D 后切换使用该项，则该项会使用 StartSize3D 中设置的 StartSizeX 的值 StartSpeed 粒子初始速度 StartRotation3D 分别设置粒子 X、Y、Z 轴的初始旋转角度 StartRotation Z 轴初始旋转角度，与 StartRotation3D 属性二者只能选其一。若在勾选了 StartRotation3D 后切换使用该项，则该项会使用 StartRotation3D 中设置的 StartRotationZ 的值 GravityModifier 粒子受重力影响的重力系数。该项只支持 CPU 粒子，当 渲染模块 中勾选 UseGPU 时不生效 RateOverTime 每秒发射的粒子数 RateOverDistance 发射器每移动一个单位距离发射的粒子数 Bursts 设定在指定时间发射指定数量粒子的 Burst 数量。可通过以下几个属性调整：Time：粒子播放多长时候后开始发射 BurstRepeatCount：在粒子生命周期内 Burst 的发射次数RepeatInterval：每次发射的时间间隔Count：每次发射的粒子数量 EnableCulling 粒子系统资源剔除，详情请参考下文说明 点击上述部分属性输入框右侧的 按钮，即可开启粒子曲线/渐变色编辑器，对粒子属性进行编辑，详情请参考 粒子属性编辑。 粒子系统组件接口请参考 ParticleSystem API。 粒子系统资源剔除 EnableCulling 选项用于剔除粒子系统中无用模块的资源数据。 粒子系统中各个模块都是作为独立对象存在，每个模块都会存储一些模块相关的数据，因此对于未勾选使用的模块，其记录的数据都是无用数据。当开发者不需要在运行时动态开启这些未使用的模块，可以勾选 EnableCulling 选项，对这些无用数据进行剔除，从而减小资源占用。 "},"particle-system/emitter.html":{"url":"particle-system/emitter.html","title":"发射器模块","keywords":"","body":"发射器模块（ShapeModule） 发射器模块主要用于设置粒子发射器形状、粒子发射方向和速度。 ShapeType 属性用于选择粒子发射器形状，可选项包括 盒子（Box）、圆形（Circle）、锥体（Cone）、球（Sphere）、半球（Hemisphere）。当形状选择不同时，可发射粒子的区域不同，相对应的属性设置项也不一致，详情请参考下文对应形状发射器的说明。 通用属性 各类型发射器有一些属性是通用的，包括： 属性 功能说明 ShapeType 发射器形状。目前支持 盒子（Box）、圆形（Circle）、锥体（Cone）、球（Sphere）、半球（Hemisphere）这几种类型。 Position 发射器相对于所在节点的位置 Rotation 发射器相对于所在节点的旋转，可用于调整粒子发射方向 Scale 发射器相对于所在节点的缩放，可用于调整发射器形状的大小，即粒子发射范围 AlignToDirection 根据粒子发射的初始方向决定粒子的移动方向，可用于模拟类似水从水桶中洒出的效果 RandomDirectionAmount 粒子生成方向随机混合设定。设置为 0 时，不生效；设置为 1 时，方向随机 SphericalDirectionAmount 表示当前发射方向与当前位置到节点中心连线方向的插值。当该值设置为 1 时，粒子由中心向外部发射（与 ShapeType 设置为 Sphere 时的行为相同） RandomPositionAmount 粒子生成位置随机设定，当该值设置 不为 0 时，粒子生成位置会超出生成器的大小范围 盒子发射器 当 ShapeType 属性设置为 Box 时，我们称之为盒子发射器： 特有的属性项说明如下： 属性 功能说明 EmitFrom 发射器从盒子的哪个部位发射粒子，包括：Volume：从盒子内部发射Shell：从盒子表面发射Edge：从盒子边框发射 BoxThickness 盒子每个发射方向的厚度，仅当 EmitFrom 选择 Shell 模式时生效 同时在 场景编辑器 中会有一个盒子 Gizmo，显示盒子发射器的形状大小： 直接拖拽盒子 Gizmo 的方块控制点可以调整盒子发射器的 Scale 属性： 圆发射器 当 ShapeType 属性设置为 Circle 时，我们称之为圆发射器： 特有的属性项说明如下： 属性 功能说明 Radius 设置圆发射器的半径 RadiusThickness 圆发射器发射粒子的位置。设置为 0 时，表示从圆周发射设置为 1 时，表示从圆心发射设置为 0~1 之间时，表示从圆心到圆周之间，在一定的比例范围内发射 Arc 设置圆发射器发射粒子的扇形区域 ArcMode 设置粒子在扇形区域的发射方式，包括：Random：随机发射Loop：沿某一方向循环发射，每次循环方向相同PingPong：循环发射，每次循环方向都与上一次相反 ArcSpread 设置可能产生粒子的圆弧周围的离散间隔。例如：设置为 0 时，可在圆弧任意位置生成粒子；设置为 0.2 时，仅在圆弧周围以 20% 的间隔生成粒子。 ArcSpeed 表示粒子沿圆弧发射的速度。点击右侧的向下图标按钮，即可选择打开曲线编辑器对该属性进行曲线编辑 同时在 场景编辑器 中会有一个圆形 Gizmo，显示发射器的形状大小： 直接拖拽圆形 Gizmo 的方块控制点可以调整圆发射器的 Radius 属性： 圆锥发射器 当 ShapeType 属性设置为 Cone 时，我们称之为圆锥发射器。在 场景编辑器 中会有一个圆锥 Gizmo，显示发射器的形状大小： 下文以上方图示为例，圆锥下方半径较小的横截面称为圆锥底部。 圆锥发射器的属性在 属性检查器 中显示如下： 特有的属性项说明如下： 属性 功能说明 EmitFrom 发射器从圆锥的哪个部位发射粒子，包括：Base：从圆锥底部发射Shell：从圆锥底部的圆周发射Volume：从圆锥内部发射 Radius 设置圆锥底部横截面的半径 RadiusThickness 圆锥发射器发射粒子的位置。设置为 0 时，表示从圆锥表面发射设置为 1 时，表示从圆锥中心发射设置为 0~1 之间时，表示从圆锥的中心到表面之间，在一定的比例范围内发射 Angle 圆锥的轴与母线的夹角，值越大夹角越大，圆锥发射器的开合程度越大 Arc 设置圆锥发射器发射粒子的扇形区域 ArcMode 表示粒子在扇形区域内的发射方式。Random：随机位置Loop：沿某一方向循环发射，每次循环方向相同PingPong：循环发射，每次循环方向相反spread：表示粒子在某个间断发射，比如，0 表示可以在任意位置发射；0.1 表示每隔圆周的十分之一位置发射 ArcSpeed 表示粒子沿圆弧发射的速度 ArcSpread 表示粒子沿圆弧发射的速度。点击右侧的向下图标按钮，即可选择打开曲线编辑器对该属性进行曲线编辑 Length 圆锥顶部截面距离底部的轴长 其中圆锥发射器的 Angle、Length、Radius 属性也可以通过直接拖拽场景中圆锥 Gizmo 的方块控制点进行设置。 球体/半球体发射器 当 ShapeType 属性设置为 Sphere/Hemisphere 时，我们称之为球体/半球体发射器。 球体发射器和半球体发射器的属性是一样的，这里我们以球体发射器为例： 特有的属性项说明如下： 属性 功能说明 EmitFrom 发射器从球体的哪个部位发射粒子，包括：Volume：从球体内部发射Shell：从球体表面发射（暂不生效，可通过 RadiusThickness 设置） Radius 球体半径。也可以直接拖拽 场景编辑器 中球体 Gizmo 的方块控制点进行设置 RadiusThickness 球体发射器发射粒子的位置。设置为 0 时，表示从球表面发射设置为 1 时，表示从球体中心发射设置为 0~1 之间时，表示从表面到球心之间，在一定的比例范围内发射 球体发射器在 场景编辑器 中会有一个球 Gizmo，显示发射器的形状大小： 同样的，半球体发射器在 场景编辑器 中也有一个半球 Gizmo，显示发射器的形状大小： "},"particle-system/velocity-module.html":{"url":"particle-system/velocity-module.html","title":"速度模块","keywords":"","body":"速度模块（VelocityOvertimeModule） 速度模块用于控制粒子在生命周期内的速度。 属性 属性 说明 Space 选择粒子进行速度计算时基于 世界坐标系（World）或者 本地坐标系（Local）（Custom 目前暂不支持） X X 轴方向上的速度分量 Y Y 轴方向上的速度分量 Z Z 轴方向上的速度分量 SpeedModifier 速度修正系数，只支持 CPU 粒子。当 Renderer 模块 中勾选 UseGPU 属性时不生效 部分属性输入框右侧有 按钮的，可点击选择对属性进行曲线编辑，详情请参考 曲线编辑。 "},"particle-system/force-module.html":{"url":"particle-system/force-module.html","title":"加速度模块","keywords":"","body":"加速度模块（ForceOvertimeModule） 通过该模块可对粒子进行加速，以模拟类似风的效果。 属性 属性 说明 Space 加速度计算时选择基于 世界坐标系（World）或者 本地坐标系（Local）（Custom 目前暂不支持） X X 轴方向上的加速度分量 Y Y 轴方向上的加速度分量 Z Z 轴方向上的加速度分量 点击属性输入框右侧的 按钮，可选择对属性进行曲线编辑，详情请参考 曲线编辑器。 "},"particle-system/size-module.html":{"url":"particle-system/size-module.html","title":"大小模块","keywords":"","body":"大小模块（SizeOvertimeModule） 大小模块用于设置粒子在其生命周期内的大小，从而实现类似大小不一的火焰和雪花等粒子效果。 属性 属性 说明 SeparateAxes 是否在 X、Y、Z 轴上分别设置粒子大小。当点击输入框右侧的 按钮，切换使用曲线编辑时，表示是否三个轴分开进行缩放，详情请参考下文 非均匀粒子缩放 部分的内容。 Size 设置粒子大小。当切换使用曲线编辑时，可设置粒子大小随时间变化的曲线。该项与 separateAxes 属性，二者只能选其一。 非均匀粒子缩放 勾选 SeparateAxes 属性，点击出现的 X、Y、Z 属性框右侧的 按钮，选择 Curve，切换到曲线编辑模式。便可分别定义曲线指定粒子在其生命周期中 X、Y、Z 轴方向上的大小变化（Z 仅用于网格粒子）。 详情请参考 曲线编辑器。 "},"particle-system/rotation-module.html":{"url":"particle-system/rotation-module.html","title":"旋转模块","keywords":"","body":"旋转模块（RotationOvertimeModule） 旋转模块用于设置粒子运行时在移动中旋转，可用于模拟类似下落的雪花这类随机旋转特效。 属性 属性 说明 SeparateAxes 是否分开设置三个轴的粒子旋转（预计在 v3.3 支持该功能） X、Y、Z 绕 X、Y、Z 轴设定旋转角速度。其中 X、Y 仅在勾选 SeparateAxes 属性后显示。 点击属性输入框右侧的 按钮，可选择对属性进行曲线编辑，详情请参考 曲线编辑器。 "},"particle-system/color-module.html":{"url":"particle-system/color-module.html","title":"颜色模块","keywords":"","body":"颜色模块（ColorOvertimeModule） 颜色模块用于设置粒子颜色及粒子在生命周期内的颜色变化。 属性 属性 说明 Color 设置粒子颜色随时间变化发生渐变。点击右侧的 按钮，可选择使用不同的颜色变化模式，详情请参考 渐变色编辑。 "},"particle-system/texture-animation-module.html":{"url":"particle-system/texture-animation-module.html","title":"贴图动画模块","keywords":"","body":"贴图动画模块（TextureAnimationModule） 贴图动画模块用于将 渲染模块 中 ParticleMaterial 属性指定的贴图纹理作为动画帧进行动态播放，用于实现类似下图中的效果： 属性 属性 说明 Mode 设定粒子动画贴图的类型，目前只支持 Grid（网格）模式。一张贴图包含一个粒子播放的动画帧。 NumTilesX 贴图纹理在水平（X）方向上划分的贴图数量。 NumTilesY 贴图纹理在垂直（Y）方向上划分的贴图数量。 Animation 动画播放方式，包括： WholeSheet：播放贴图中的所有帧；SingleRow：只播放其中一行，默认第一行。可搭配 RandomRow 和 RowIndex 属性使用。 RandomRow 随机从动画贴图中选择一行播放动画帧。该项仅在 Animation 设置为 SingleRow 时生效。 RowIndex 从动画贴图中选择特定行以播放动画帧。该项仅在 Animation 设置为 SingleRow 并且禁用 RandomRow 时生效。 FrameOverTime 设置动画播放速度。当点击输入框右侧的 按钮，切换使用曲线编辑时，表示一个周期内动画播放的帧与时间变化曲线。 StartFrame 指定动画在整个粒子系统生命周期的第几帧开始播放。 CycleCount 动画帧在粒子生命周期内重复播放的次数。 "},"particle-system/limit-velocity-module.html":{"url":"particle-system/limit-velocity-module.html","title":"限速模块","keywords":"","body":"限速模块（LimitVelocityOvertimeModule） 限速模块用于设置粒子的速度在生命周期内逐渐减缓。 属性 说明 Space 速度计算时选择基于 世界坐标系（World）或者 本地坐标系（Local）（Custom 目前暂不支持） Dampen 当前速度与速度下限的插值 SeparateAxes 是否在 X、Y、Z 轴上分别限制粒子速度。若勾选该项，则可设置：LimitX：X 轴方向上的速度下限LimitY：Y 轴方向上的速度下限LimitZ：Z 轴方向上的速度下限 Limit 速度下限。若当前速度超出该值时，当前速度将会与速度下限进行线性插值。该项仅在不勾选 SeparateAxes 时生效 点击属性输入框右侧的 按钮，可选择对属性进行曲线编辑，详情请参考 曲线编辑。 "},"particle-system/trail-module.html":{"url":"particle-system/trail-module.html","title":"拖尾模块","keywords":"","body":"轨迹模块（TrailModule） 轨迹模块用于在粒子尾部添加一个轨迹效果，实现类似下图中的拖尾效果： 属性 属性 说明 Mode 粒子系统生成拖尾的方式，目前仅支持 Particles，表示在每个粒子的运动轨迹上都行成拖尾效果。 LifeTime 生成的拖尾的生命周期。 MinParticleDistance 粒子每生成一个拖尾节点所运行的最短距离。 Space 选择拖尾运行时基于 世界坐标系（World）或者 本地坐标系（Local）（Custom 目前暂不支持） TextureMode 当在 渲染模块 中指定了 TrialMaterial 贴图时，贴图在拖尾上的展开形式。目前仅支持 Stretch，表示将贴图覆盖在整条拖尾上。 WidthFromParticle 拖尾宽度跟随粒子大小 WidthRatio 拖尾宽度。若勾选 WidthFromParticle，则拖尾宽度为例子大小乘以比例。 ColorFromParticle 拖尾颜色是否跟随粒子初始颜色 ColorOverTrail 拖尾颜色随着拖尾自身长度的变化而变化 ColorOvertime 拖尾颜色随着时间的变化而变化 点击属性输入框右侧的 按钮，可选择对属性进行曲线编辑/渐变色编辑，详情请参考 粒子属性编辑。 "},"particle-system/renderer.html":{"url":"particle-system/renderer.html","title":"渲染模块","keywords":"","body":"渲染模块（Renderer） 渲染模块用于生成粒子渲染所需要的数据。 属性 说明 RenderMode 设置粒子的生成方式，包括：Billboard：粒子显示为公告牌，并始终面向摄像机；StretchedBillboard：粒子始终面向摄像机，但会根据相关参数进行拉伸；HorizontalBillboard：粒子始终与 X-Z 平面平行VerticalBillboard：粒子始终与 Y 轴平行，但会朝向摄像机；Mesh：以指定的网格资源渲染粒子。 VelocityScale 当 RenderMode 设置为 StretchedBillboard 模式时，根据粒子 速度大小 按比例进行拉伸。当设置为 0 时，可禁用基于速度的拉伸。 LengthScale 当 RenderMode 设置为 StretchedBillboard 模式时，根据粒子 大小 按比例进行拉伸。当设置为 0 时，相当于粒子大小为 0，粒子会消失。 Mesh 当 RenderMode 设置为 Mesh 时，指定粒子渲染的网格资源。 ParticleMaterial 用于粒子渲染的材质。当使用 CPU 渲染器，也就是不勾选 UseGPU 时，材质使用的 effect 只能选择 Creator 内置的 builtin-particle，不支持其它的 effect。当使用 GPU 渲染器，也就是勾选 UseGPU 时，材质使用的 effect 只能选择 Creator 内置的 builtin-particle-gpu，不支持其它的 effect。 TrailMaterial 用于渲染粒子拖尾的材质，材质的 effect 只支持 builtin-particle-trail，不支持其它的 effect。 UseGPU 若不勾选该项（默认），使用 CPU 渲染器 进行粒子的渲染。若勾选该项，使用 GPU 渲染器 进行粒子的渲染。详情请参考下文 粒子渲染器 部分的内容。 粒子渲染器 粒子渲染部分由 渲染器 ParticleSystemRenderer 控制，渲染器分为 CPU 渲染器（默认）和 GPU 渲染器，可通过渲染模块中的 UseGPU 属性选择使用。 CPU 渲染器（ParticleSystemRendererCPU）通过一个对象池来维护所有粒子，根据粒子当前状态来生成对应的 VB、IB 数据，持有粒子需要渲染的材质，并且保存相关渲染状态。粒子系统默认使用 CPU 渲染器。 GPU 渲染器（ParticleSystemRendererGPU）目前是在 CPU 端生成粒子，只提交初始参数的 VB、IB 数据，但模块相关的计算则是通过预采样数据的形式，在初始化时提交一次数据。后续的模块系统则是在 GPU 端对数据进行提取模拟运算，减少 CPU 端的计算压力。 可通过勾选 UseGPU 属性选择使用 GPU 渲染器。目前暂不支持 拖尾模块 和 限速模块。 "},"particle-system/editor/":{"url":"particle-system/editor/","title":"粒子属性编辑","keywords":"","body":"粒子属性编辑 Creator 提供了 粒子控制面板、曲线编辑器 和 渐变色编辑器，用于控制粒子播放，以及编辑粒子属性等。 详情请参考： 粒子控制面板 曲线编辑器 渐变色编辑器 "},"particle-system/editor/curve-editor.html":{"url":"particle-system/editor/curve-editor.html","title":"曲线编辑器","keywords":"","body":"曲线编辑器 曲线编辑器 支持设置粒子系统中部分属性随时间变化的曲线。属性默认都是以常量（Constant）的形式显示，点击属性框右侧的 按钮，可以看到有以下几种编辑形式： 根据选择的编辑模式不同，属性框的显示也有一定的差异： Constant：设置属性的常量值，该值在粒子整个生命周期内不会发生变化； Curve：属性切换为曲线编辑形式，点击属性框即可打开曲线编辑器，编辑属性值随时间变化的曲线图； TwoCurves：通过两条曲线设定属性值随时间变化时，在生命周期内某一点的上、下限，取随机值。 TwoConstant：通过两个常量值设定属性值的范围，实际值会随着时间推移在范围内随机变化。 曲线编辑面板 属性切换为曲线编辑后（Curve/TwoCurve 模式），属性框会显示当前曲线的预览图： 注意：若属性的取值范围包括负值，则属性框中的预览图显示为： 然后点击属性框即可打开曲线编辑器进行编辑： 曲线编辑器面板的相关功能说明如下： 当前进行曲线编辑的属性名称会以黄色字体显示在面板左上角。 横坐标 表示粒子单位化的生命周期，由引擎定义，无法调整，一般为 [0, 1]。例如一个粒子的生命周期为 5s，则横坐标上的 0.5 代表 2.5s。 纵坐标 表示当前编辑的属性的取值范围，可通过纵坐标上方的输入框调整纵坐标区间。 preWrapMode/postWrapMode：设置粒子在生命周期范围内，曲线前后若有未定义部分时，粒子系统播放曲线的方式。详情请参考下文 前后循环模式 部分的内容。 Creator 提供了一些预设粒子曲线模板，单击下方中某个模板便可直接将其应用到当前曲线中。 曲线编辑 在曲线编辑器窗口点击选中曲线后，曲线会显示为橙色。然后便可执行以下关键帧操作： 在曲线上点击右键即可添加关键帧 单击选中关键帧后，可拖动关键帧改变其坐标。点击关键帧左右两侧出现的线段拉杆，转动拉杆即可调整该关键帧所在的点的曲线斜率 右键点击关键帧后即可删除关键帧 前后循环模式 preWrapMode 和 postWrapMode 用于设置在粒子生命周期范围内，曲线前后有未定义部分时，粒子系统播放曲线的方式。 例如下图中曲线只定义了横坐标为 [0.2, 0.8] 区间的部分，而 [0, 0.2] 和 [0.8, 1]部分曲线没有定义，便可分别通过 preWrapMode 和 postWrapMode 设置其循环模式，曲线编辑器便会根据循环模式和曲线定义部分决定未定义部分的曲线变化： 循环模式包括以下几种： Loop：将整条曲线（包括定义部分和未定义部分）当做是无限连续循环的。 Ping Pong：与 Loop 类似，但循环方式是以与曲线定义部分反向再正向（“乒乓”），如此往复的形式。 Clamp：曲线前/后未定义部分会使用曲线定义部分第一帧/最后一帧的值。 注意：若曲线前后没有未定义部分，则设置 preWrapMode 和 postWrapMode 无效。 "},"particle-system/editor/gradient-editor.html":{"url":"particle-system/editor/gradient-editor.html","title":"渐变色编辑器","keywords":"","body":"渐变色编辑器 渐变色编辑器 支持设置粒子系统中部分属性颜色随时间发生渐变。属性默认都是以固定颜色（Color）的形式显示，点击属性框右侧的 按钮，可以看到有以下几种编辑模式： 根据选择的编辑模式不同，属性框的显示也有一定的差异： Color（默认）：设定的颜色在属性整个生命周期内不会发生变化； Gradient：属性切换为渐变色编辑形式，点击属性框即可打开渐变色编辑器。属性的颜色变化由设置的颜色渐变图指定； TwoColors：设置的两个固定颜色定义了颜色的上限和下限，实际颜色会随着时间的推移在两个边界之间进行插值； TwoGradients：两个渐变图定义了属性颜色在生命周期内某一点的渐变上限和下限，当前颜色在两个边界之间进行插值； RadomColor：取 Gradient 模式下的渐变图中的随机颜色。 然后点击属性框，即可打开相应的颜色编辑器。 接下来我们以 Gradient 模式为例，看一下渐变色编辑器具体的操作步骤。 渐变色编辑 选择 Gradient 模式后点击属性框，即可打开渐变色编辑器。初始界面如下： 可将其大致分为上下两部分，上方的三条色带区域为颜色渐变图，下方区域为颜色选择器。 上方的色带用于插入 Alpha 关键帧；下方的色带用于插入 RGB 关键帧；中间的色带用于显示关键帧影响下的最终颜色，最终颜色的计算方式可在 Mode 选项中设置，详情请参考下文说明。 选中关键帧即可在下方的颜色选择器中设置 Alpha 或 RGB 值。设置时可在左侧直接选择颜色，也可以在右侧通过数值进行设置； 拖动关键帧 上下移动 可以 删除 关键帧。 拖动关键帧 左右移动 可以 调节关键帧位置，也可以在 Location 中通过设置百分比数值进行调节。 Mode 用于设置渐变色的计算方式，支持以下两种： Blend 模式（默认）：会按照当前时刻相邻的两个关键帧进行插值得到当前帧的颜色； Fixed 模式：会直接使用当前时刻的前一个关键帧颜色，没有渐变。 编辑器中默认使用 Blend 模式，可通过代码进行切换，代码示例如下： // 切换为 Fixed 模式 startColor.gradient.mode = Mode.Fixed; // 切换为 Blend 模式 startColor.gradient.mode = Mode.Blend; "},"particle-system/editor/particle-effect-panel.html":{"url":"particle-system/editor/particle-effect-panel.html","title":"控制面板","keywords":"","body":"粒子控制面板 在 层级管理器 选中粒子节点时，粒子控制面板 便会默认显示在 场景编辑器 右下角： 粒子控制面板可在 场景编辑器 区域内拖动，通过粒子控制面板可执行以下操作及设置： ：不使用面板时，面板在 场景编辑器 区域中会造成遮挡。那么便可以点击该按钮选择 Dock，当鼠标不在面板上且面板在靠边位置时便会收起，避免遮挡。使用时，将鼠标悬停在面板收起时预留的突出部分，即可唤出面板。 ：在 场景编辑器 中播放粒子 ：暂停播放粒子 ：重新播放粒子 ：停止播放粒子 Playback Speed：调整粒子播放速度 Playback Time：显示粒子播放时长 Particle：显示当前粒子数量 "},"tween/":{"url":"tween/","title":"缓动系统","keywords":"","body":"缓动系统 Cocos Creator 3.x 为了全面兼容和保持 Cocos Creator 2.x 缓动系统的使用体验，移植了所有的功能实现。需要注意的是： action 已经被废弃了，请使用 tween 不再依赖 tween.js，如果使用了 tween.js 的相关特性，请注意及时适配 to 和 by 的可选属性中增加了 onStart、onUpdate、onComplete 回调 与 v2.x 的 tween.js 的区别主要是可选属性，包括以下两点： easing 的值定义发生变动，但 v3.x 有做了兼容性处理。详情请参考下文 easing 部分的内容。 除了 easing、onStart、onUpdate、onComplete，其它属性暂不支持。若使用了不支持的属性，控制台 面板会输出警告信息。 简单示例 import { _decorator, Component, Vec3, Tween } from 'cc'; const { ccclass, property } = _decorator; @ccclass('TweenTest') export class TweenTest extends Component { private _pos: Vec3 = new Vec3(0, 0, 0); start () { /** 缓动 _pos */ const tw1 = new Tween(this._pos) .to(3, new Vec3(10, 10, 10), { easing: 'bounceInOut' }) .to(3, new Vec3(0, 0, 0), { easing: 'elasticOut' }) .union() .repeat(2) // 执行 2 次 .start(); /** 缓动 Node，这里将缓动 Node 的 position 属性 */ const tw2 = new Tween(this.node) .to(3, { position: new Vec3(10, 10, 10) }, { easing: 'bounceInOut' }) .to(3, { position: new Vec3(0, 0, 0) }, { easing: 'elasticOut' }) .union() .repeat(2) // 执行 2 次 .start(); } } Tween 接口介绍 接口 功能说明 to 添加一个对属性进行 绝对值 计算的间隔动作 by 添加一个对属性进行 相对值 计算的间隔动作 set 添加一个 直接设置目标属性 的瞬时动作 delay 添加一个 延迟时间 的瞬时动作 call 添加一个 调用回调 的瞬时动作 target 添加一个 直接设置缓动目标 的瞬时动作 union 将 union 前面所有的缓动动作整合为一个缓动动作 then 插入一个 Tween 到缓动队列中 repeat 执行 n 次（n 为方法参数） repeatForever 一直重复执行 sequence 添加一个顺序执行的缓动 parallel 添加一个同时进行的缓动 start 启动缓动 stop 停止缓动 clone 克隆缓动 show 启用节点链上的渲染，缓动目标需要为 Node hide 禁用节点链上的渲染，缓动目标需要为 Node removeSelf 将节点移出场景树，缓动目标需要为 Node to 和 by 的可选属性 定义如下: interface ITweenOption { easing?: TweenEasing | ((k: number) => number); progress?: (start: number, end: number, current: number, ratio: number) => number; onStart?: (target: object) => {}; onUpdate?: (target: object, ratio: number) => {}; onComplete?: (target: object) => {}; } 与 Creator 2.x 不同的是 v3.x 新增了 onStart、onUpdate、onComplete 等属性，这些属性是回调函数，调用时会传入缓动的目标。 另外，onUpdate 调用时还会多传入一个目前缓动的进行值，范围为 (0-1]。 回调的使用 以 onUpdate 为例，以下代码示例演示了缓动一个位置，然后在 onUpdate 中将其设置到多个对象上，类似于缓动的合批。 import { _decorator, Component, Node, Vec3, Tween, Quat } from 'cc'; const { ccclass, property } = _decorator; @ccclass('TweenTest') export class TweenTest extends Component { start () { const nodeArray: Node[] = []; // 此处替换成相应的节点数组 const tweenTargetVec3 = new Vec3(); const tw = new Tween(tweenTargetVec3) .by(1, new Vec3(1, 1, 1), { 'onUpdate': (target: object | undefined, ratio: number | undefined) => { if (target instanceof Vec3) { for (let i = 0; i call 的使用，代码示例如下： const tw = new Tween(this.node) .to(2, { rotation: new Quat(Math.sin(90), Math.sin(90), Math.sin(90), Math.cos(90)) }) .to(1, { scale: new Vec3(2, 2, 2) }) // 当前面的动作都执行完毕后才会调用这个回调函数 .call(() => { console.log('This is a callback') }) .start() repeat 的使用 在 Creator 2.x 中，repeat 的含义为 重复 n 次。 在 Creator 3.x 中，repeat 的含义为 执行 n 次，例如 repeat(1) 表示执行一次。 与 union 的搭配使用 repeat 的 API 注释 为：添加一个重复 action，这个 action 会将 前一个动作 作为它的参数。 repeatForever 的 API 注释 为：添加一个永久重复 action，这个 action 会将 前一个动作 作为它的参数。 由此可以看出 repeat 和 repeatForever 都是重复执行它前一个 action。所以，当我们需要重复应用一些复杂的缓动时，可以在 repeat 前加一个 union 将前面所有的 action 整合为一个 action。 代码示例如下： const tw = new Tween(this.node) .by(1, { position: new Vec3(100, 0, 0) }) .to(1, { scale: new Vec3(2, 2, 2) }) .call(() => { console.log('It is a callback.') }) // 将前面的三个 action 整合为一个 action .union() .repeat(5) .start(); 瞬时动作与间隔动作 瞬时动作 包括 delay、call、target 等。 间隔动作 包括 to、by 等。 repeat/repeatForever 不可与 瞬时动作 搭配使用，否则会出现异常。与 间隔动作 搭配使用时，前面需要有间隔动作或者包含间隔动作的 union。 自动销毁 当缓动目标为 Node 时，将会监听其销毁事件进行缓动的自动销毁，调用 target 方法也会自动更新监听。 注意事项 使用限制 为了降低更新 Node Transform 信息的频率，Node 内部维护了一个 dirty 状态，只有在调用到可能会改变 Node Transform 信息的接口时，才会将 dirty 置为需要更新的状态。 但目前的接口存在一定的限制，例如：通过 this.node.position 获取到的 position 是一个通用的 Vec3。 当执行 this.node.position.x = 1 时，只执行了 position 的 getter，并没有执行 position 的 setter。由于 dirty 并没有更新，便会导致渲染时使用的节点的 Transform 信息没有更新。 目前也暂不支持上述的调用方式，我们更推荐使用 setPosition 或 position 的 setter，代码示例如下： let _pos = new Vec3(0, 1, 0); // 通过 position 的 setter this.node.position = _pos; // 通过接口 setPosition this.node.setPosition(_pos); 正确的缓动方式 在新的 Tween 模块中可以对具有 getter 和 setter 的属性进行缓动，例如在上文的简单示例中，node 的 position 属性。这样在缓动的过程中，会对相应的接口进行设置，从而保证 dirty 正常更新。 注意：切换场景时请停止相应的缓动。 针对 readonly 字段的缓动 例如节点上 position 属性的类型是 Readonly，它的分量 x/y/z 无法在 Tween 里被修改，所以我们需要在节点挂载 Tween 且指定目标为 position。代码示例如下： const tw = new Tween(this.node) .by(1, { position: new Vec3(100, 0, 0) }) .call( () => { this.node.position = new Vec3(0, 0, 0); }) .union() .repeatForever() .start(); 使用 tween(node.position) 的方式是无效的。错误代码示例如下： const tw = new Tween(this.node.position) .by(1, new Vec3(100, 0, 0)) .call(() => { this.node.position = new Vec3(0, 0, 0); }) .union() .repeatForever() .start(); 基础使用范例 链式 API Tween 的每一个 API 都会在内部生成一个 action，并将这个 action 添加到内部队列中，在 API 调用完后会再返回自身实例，这样就可以通过链式调用的方式来组织代码。 Tween 在调用 start 时会将之前生成的 action 队列重新组合生成一个 sequence 队列，所以 Tween 的链式结构是依次执行每一个 API 的，也就是会执行完一个 API 后再执行下一个 API。 import { _decorator, Component, Vec3, Tween } from 'cc'; const { ccclass, property } = _decorator; @ccclass('TweenTest') export class TweenTest extends Component { start () { const tw = new Tween(this.node) // 0s 时，node 的 scale 还是 1 .to(1, { scale: new Vec3(2, 2, 2) }) // 1s 时，执行完第一个 action，scale 为 2 .to(1, { scale: new Vec3(3, 3, 3) }) // 2s 时，执行完第二个 action，scale 为 3 // 调用 ‘start()’ 开始执行 Tween .start() } } 设置缓动属性 Tween 提供了两个设置属性的 API： to：对属性进行 绝对值 计算，最终的运行结果是设置的属性值，即修改为某个值。 by：对属性进行 相对值 计算，最终的运行结果是设置的属性值加上开始运行时节点的属性值，即变化值。 代码示例如下： import { _decorator, Component, Vec3, Tween } from 'cc'; const { ccclass, property } = _decorator; @ccclass('TweenTest') export class TweenTest extends Component { start () { const tw = new Tween(this.node) .to(1, {scale: new Vec3(2, 2, 2) }) // node.scale === 2 .by(1, {scale: new Vec3(2, 2, 2) }) // node.scale === 4 (2 + 2) .by(1, {scale: new Vec3(1, 1, 1) }) // node.scale === 5 .to(1, {scale: new Vec3(2, 2, 2) }) // node.scale === 2 .start() } } 同时执行多个属性 例如同时对 scale、position、rotation 三个属性进行缓动，代码示例如下： import { _decorator, Component, Vec3, Tween, Quat } from 'cc'; const { ccclass, property } = _decorator; @ccclass('TweenTest') export class TweenTest extends Component { start () { const tw = new Tween(this.node) .to(1, { scale: new Vec3(2, 2, 2), position: new Vec3(100, 100, 0), rotation: new Quat(Math.sin(90), Math.sin(90), Math.sin(90), Math.cos(90)) }) .start() } } easing 使用 easing 可以让缓动更生动，Tween 针对不同的情况提供了多种使用方式。代码示例如下： import { _decorator, Component, Vec3, Tween } from 'cc'; const { ccclass, property } = _decorator; @ccclass('TweenTest') export class TweenTest extends Component { start () { // 传入 easing 名字，直接使用内置 easing 函数 const tw1 = new Tween(this.node) .to(1, { scale: new Vec3(2, 2, 2) }, { easing: 'sineOutIn'}) // 使用自定义 easing 函数 const tw2 = new Tween(this.node) .to(1, { scale: new Vec3(2, 2, 2) }, { easing: t => t * t }) // 只对单个属性使用 easing 函数 // value 必须与 easing 或者 progress 配合使用 const tw3 = new Tween(this.node) .to(1, { scale: new Vec3(2, 2, 2), position: new Vec3(100, 100, 100) }, {easing: 'sineOutIn'}) } } 更多的内置 Easing 类型，详情可参考 API TweenEasing。 自定义 progress 相对于 easing，自定义 progress 函数可以更自由地控制缓动的过程。代码示例如下： import { _decorator, Component, Vec3, Tween, Quat, math } from 'cc'; const { ccclass, property } = _decorator; @ccclass('TweenTest') export class TweenTest extends Component { start () { // 对所有属性自定义 progress const tw1 = new Tween(this.node) .to(1, { scale: new Vec3(2, 2, 2), rotation: new Quat(Math.sin(90), Math.sin(90), Math.sin(90), Math.cos(90) )}, { progress: (start: number, end: number, current: number, ratio: number) => { return start + (end - start) * ratio; } } ) // 对单个属性自定义 progress const tw2 = new Tween(this.node) .to(1, { scale: new Vec3(2, 2, 2), position: new Vec3(1, 1, 1)}, { progress: (start: number, end: number, current: number, t: number) => { // 注意：传入的属性为 ‘cc.Vec3’，所以需要使用 ‘Vec3.lerp’ 进行插值计算 return math.lerp(start, end, current); } } ) } } 复制缓动 clone 函数会克隆一个当前的缓动，并接受一个 target 作为参数。代码示例如下： import { _decorator, Component, Vec3, Tween, find } from 'cc'; const { ccclass, property } = _decorator; @ccclass('TweenTest') export class TweenTest extends Component { start () { // 先创建一个缓动作为模板 const tween = new Tween(this.node).to(4, { scale: new Vec3(2, 2, 2) }) // 复制 tween，并使用节点 ‘Canvas/cocos’ 作为 target tween.clone( find('Canvas/cocos')! ).start() // 复制 tween，并使用节点 ‘Canvas/cocos2’ 作为 target tween.clone( find('Canvas/cocos2')! ).start() } } 插入其他的缓动到队列中 通过事先创建一些固定的缓动，然后将其组合形成新的缓动，可以减少代码量。代码示例如下： import { _decorator, Component, Vec3, Tween, Quat } from 'cc'; const { ccclass, property } = _decorator; @ccclass('TweenTest') export class TweenTest extends Component { start () { let scale = new Tween(this.node) .to(1, { scale: new Vec3(2, 2, 2) }) let rotate = new Tween(this.node) .to(1, { rotation: new Quat(Math.sin(90), Math.sin(90), Math.sin(90), Math.cos(90)) }) let move = new Tween(this.node) .to(1, { position: new Vec3(100, 100, 100) }) // 先缩放再旋转 let tw = new Tween(this.node).then(scale).then(rotate) // 先缩放再移动 tw = new Tween(this.node).then(scale).then(move) } } 并行执行缓动 Tween 在链式执行时是按照 sequence 的方式来执行的，但是在编写复杂缓动的时候可能会需要同时并行执行多个队列，Tween 提供了 parallel 接口来满足这个需求。代码示例如下： import { _decorator, Component, Vec3, Tween } from 'cc'; const { ccclass, property } = _decorator; @ccclass('TweenTest') export class TweenTest extends Component { start () { const tw = new Tween(this.node) // 同时执行两个 Tween .parallel( new Tween().to(1, { scale: new Vec3(2, 2, 2) }), new Tween().to(2, { position: new Vec3(100, 100, 0) }) ) .call(() => { console.log('All tweening complete.') }) .start() } } 重复执行 repeat/repeatForever 函数会将前一个 action 作为作用对象。但是如果有参数提供了其他的 action 或者 tween，则 repeat/repeatForever 函数会将传入的 action 或者 tween 作为作用对象。 import { _decorator, Component, Vec3, Tween } from 'cc'; const { ccclass, property } = _decorator; @ccclass('TweenTest') export class TweenTest extends Component { start () { const tw1 = new Tween(this.node) .by(1, { scale: new Vec3(1, 1, 1) }) // 对前一个 ‘by’ 执行 10 次 .repeat(10) // 最后 node.scale === 11 .start() // 也可以这样用 // const tw1 = new Tween(this.node) // .repeat(10, // new Tween().by(1, { scale: new Vec3(1, 1, 1) }) // ) // .start() const tw2 = new Tween(this.node) .by(1, { scale: new Vec3(1, 1, 1) }) // 一直重复执行下去 .repeatForever() .start() } } 延迟执行 import { _decorator, Component, Vec3, Tween } from 'cc'; const { ccclass, property } = _decorator; @ccclass('TweenTest') export class TweenTest extends Component { start () { const tw = new Tween(this.node) // 延迟 1s .delay(1) .to(1, { scale: new Vec3(2, 2, 2) }) // 再延迟 1s .delay(1) .to(1, { scale: new Vec3(3, 3, 3) }) .start() } } 范例 更多关于 Tween 具体的使用方法，详情请参考范例 Tween（GitHub | Gitee）。 "},"editor/terrain/":{"url":"editor/terrain/","title":"地形系统","keywords":"","body":"地形系统 地形系统以一种高效的方式来展示大自然的山川地貌。开发者可以很方便的使用画刷来雕刻出盆地、山脉、峡谷、平原等地貌。 创建地形 创建地形需要以下步骤： 在 层级管理器 中点击鼠标右键，在弹出菜单中点击 创建 -> 地形 来创建地形节点（地形节点可移动，但不支持旋转与缩放）。 在 资源管理器 中点击鼠标右键，在弹出菜单中点击 创建 -> 地形 来创建地形资源。 地形组件属性 属性 说明 Asset 地形资源 EffectAsset 地形特效资源 ReceiveShadow 是否接受阴影 UseNormalMap 是否使用法线贴图 UsePBR 是否使用物理材质 使用 点击创建后的地形节点，此时在 属性检查器 中可以看到 cc.Terrain 地形组件，将已经创建好的地形资源拖拽到地形组件中的 Asset 属性框中。 编辑 地形资源设置完成后会在 场景编辑器 的右下角弹出 cc.Terrain 编辑面板，Cocos Creator 中的地形编辑主要包括三大功能：管理（Manage）、雕塑（Sculpt）、涂料（Paint）。可以通过点击三个 Tab 标签页来切换功能。 除了编辑面板，也可以通过 场景编辑器 左上角的工具来切换功能： 1 — 对应 管理 功能 2 — 对应 雕塑 功能中的 Bulge（隆起）画刷类型 3 — 对应 雕塑 功能中的 Sunken（凹陷）画刷类型 4 — 对应 雕塑 功能中的 Smooth（平滑）画刷类型 5 — 对应 涂料 功能 管理（Manage） 用于调整地形的各种参数。Tile 是地形的最小单位，Tile 组成地形块（Block），目前一个 Block 由 32x32 个 Tile 组成，一个地形至少由 1 个 Block 组成。 参数 说明 TileSize 地形 Tile 的大小，目前一个地形块由 32 x 32 个 Tile 组成，所以一个地形块的边长是 32 x TileSize BlockCount 地形块在两个维度上的数量（注意：若该值设置过大会造成顶点数过多，导致卡顿） WeightMapSize 权重图大小 LightmapSize 光照贴图大小 雕塑（Sculpt） 用于改变地形的形状。 参数 说明 BrushSize 画刷的大小 BrushStrength 画刷的力度 BrushMode 画刷类型，包括 Bulge、Sunken 和 Smooth Brush 自定义画刷样式，通过选取样式图片生成自定义画刷 可通过 鼠标左键 控制地形的 隆起，通过 Shift + 鼠标左键 控制地形的 凹陷。而隆起/凹陷的操作往往会使地形看上去很尖锐，此时就可以使用平滑功能进行过度。 涂料（Paint） 用于描绘地形的纹理 参数 说明 Terrain Layer 设置地形的 Layer。详情可参考下方的 Layer 编辑 BrushSize 画刷的大小 BrushStrength 画刷的力度 BrushFalloff 画刷衰减度，决定了画刷边缘的锐利程度。0.0 表示画刷在整个范围内都有完全效果（全部被当前层纹理覆盖），具有尖锐的边缘。1.0 表示画刷仅在它中心具有完全效果，在到达边缘的过程中效果逐渐衰减 Brush 自定义画刷样式，通过选取样式图片生成自定义画刷 Layer 编辑 点击右上方的 +/- 按钮可以添加/删除 Layer（最多支持 4 层 layer）。选中某个 Layer 后就可以对 Layer 及其纹理进行编辑。 参数 说明 Terrain Layer 设置当前 Layer 的纹理 NormalMap 设置当前 Layer 的法线贴图，需要勾选地形组件的 UseNormalMap 属性 Metallic 设置当前 Layer 的金属特性 (主要指光滑程度) Roughness 设置当前 Layer 的粗糙程度 TileSize 纹理的平铺大小，值越小会在同样大小的区域内进行更多次的平铺 "},"asset/asset-manager.html":{"url":"asset/asset-manager.html","title":"资源管理","keywords":"","body":"Asset Manager 概述 文：Santy-Wang、Xunyi 在游戏的开发过程中，一般需要使用到大量的图片、音频等资源来丰富整个游戏内容，而大量的资源就会带来管理上的困难。所以 Creator 提供了 Asset Manager 资源管理模块来帮助开发者管理其资源的使用，大大提升开发效率和使用体验。 Asset Manager 是 Creator 在 v2.4 新推出的资源管理器，用于替代之前的 loader。新的 Asset Manager 资源管理模块具备加载资源、查找资源、销毁资源、缓存资源、Asset Bundle 等功能，相比之前的 loader 拥有更好的性能，更易用的 API，以及更强的扩展性。所有函数和方法可通过 assetManager 进行访问，所有类型和枚举可通过 AssetManager 命名空间进行访问。 注意：为了带来平滑的升级体验，我们会在一段时间内保留对 loader 的兼容，但还是建议新项目统一使用 Asset Manager。 你可以参考以下文章升级： loader 升级 assetManager 指南 子包升级 Asset Bundle 指南 加载资源 动态加载资源 除了在编辑场景时，可以将资源应用到对应组件上，Creator 还支持在游戏运行过程中动态加载资源并进行设置。而动态加载资源 Asset Manager 提供了以下两种的方式： 通过将资源放在 resources 目录下，并配合 resources.load 等 API 来实现动态加载。 开发者可以自己规划资源制作为 Asset Bundle，再通过 Asset Bundle 的 load 系列 API 进行资源的加载。例如： resources.load('images/background/spriteFrame', SpriteFrame, (err, asset) => { this.getComponent(Sprite).spriteFrame = asset; }); 相关的 API 列表如下： 类型 支持 加载 释放 预加载 获取 查询资源信息 单个资源 Asset Bundle load release preload get getInfoWithPath 文件夹 Asset Bundle loadDir releaseAsset preloadDir N/A getDirWithPath 场景 Asset Bundle loadScene N/A preloadScene N/A getSceneInfo 单个资源 resources load release preload get getInfoWithPath 文件夹 resources loadDir releaseAsset preloadDir N/A getDirWithPath 脚本 Asset Manager loadScript N/A N/A N/A N/A 远程 Asset Manager loadRemote releaseAsset N/A N/A N/A 相关文档可参考： 动态加载资源 所有加载到的资源都会被缓存在 assetManager 中。 预加载 为了减少下载的延迟，assetManager 和 Asset Bundle 中不但提供了加载资源的接口，每一个加载接口还提供了对应的预加载版本。开发者可在游戏中进行预加载工作，然后在真正需要时完成加载。预加载只会下载必要的资源，不会进行反序列化和初始化工作，所以性能消耗更小，适合在游戏过程中使用。 start () { resources.preload('images/background/spriteFrame', SpriteFrame); setTimeOut(this.loadAsset.bind(this), 10000); } loadAsset () { resources.load('images/background/spriteFrame', SpriteFrame, (err, asset) => { this.getComponent(Sprite).spriteFrame = asset; }); } 关于预加载的更多内容请参考 预加载与加载。 Asset Bundle 开发者可以将自己的场景、资源、代码划分成多个 Asset Bundle，并在运行时动态加载资源，从而实现资源的模块化，以便在需要时加载对应资源。例如： assetManager.loadBundle('testBundle', function (err, bundle) { bundle.load('textures/background', (err, asset) => { // ... }); }); 更多关于 Asset Bundle 的介绍请参考 bundle。 释放资源 Asset Manager 提供了更为方便的资源释放机制，在释放资源时开发者只需要关注该资源本身而不再需要关注其依赖资源。引擎会尝试对其依赖资源根据引用数量进行释放，以减少用户管理资源释放的复杂度。例如： resources.load('prefabs/enemy', Prefab, function (err, asset) { assetManager.releaseAsset(asset); }); Creator 还提供了引用计数机制来帮助开发者控制资源的引用和释放。例如： 当需要持有资源时，请调用 addRef 来增加引用，确保该资源不会被其他引用到的地方自动释放。 resources.load('textures/armor/texture', Texture2D, function (err, texture) { texture.addRef(); this.texture = texture; }); 当不再需要持有该资源时，请调用 decRef 来减少引用，decRef 还将根据引用计数尝试自动释放。 this.texture.decRef(); this.texture = null; 更多详细内容请参考文档 资源释放。 缓存管理器 在某些平台上，比如微信小游戏，因为存在文件系统，所以可以利用文件系统对一些远程资源进行缓存。此时需要一个缓存管理器来管理所有缓存资源，例如缓存资源、清除缓存资源、修改缓存周期等。从 v2.4 开始，Creator 在所有存在文件系统的平台上都提供了缓存管理器，以便对缓存进行增删改查操作。例如： // 获取某个资源的缓存 assetManager.cacheManager.getCache('http://example.com/bundle1/import/9a/9aswe123-dsqw-12xe-123xqawe12.json'); // 清除某个资源的缓存 assetManager.cacheManager.removeCache('http://example.com/bundle1/import/9a/9aswe123-dsqw-12xe-123xqawe12.json'); 更多缓存管理器的介绍请参考 缓存管理器。 可选参数 assetManager 和 Asset Bundle 的部分接口都额外提供了 options 参数，可以极大地增加灵活性以及扩展空间。options 中除了可以配置 Creator 内置的参数之外，还可以自定义任意参数，这些参数将提供给下载器、解析器以及加载管线。 bundle.loadScene('test', { priority: 3 }, callback); 更多关于 options 的内容可参考文档 可选参数。 如果不需要配置引擎内置参数或者自定义参数来扩展引擎功能，可以无视它，直接使用更简单的 API 接口，比如 resources.load。 加载管线 为了更方便地扩展资源加载流程，Asset Manager 底层使用了名为 管线与任务、下载与解析 的机制来完成资源的加载工作，极大地增加了灵活性和可扩展性。如果需要扩展加载管线或自定义管线，可以参考： 管线与任务 下载与解析 更多参考 Asset Bundle 资源释放 下载与解析 加载与预加载 缓存管理器 可选参数 管线与任务 "},"asset/asset-manager-upgrade-guide.html":{"url":"asset/asset-manager-upgrade-guide.html","title":"资源管理模块升级指南","keywords":"","body":"资源管理模块升级指南 文：Santy-Wang、Xunyi 本文将详细介绍 Cocos Creator 3D 的 loader 升级到 assetManager 时的注意事项。v2.4 的资源管理与 v3.0 差别不大，无需升级。 在 Cocos Creator 2.4 以前，获取和加载资源 是通过 loader 模块（包括 loader.load、loader.loadRes、loader.loadResDir 等系列 API）来实现的，loader 模块主要用于加载资源。但随着 Creator 的不断发展，开发者对于资源管理的需求不断增加，原来的 loader 已无法满足大量的资源管理需求，一个新的资源管理模块呼之欲出。 因此，Creator 在 v2.4 推出了全新的资源管理模块 —— Asset Manager。相较之前的 loader，Asset Manager 不但提供了更好的加载性能，而且支持 Asset Bundle、预加载资源以及更加方便的资源释放管理。同时 Asset Manager 还拥有强大的扩展性，大大提升开发者的开发效率和使用体验，我们建议所有开发者都进行升级。 为了带来平滑的升级体验，我们仍保留了对 loader 相关 API 的兼容。除个别项目使用了无法兼容的特殊用法的 API 必须手动升级外，大部分项目都可以照常运行。之后我们会在时机成熟时才逐渐完全移除对 loader 的兼容。如果由于项目周期等原因暂时不方便升级，你可以在确保测试通过的情况下继续保留原来的写法。 目前在使用旧的 API 时，引擎会输出警告并提示升级方法。请你根据警告内容和本文的说明对代码进行调整，升级到新的用法。比较抱歉的是，由于底层经过了升级，我们遗留了个别无法兼容的 API，在运行时会输出错误信息。如果你已经决定好要进行升级，那么请仔细阅读以下内容。 对 美术策划 而言，项目中的所有资源，例如场景、动画、Prefab 都不需要修改，也不需要升级。 对 程序 而言，影响主要体现在原先代码中使用的 loader 的所有 API，都需要改为 assetManager 的 API。以下将详细介绍这部分内容。 注意：因为 v2.4 支持 Asset Bundle，项目中的分包功能也需要进行升级，具体内容请参考 分包升级指南。 需要手动升级的情况 你在自己的代码中使用了以 loader 开头的 API，比如 loader.loaderRes、loader.loadResDir、loader.release 等。 你在自己的代码中使用了以 AssetLibrary 开头的 API，比如 AssetLibrary.loadAsset。 你在自己的代码中使用了 url 开头的 API，比如 url.raw。 你在自己的代码中使用了 Pipeline，LoadingItems 等类型。 你在自己的代码中使用了 macro.DOWNLOAD_MAX_CONCURRENT 属性。 升级步骤 备份好旧项目 在 Dashboard 中使用 Cocos Creator v3.0 打开需要升级的旧项目，Creator 将对有影响的资源重新导入，第一次导入时会稍微多花一点时间，导入完毕后就会打开编辑器主窗口。此时可能会出现较多的报错或警告信息，别担心，请打开代码编辑工具根据报错或警告信息对代码进行升级。 将 loader 相关的 API 替换为 assetManager 相关的 API 从 v2.4 开始，不建议使用 loader，并且在后续的版本中也会逐渐被彻底移除，请使用新的资源管理模块 assetManager 进行替换。 加载相关接口的替换 如果你在自己的代码中使用了 loader.loadRes、loader.loadResArray、loader.loadResDir，请使用 assetManager 中对应的 API 进行替换。可参考下方的替换方式： loader.loadRes resources.load 的参数与 loader.loadRes 完全相同。替换方式如下： // 修改前 loader.loadRes(...); // 修改后 resources.load(...); loader.loadResArray assetManager 为了降低学习成本，将 loadResArray 与 load 进行了合并。resources.load 的第一个参数可支持多个路径，所以可以使用 resources.load 进行替换： // 修改前 loader.loadResArray(...); // 修改后 resources.load(...); loader.loadResDir resources.loadDir 的参数与 loader.loadResDir 完全相同： // 修改前 loader.loadResDir(...); // 修改后 resources.loadDir(...); 注意：为了简化接口，resources.loadDir 的加载完成回调将 不再提供 paths 的列表。请避免以下的使用方式： loader.loadResDir('images', Texture2D, (err, assets, paths) => console.log(paths)); 如果你想要查询 paths 列表，可以使用以下方式： const infos = resources.getDirWithPath('images', Texture2D); let paths = infos.map(function (info) { return info.path; }); loader.load 如果你在自己的代码中使用了 loader.load 来加载远程图片或远程音频，为了方便理解，在 assetManager 中将有专门的 API 用于此项工作，如下所示： 加载远程图片 // 修改前 loader.load('http://example.com/remote.jpg', (err, texture) => console.log(texture)); // 修改后 assetManager.loadRemote('http://example.com/remote.jpg', (err, texture) => console.log(texture)); 加载远程音频 // 修改前 loader.load('http://example.com/remote.mp3', (err, audioClip) => console.log(audioClip)); // 修改后 assetManager.loadRemote('http://example.com/remote.mp3', (err, audioClip) => console.log(audioClip)); 加载远程文本 // 修改前 loader.load('http://example.com/equipment.txt', (err, text) => console.log(text)); // 修改后 assetManager.loadRemote('http://example.com/equipment.txt', (err, textAsset) => console.log(textAsset.text)); 注意： 如果你在自己的代码中使用了 loader.downloader.loadSubpackage 来加载分包，请参考 分包升级指南 进行升级。 为了避免产生不必要的错误，loader.onProgress 在 assetManager 中没有对应实现。你可以自己实现全局回调机制，但建议将回调传入到每个加载函数中，避免并发加载时互相干扰。 释放相关接口的替换 如果你在自己的代码中使用了 loader.release、loader.releaseAsset、loader.releaseRes、loader.releaseResDir，请使用 assetManager 中对应的 API 进行替换。可参考下方的替换方式： loader.release loader.release 可用 assetManager.releaseAsset 替换。 注意：为了避免开发者关注资源中一些晦涩难懂的属性，assetManager.releaseAsset 不再接受 数组、资源 UUID、资源 URL 进行释放，仅能通过资源本身进行释放。 // 修改前 loader.release(texture); // 修改后 assetManager.releaseAsset(texture); // 修改前 loader.release([texture1, texture2, texture3]); // 修改后 [texture1, texture2, texture3].forEach(t => assetManager.releaseAsset(t)); // 修改前 const uuid = texture._uuid; loader.release(uuid); // 修改后 assetManager.releaseAsset(texture); // 修改前 const url = texture.url; loader.release(url); // 修改后 assetManager.releaseAsset(texture); 注意：为了增加易用性，在 assetManager 中释放资源的依赖资源将 不再需要 手动获取资源的依赖项，在 assetManager.releaseAsset 内部将会尝试自动去释放相关依赖资源，例如： // 修改前 const assets = loader.getDependsRecursively(texture); loader.release(assets); // 修改后 assetManager.releaseAsset(texture); loader.releaseAsset loader.releaseAsset 可直接使用 assetManager.releaseAsset 替换： // 修改前 loader.releaseAsset(texture); // 修改后 assetManager.releaseAsset(texture); loader.releaseRes loader.releaseRes 可直接使用 resources.release 替换： // 修改前 loader.releaseRes('images/a', Texture2D); // 修改后 resources.release('images/a', Texture2D); loader.releaseAll loader.releaseAll 可直接使用 assetManager.releaseAll 替换： // 修改前 loader.releaseAll(); // 修改后 assetManager.releaseAll(); 注意： 出于安全考虑，loader.releaseResDir 在 assetManager 中没有对应实现，请使用 assetManager.releaseAsset 或 resources.release 进行单个资源释放。 因为 assetManager.releaseAsset 会自动释放依赖资源，所以你不需要再显式调用 loader.getDependsRecursively。如果需要查找资源的相关依赖，请参考 assetManager.dependUtil 中相关的 API。 出于安全考虑，assetManager 仅支持在场景中设置的自动释放，其他的已移除。assetManager 中没有实现 loader.setAutoRelease、loader.setAutoReleaseRecursively、loader.isAutoRelease 这几个 API，建议你使用全新的基于引用计数的自动释放机制，详细请参考 资源释放。 扩展相关接口的替换 Pipeline 如果你的代码中有使用 loader.insertPipe、loader.insertPipeAfter、loader.appendPipe、loader.addDownloadHandlers、loader.addLoadHandlers 系列 API 对 loader 的加载流程做过扩展，或者直接使用了 loader.assetLoader、loader.md5Pipe、loader.downloader、loader.loader、loader.subPackPipe 中的方法，请使用 assetManager 中对应的 API 进行替换。 因为 assetManager 是更通用的模块，不再继承自 Pipeline，所以 assetManager 不再实现 loader.insertPipe、loader.insertPipeAfter、loader.appendPipe。具体的替换方式如下： // 修改前 const pipe1 = { id: 'pipe1', handle: (item, done) => { let result = doSomething(item.uuid); done(null, result); } }; const pipe2 = { id: 'pipe2', handle: (item, done) => { let result = doSomething(item.content); done(null, result); } }; loader.insertPipe(pipe1, 1); loader.appendPipe(pipe2); // 修改后 function pipe1 (task, done) { let output = []; for (let i = 0; i 注意： assetManager 不再继承 自 Pipeline，而是 assetManager 下拥有的多个 Pipeline 实例。详情请参考 管线与任务。 为了易用性，Pipe 的定义不再需要定义一个拥有 handle 方法和 id 的对象，只需要一个方法即可。详情请参考 管线与任务。 为了简化逻辑、提高性能，Pipe 中处理的内容不再是 item，而是 task 对象。详情请参考 管线与任务。 为了降低学习成本，Pipeline 中不再支持 insertPipeAfter 形式的 API，请使用 insert 插入指定的位置。 addDownloadHandlers、addLoadHandlers 出于模块化考虑，assetManager 中没有实现 addDownloadHandlers、addLoadHandlers，请参考以下方式替换： // 修改前 const customHandler = (item, cb) => { let result = doSomething(item.url); cb(null, result); }; loader.addDownloadHandlers({png: customHandler}); // 修改后 const customHandler = (url, options, cb) => { let result = doSomething(url); cb(null, result); }; assetManager.downloader.register('.png', customHandler); 或者： // 修改前 const customHandler = (item, cb) => { let result = doSomething(item.content); cb(null, result); }; loader.addLoadHandlers({png: customHandler}); // 修改后 const customHandler = (file, options, cb) => { let result = doSomething(file); cb(null, result); }; assetManager.parser.register('.png', customHandler); 注意： 因为 下载模块 与 解析模块 都是依靠 扩展名 来匹配对应的处理方式，所以调用 register 时，传入的第一个参数需要以 . 开头。 出于模块化的考虑，自定义的处理方法将不再传入一个 item 对象，而是直接传入与其相关的信息。downloader 的自定义处理方法传入的是 待下载的 URL，parser 传入的则是 待解析的文件。具体的内容请参考 下载与解析。 新的拓展机制提供了一个额外的 options 参数，可以极大地增加灵活性。但如果你不需要配置引擎内置参数或者自定义参数，可以无视它。具体内容请参考文档 可选参数。 downloader，loader，md5Pipe，subPackPipe loader.downloader 可由 assetManager.downloader 代替，loader.loader 可由 assetManager.parser 代替。但其中的接口没有完全继承，具体内容请参考文档 下载与解析 或者 API 文档 assetManager.downloader 和 assetManager.parser。 注意：出于对性能、模块化和易读性的考虑，loader.assetLoader、loader.md5Pipe、loader.subPackPipe 已经被合并到 assetManager.transformPipeline 中，你应该避免使用这三个模块中的任何方法与属性。关于 assetManager.transformPipeline 的具体内容可参考 管线与任务。 其他更新 url 与 AssetLibrary 在 v2.4 中已经被移除，请避免使用 url 与 AssetLibrary 中的任何方法和属性。 Pipeline 可由 AssetManager.Pipeline 进行替换，请参考以下方式进行替换： // 修改前 const pipe1 = { id: 'pipe1', handle: function (item, cb) { let result = doSomething(item); cb(null, result); } } const pipeline = new Pipeline([pipe1]); // 修改后 function pipe1 (task, cb) { task.output = doSomething(task.input); cb(null); } const pipeline = new AssetManager.Pipeline('test', [pipe1]); 注意：LoadingItem 在 assetManager 中已经不支持，请避免使用这个类型。 为了支持更多加载策略，macro.DOWNLOAD_MAX_CONCURRENT 已经从 macro 中移除，你可以用以下方式替换： // 修改前 macro.DOWNLOAD_MAX_CONCURRENT = 10; // 修改后 assetManager.downloader.maxConcurrency = 10; 或者 // 修改前 macro.DOWNLOAD_MAX_CONCURRENT = 10; // 修改后（设置预设值） assetManager.presets['default'].maxConcurrency = 10; 具体内容可参考 下载与解析。 "},"asset/subpackage-upgrade-guide.html":{"url":"asset/subpackage-upgrade-guide.html","title":"资源分包升级指南","keywords":"","body":"资源分包升级指南 文：Santy-Wang、Xunyi 本文将详细介绍 Cocos Creator 3D 的小游戏子包升级到 Asset Bundle 的注意事项。v2.4 的资源分包与 v3.0 差别不大，无需升级。 在 v2.4 之前，分包加载 功能仅支持各类小游戏平台，如微信小游戏、OPPO 小游戏等。但随着 Creator 的发展，开发者对分包的需求不断增加，例如多平台支持，原有的分包加载已经远远不能满足了。所以，Creator 从 v2.4 开始正式支持功能更为完整的 Asset Bundle。 对 美术策划 而言，项目中的所有资源，例如场景、动画、Prefab 都不需要修改，也不用升级。 对 程序 而言，影响主要体现在原先代码中使用的 loader.downloader.loadSubpackage 需要改为 Asset Manager 中的 assetManager.loadBundle。以下将详细介绍这部分内容。 注意：如果你在旧项目中使用了分包功能，也就是在 属性检查器 中勾选了 配置为子包 选项，那么当项目升级到 v2.4 之后，将自动转变为一个普通文件夹。你可以参考这里进行 Asset Bundle 的配置： 配置 Asset Bundle 需要手动升级的情况 你在自己的代码中使用了 loader.downloader.loadSubpackage 来加载分包。 升级步骤 备份好旧项目 在 Dashboard 中使用 Cocos Creator v3.0 打开需要升级分包的旧项目，Creator 会对有影响的资源重新导入。第一次导入时会稍微多花一点时间，导入完毕后就会打开编辑器主窗口。然后使用代码编辑器将所有 loader.downloader.loadSubpackage 替换为 assetManager.loadBundle。 // 修改前 loader.downloader.loadSubpackage('sub1', (err) => { loader.loadRes('sub1/sprite-frames/background', SpriteFrame); }); // 修改后 assetManager.loadBundle('sub1', (err, bundle) => { // 传入该资源相对 Asset Bundle 根目录的相对路径 bundle.load('sprite-frames/background/spriteFrame', SpriteFrame); }); 注意：加载 Asset Bundle 中的资源需要使用 Asset Bundle 相关的 API，具体请查看 API 文档 Asset Bundle。 Asset Bundle 的使用方式 关于 Asset Bundle 的具体使用方式，请参考文档 Asset Bundle。 "},"asset/dynamic-load-resources.html":{"url":"asset/dynamic-load-resources.html","title":"资源加载","keywords":"","body":"加载资源 动态加载 resources 通常我们会把项目中需要动态加载的资源放在 resources 目录下，配合 resources.load 等接口动态加载。你只要传入相对 resources 的路径即可，并且路径的结尾处 不能 包含文件扩展名。 // 加载 Prefab resources.load(\"test assets/prefab\", Prefab, (err, prefab) => { const newNode = instantiate(prefab); this.node.addChild(newNode); }); // 加载 AnimationClip resources.load(\"test assets/anim\", AnimationClip, (err, clip) => { this.node.getComponent(Animation).addClip(clip, \"anim\"); }); 所有需要通过脚本动态加载的资源，都必须放置在 resources 文件夹或它的子文件夹下。resources 文件夹需要在 assets 根目录 下手动创建。如下所示： resources 文件夹中的资源，可以引用文件夹外部的其它资源，同样也可以被外部场景或资源所引用。项目构建时，除了在 构建发布 面板中勾选的场景外，resources 文件夹中的所有资源，包括它们关联依赖的 resources 文件夹外部的资源，都会被导出。 如果一份资源仅仅是被 resources 中的其它资源所依赖，而不需要直接被 resources.load 调用，那么 请不要 放在 resources 文件夹中。否则会增大 config.json 的大小，并且项目中无用的资源，将无法在构建的过程中自动剔除。同时在构建过程中，JSON 的自动合并策略也将受到影响，无法尽可能合并零碎的 JSON。 注意：从 v2.4 开始，loader 等接口不再建议使用，请使用最新的 assetManager 相关接口，升级文档请参考 资源加载升级指南。 加载 SpriteFrame 或 Texture2D 图片设置为 sprite-frame 或 texture 或其他图片类型后，将会在 资源管理器 中生成一个对应类型的资源。但如果直接加载 test assets/image，得到的类型将会是 ImageAsset。你必须指定路径到具体的子资源，才能加载到图片生成的 SpriteFrame： // 加载 SpriteFrame，image 是 ImageAsset，spriteFrame 是 image/spriteFrame，texture 是 image/texture resources.load(\"test assets/image/spriteFrame\", SpriteFrame, (err, spriteFrame) => { this.node.getComponent(Sprite).spriteFrame = spriteFrame; }); // 加载 texture resources.load(\"test assets/image/texture\", Texture2D, (err: any, texture: Texture2D) => { const spriteFrame = new SpriteFrame(); spriteFrame.texture = texture; this.node.getComponent(Sprite).spriteFrame = spriteFrame; }); 如果指定了类型参数，就会在路径下查找指定类型的资源。当你在同一个路径下同时包含了多个重名资源（例如同时包含 player.clip 和 player.psd）就需要声明类型。当你需要获取 “子资源”（例如获取 ImageAsset 的子资源 SpriteFrame），就需要指定子资源的路径。 加载图集中的 SpriteFrame 对从 TexturePacker 等第三方工具导入的图集而言，如果要加载其中的 SpriteFrame，则只能先加载图集，再获取其中的 SpriteFrame。这是一种特殊情况。 // 加载 SpriteAtlas（图集），并且获取其中的一个 SpriteFrame // 注意 atlas 资源文件（plist）通常会和一个同名的图片文件（png）放在一个目录下, 所以需要在第二个参数指定资源类型 resources.load(\"test assets/sheep\", SpriteAtlas, (err, atlas) => { const frame = atlas.getSpriteFrame('sheep_down_0'); sprite.spriteFrame = frame; }); 加载 FBX 或 glTF 模型中的资源 在将 FBX 模型或 glTF 模型导入编辑器后，会解析出该模型中包含的相关资源如网格，材质，骨骼，动画等，如下图所示： 你可以在运行时动态加载模型中的单一资源，只需指定到某个具体子资源的路径即可，如下所示： // 加载模型中的网格资源 resources.load(\"Monster/monster\", Mesh, (err, mesh) => { this.node.getComponent(MeshRenderer).mesh = mesh; }); // 加载模型中的材质资源 resources.load(\"Monster/monster-effect\", Material, (err, material) => { this.node.getComponent(MeshRenderer).material = material; }); // 加载模型中的骨骼 resources.load(\"Monster/Armature\", Skeleton, (err, skeleton) => { this.node.getComponent(SkinnedMeshRenderer).skeleton = skeleton; }); 资源批量加载 resources.loadDir 可以加载相同路径下的多个资源： // 加载 test assets 目录下所有资源 resources.loadDir(\"test assets\", function (err, assets) { // ... }); // 加载 test assets 目录下所有 SpriteFrame，并且获取它们的路径 resources.loadDir(\"test assets\", SpriteFrame, function (err, assets) { // ... }); 预加载资源 从 v2.4 开始，除了场景能够预加载之外，其他资源也可以预加载。预加载的加载参数与正常加载时一样，不过预加载只会去下载必要的资源，并不会进行资源的反序列化和初始化工作，所以性能消耗更小，适合游戏运行中使用。 resources 提供了 preload 和 preloadDir 用于预加载资源。 resources.preload('test assets/image/spriteFrame', SpriteFrame); // wait for while resources.load('test assets/image/spriteFrame', SpriteFrame, (err, spriteFrame) => { this.node.getComponent(Sprite).spriteFrame = spriteFrame; }); 开发者可以使用预加载相关接口提前加载资源，不需要等到预加载结束即可使用正常加载接口进行加载，正常加载接口会直接复用预加载过程中已经下载好的内容，缩短加载时间。 关于预加载的说明，请参考 预加载与加载。 加载远程资源和设备资源 在目前的 Cocos Creator 中，我们支持加载远程贴图资源，这对于加载用户头像等需要向服务器请求的贴图很友好，需要注意的是，这需要开发者直接调用 assetManager.loadRemote 方法。同时，如果开发者用其他方式下载了资源到本地设备存储中，也需要用同样的 API 来加载，上文中的 resources.load 等 API 只适用于应用包内的资源和热更新的本地资源。下面是这个 API 的用法： // 远程 url 带图片后缀名 let remoteUrl = \"http://unknown.org/someres.png\"; assetManager.loadRemote(remoteUrl, function (err, imageAsset) { const spriteFrame = new SpriteFrame(); const texture = new Texture2D(); texture.image = imageAsset; spriteFrame.texture = texture; // ... }); // 远程 url 不带图片后缀名，此时必须指定远程图片文件的类型 remoteUrl = \"http://unknown.org/emoji?id=124982374\"; assetManager.loadRemote(remoteUrl, {ext: '.png'}, function (err, imageAsset) { const spriteFrame = new SpriteFrame(); const texture = new Texture2D(); texture.image = imageAsset; spriteFrame.texture = texture; // ... }); // 用绝对路径加载设备存储内的资源，比如相册 const absolutePath = \"/dara/data/some/path/to/image.png\"; assetManager.loadRemote(absolutePath, function (err, imageAsset) { const spriteFrame = new SpriteFrame(); const texture = new Texture2D(); texture.image = imageAsset; spriteFrame.texture = texture; // ... }); // 远程音频 remoteUrl = \"http://unknown.org/sound.mp3\"; assetManager.loadRemote(remoteUrl, function (err, audioClip) { // play audio clip }); // 远程文本 remoteUrl = \"http://unknown.org/skill.txt\"; assetManager.loadRemote(remoteUrl, function (err, textAsset) { // use string to do something }); 目前的此类手动资源加载还有一些限制，对开发者影响比较大的是： 这种加载方式只支持图片、声音、文本等原生资源类型，不支持 SpriteFrame、SpriteAtlas、TiledMap 等资源的直接加载和解析。（如需远程加载所有资源，可使用 Asset Bundle) Web 端的远程加载受到浏览器的 CORS 跨域策略限制，如果对方服务器禁止跨域访问，那么会加载失败，而且由于 WebGL 安全策略的限制，即便对方服务器允许 http 请求成功之后也无法渲染。 "},"asset/bundle.html":{"url":"asset/bundle.html","title":"Asset Bundle","keywords":"","body":"Asset Bundle 介绍 文：Santy-Wang、Xunyi 从 v2.4 开始，Creator 正式支持 Asset Bundle 功能。Asset Bundle 作为资源模块化工具，允许开发者按照项目需求将贴图、脚本、场景等资源划分在多个 Asset Bundle 中，然后在游戏运行过程中，按照需求去加载不同的 Asset Bundle，以减少启动时需要加载的资源数量，从而减少首次下载和加载游戏时所需的时间。 Asset Bundle 可以按需求随意放置，比如可以放在远程服务器、本地、或者小游戏平台的分包中。也可以跨项目复用，用于加载子项目中的 Asset Bundle。 内置 Asset Bundle 项目中除了自定义的 Asset Bundle 外，Creator 还有内置的 3 个 Asset Bundle。与其他自定义 Asset Bundle 一样，内置 Asset Bundle 也可以根据不同平台进行配置。 内置 Asset Bundle 功能说明 配置 main 存放所有在 构建发布 面板的 参与构建场景 中勾选的场景以及其依赖资源 通过配置 构建发布 面板的 主包压缩类型 和 配置主包为远程包 两项 resources 存放 resources 目录下的所有资源以及其依赖资源 通过配置 资源管理器 中的 assets -> resources 文件夹 start-scene 如果在 构建发布 面板中勾选了 初始场景分包，则首场景将会被构建到 start-scene 中。 无法进行配置 在构建完成后，内置 Asset Bundle 会根据配置决定它所生成的位置，具体的配置方法以及生成规则请参考 配置 Asset Bundle。 内置 Asset Bundle 是在 application.js 中进行加载的，你可以通过自定义构建模板功能修改 application.js 中的加载代码，如下所示： // ... function loadAssetBundle (hasResourcesBundle, hasStartSceneBundle) { let promise = Promise.resolve(); const mainBundleRoot = 'http://myserver.com/assets/main'; const resourcesBundleRoot = 'http://myserver.com/assets/resources'; const bundleRoot = hasResourcesBundle ? [resourcesBundleRoot, mainBundleRoot] : [mainBundleRoot]; return bundleRoot.reduce((pre, name) => pre.then(() => loadBundle(name)), Promise.resolve()); } function loadBundle (name) { return new Promise((resolve, reject) => { assetManager.loadBundle(name, (err, bundle) => { if (err) { return reject(err); } resolve(bundle); }); }); } 配置方法 自定义 Asset Bundle 是以 文件夹 为单位进行配置的。当我们在 资源管理器 中选中一个文件夹时，属性检查器 中就会出现一个 配置为 Bundle 的选项，勾选后会出现如下图的配置项： 配置项 功能说明 Bundle 名称 Asset Bundle 构建后的名称，默认会使用这个文件夹的名字，可根据需要修改。 Bundle 优先级 Creator 开放了 20 个可供配置的优先级，构建时将会按照优先级 从大到小 的顺序对 Asset Bundle 依次进行构建。具体内容请参考 Asset Bundle - 优先级。 目标平台 不同平台可使用不同的配置，构建时将根据对应平台的设置来构建 Asset Bundle。 压缩类型 决定 Asset Bundle 最后的输出形式，包括 合并依赖、无压缩、合并所有 JSON、小游戏分包、Zip 5 种压缩类型。具体内容请参考 Asset Bundle - 压缩类型 配置为远程包 是否将 Asset Bundle 配置为远程包，不支持 Web 平台。若勾选了该项，则 Asset Bundle 在构建后会被放到 remote 文件夹，你需要将整个 remote 文件夹放到远程服务器上。构建 OPPO、vivo、华为等小游戏平台时，若勾选了该项，则不会将 Asset Bundle 打包到 rpk 中。 配置完成后点击面板右上方的 绿色打钩按钮，这个文件夹就被配置为 Asset Bundle 了，然后在 构建发布 面板选择对应的平台进行构建。 注意： Creator 有 3 个 内置 Asset Bundle，包括 resources、main、start-scene，在设置 Bundle 名称 时请不要使用这三个名称。 小游戏分包 只能放在本地，不能配置为远程包。所以当 压缩类型 设置为 小游戏分包 时，配置为远程包 项不可勾选。 Zip 压缩类型主要是为了降低网络请求数量，如果放在本地，不用网络请求，则没什么必要。所以要求与 配置为远程包 搭配使用。 优先级 当文件夹设置为 Asset Bundle 之后，会将文件夹中的资源以及文件夹外的相关依赖资源都合并到同一个 Asset Bundle 中。这样就有可能出现某个资源虽然不在 Asset Bundle 文件夹中，但因为同时被两个 Asset Bundle 所依赖，所以属于两个 Asset Bundle 的情况，如图所示： 另一种情况是某个资源在一个 Asset Bundle 文件夹中，但同时又被其他 Asset Bundle 所依赖，如图所示： 在这两种情况下，资源 c 既属于 Asset Bundle A，也属于 Asset Bundle B。那资源 c 究竟存在于哪一个 Asset Bundle 中呢？此时就需要通过调整 Asset Bundle 的优先级来指定了。 Creator 开放了 20 个可供配置的优先级，编辑器在构建时将会按照优先级 从大到小 的顺序对 Asset Bundle 依次进行构建。 当同个资源被 不同优先级 的多个 Asset Bundle 引用时，资源会优先放在优先级高的 Asset Bundle 中，低优先级的 Asset Bundle 只会存储一条记录信息。此时低优先级的 Asset Bundle 会依赖高优先级的 Asset Bundle。 如果你想在低优先级的 Asset Bundle 中加载此共享资源，必须在加载低优先级的 Asset Bundle 之前 先加载高优先级的 Asset Bundle。 当同个资源被 相同优先级 的多个 Asset Bundle 引用时，资源会在每个 Asset Bundle 中都复制一份。此时不同的 Asset Bundle 之间没有依赖关系，可按任意顺序加载。所以请尽量确保共享的资源（例如 Texture、SpriteFrame、Audio 等）所在的 Asset Bundle 优先级更高，以便让更多低优先级的 Asset Bundle 共享资源，从而最小化包体。 四个内置 Asset Bundle 文件夹的优先级分别为： Asset Bundle 优先级 main 7 resources 8 start-scene 20 当四个内置 Asset Bundle 中有相同资源时，资源会优先存储在优先级高的 Asset Bundle 中。建议其他自定义的 Asset Bundle 优先级 不要高于 内置的 Asset Bundle，以便尽可能共享内置 Asset Bundle 中的资源。 压缩类型 Creator 目前提供了 合并依赖、无压缩、合并所有 JSON、小游戏分包、Zip 这几种压缩类型用于优化 Asset Bundle。所有 Asset Bundle 默认使用 合并依赖 压缩类型，开发者可重新设置包括内置 Asset Bundle 在内的所有 Asset Bundle 的压缩类型。 压缩类型 功能说明 合并依赖 构建 Asset Bundle 时会将相互依赖的资源的 JSON 文件合并在一起，从而减少运行时的加载请求次数 无压缩 构建 Asset Bundle 时没有任何压缩操作 合并所有 JSON 构建 Asset Bundle 时会将所有资源的 JSON 文件合并为一个，从而最大化减少请求数量，但可能会增加单个资源的加载时间 小游戏分包 在提供了分包功能的小游戏平台，会将 Asset Bundle 设置为对应平台上的分包。 Zip 在部分小游戏平台，构建 Asset Bundle 时会将资源文件压缩成一个 Zip 文件，从而减少运行时的加载请求数量 如果开发者在不同平台对 Asset Bundle 设置了不同的压缩类型，那么在构建时将根据对应平台的设置来构建 Asset Bundle。 Asset Bundle 的构建 在构建时，配置为 Asset Bundle 的文件夹中的资源（包含场景、代码和其他资源）以及文件夹外的相关依赖资源都会被合并到同一个 Asset Bundle 文件夹中。比如场景 A 放在 a 文件夹中，当 a 文件夹配置为 Asset Bundle 后，场景 A 以及它所依赖的资源都会被合并到 Asset Bundle a 文件夹中。 配置为 Asset Bundle 的文件夹中的所有 代码 和 资源，会进行以下处理： 代码：文件夹中的所有代码会根据发布平台合并成一个 index.js 或 game.js 的入口脚本文件。 资源：文件夹中的所有资源以及文件夹外的相关依赖资源都会放到 import 或 native 目录下。 资源配置：所有资源的配置信息包括路径、类型、版本信息都会被合并成一个 config.json 文件。 构建后生成的 Asset Bundle 目录结构如下图所示： 构建完成后，这个 Asset Bundle 文件夹会被打包到对应平台发布包目录下的 assets 文件夹中。但有以下两种特殊情况： 配置 Asset Bundle 时，若勾选了 配置为远程包，则这个 Asset Bundle 文件夹会被打包到对应平台发布包目录下的 remote 文件夹中。 配置 Asset Bundle 时，若设置了 压缩类型 为 小游戏分包，则这个 Asset Bundle 文件夹会被打包到对应平台发布包目录下的 subpackages 文件夹中。 assets、remote、subpackages 这三个文件夹中包含的每个文件夹都是一个 Asset Bundle。 例如：将 example 工程中的 cases/01_graphics 文件夹在 Web Mobile 平台配置为 Asset Bundle，那么项目构建后将会在发布包目录下的 assets 中生成 01_graphics 文件夹，01_graphics 文件夹就是一个 Asset Bundle。 Asset Bundle 中的脚本 Asset Bundle 支持脚本分包。如果开发者的 Asset Bundle 中包含脚本文件，则所有脚本会被合并为一个 js 文件。在加载 Asset Bundle 时，就会去加载这个 js 文件。 注意： 有些平台不允许加载远程的脚本文件，例如微信小游戏，在这些平台上，Creator 会将 Asset Bundle 的代码拷贝到 src/bundle-scripts 目录下，从而保证正常加载。 不同 Asset Bundle 中的脚本建议最好不要互相引用，否则可能会导致在运行时找不到对应脚本。如果需要引用某些类或变量，可以将该类和变量暴露在一个你自己的全局命名空间中，从而实现共享。 加载 Asset Bundle 引擎提供了一个统一的 API assetManager.loadBundle 来加载 Asset Bundle，加载时需要传入 Asset Bundle 配置面板中的 Bundle 名称 或者 Asset Bundle 的 url。但当你复用其他项目的 Asset Bundle 时，则只能通过 url 进行加载。使用方法如下： assetManager.loadBundle('01_graphics', (err, bundle) => { bundle.load('xxx'); }); // 当复用其他项目的 Asset Bundle 时 assetManager.loadBundle('https://othergame.com/remote/01_graphics', (err, bundle) => { bundle.load('xxx'); }); assetManager.loadBundle 还支持传入用户空间中的路径来加载用户空间中的 Asset Bundle。通过对应平台提供的下载接口将 Asset Bundle 提前下载到用户空间中，然后再使用 loadBundle 进行加载，开发者就可以完全自己管理 Asset Bundle 的下载与缓存过程，更加灵活。例如： // 提前下载某个 Asset Bundle 到用户空间 pathToBundle 目录下。需要保证用户空间下的 Asset Bundle 和对应原始 Asset Bundle 的结构和内容完全一样 // ... // 通过 Asset Bundle 在用户空间中的路径进行加载 // 原生平台 assetManager.loadBundle(jsb.fileUtils.getWritablePath() + '/pathToBundle/bundleName', (err, bundle) => { // ... }); // 微信小游戏平台 assetManager.loadBundle(wx.env.USER_DATA_PATH + '/pathToBundle/bundleName', (err, bundle) => { // ... }); 注意：在配置 Asset Bundle 时，若勾选了 配置为远程包，那么构建时请在 构建发布 面板中填写 资源服务器地址。 在通过 API 加载 Asset Bundle 时，引擎并没有加载 Asset Bundle 中的所有资源，而是加载 Asset Bundle 的 资源清单，以及包含的 所有脚本。 当 Asset Bundle 加载完成后，会触发回调并返回错误信息和 AssetManager.Bundle 类的实例，这个实例就是 Asset Bundle API 的主要入口，开发者可以使用它去加载 Asset Bundle 中的各类资源。 Asset Bundle 的版本 Asset Bundle 在更新上延续了 Creator 的 MD5 方案。当你需要更新远程服务器上的 Asset Bundle 时，请在 构建发布 面板中勾选 MD5 Cache 选项，此时构建出来的 Asset Bundle 中的 config.json 文件名会附带 Hash 值。如图所示： 在加载 Asset Bundle 时 不需要 额外提供对应的 Hash 值，Creator 会在 settings.json 中查询对应的 Hash 值，并自动做出调整。 但如果你想要将相关版本配置信息存储在服务器上，启动时动态获取版本信息以实现热更新，你也可以手动指定一个版本 Hash 值并传入 loadBundle 中，此时将会以传入的 Hash 值为准： assetManager.loadBundle('01_graphics', {version: 'fbc07'}, function (err, bundle) { if (err) { return console.error(err); } console.log('load bundle successfully.'); }); 这样就能绕过缓存中的老版本文件，重新下载最新版本的 Asset Bundle。 加载 Asset Bundle 中的资源 在 Asset Bundle 加载完成后，返回了一个 AssetManager.Bundle 类的实例。我们可以通过实例上的 load 方法来加载 Asset Bundle 中的资源，此方法的参数与 resources.load 相同，只需要传入资源相对 Asset Bundle 的路径即可。但需要注意的是，路径的结尾处 不能 包含文件扩展名。 // 加载 Prefab bundle.load(`prefab`, Prefab, function (err, prefab) { let newNode = instantiate(prefab); director.getScene().addChild(newNode); }); // 加载 Texture bundle.load(`image/texture`, Texture2D, function (err, texture) { console.log(texture) }); 与 resources.load 相同，load 方法也提供了一个类型参数，这在加载同名资源或者加载 SpriteFrame 时十分有效。 // 加载 SpriteFrame bundle.load(`image/spriteFrame`, SpriteFrame, function (err, spriteFrame) { console.log(spriteFrame); }); 批量加载资源 Asset Bundle 提供了 loadDir 方法来批量加载相同目录下的多个资源。此方法的参数与 resources.loadDir 相似，只需要传入该目录相对 Asset Bundle 的路径即可。 // 加载 textures 目录下的所有资源 bundle.loadDir(\"textures\", function (err, assets) { // ... }); // 加载 textures 目录下的所有 Texture 资源 bundle.loadDir(\"textures\", Texture2D, function (err, assets) { // ... }); 加载场景 Asset Bundle 提供了 loadScene 方法用于加载指定 bundle 中的场景，你只需要传入 场景名 即可。 loadScene 与 director.loadScene 不同的地方在于 loadScene 只会加载指定 bundle 中的场景，而不会运行场景，你还需要使用 director.runScene 来运行场景。 bundle.loadScene('test', function (err, scene) { director.runScene(scene); }); 获取 Asset Bundle 当 Asset Bundle 被加载过之后，会被缓存下来，此时开发者可以使用 Asset Bundle 名称来获取该 bundle。例如： let bundle = assetManager.getBundle('01_graphics'); 预加载资源 除了场景，其他资源也可以进行预加载。预加载的加载参数和正常加载时一样，不过因为预加载只会去下载必要的资源，并不会进行资源的反序列化和初始化工作，所以性能消耗更小，更适合在游戏过程中使用。 Asset Bundle 中提供了 preload 和 preloadDir 接口用于预加载 Asset Bundle 中的资源。具体的使用方式和 assetManager 一致，详情可参考文档 预加载与加载。 释放 Asset Bundle 中的资源 在资源加载完成后，所有的资源都会被临时缓存到 assetManager 中，以避免重复加载。当然，缓存中的资源也会占用内存，有些资源如果不再需要用到，可以通过以下三种方式进行释放： 使用常规的 assetManager.releaseAsset 方法进行释放。 bundle.load(`image/spriteFrame`, SpriteFrame, function (err, spriteFrame) { assetManager.releaseAsset(spriteFrame); }); 使用 Asset Bundle 提供的 release 方法，通过传入路径和类型进行释放，只能释放在 Asset Bundle 中的单个资源。参数可以与 Asset Bundle 的 load 方法中使用的参数一致。 bundle.load(`image/spriteFrame`, SpriteFrame, function (err, spriteFrame) { bundle.release(`image`, SpriteFrame); }); 使用 Asset Bundle 提供的 releaseAll 方法，此方法与 assetManager.releaseAll 相似，releaseAll 方法会释放所有属于该 bundle 的资源（包括在 Asset Bundle 中的资源以及其外部的相关依赖资源），请慎重使用。 bundle.load(`image/spriteFrame`, SpriteFrame, function (err, spriteFrame) { bundle.releaseAll(); }); 注意：在释放资源时，Creator 会自动处理该资源的依赖资源，开发者不需要对其依赖资源进行管理。 更多资源释放相关的内容，可参考文档 资源释放。 移除 Asset Bundle 在加载了 Asset Bundle 之后，此 bundle 会一直存在整个游戏过程中，除非开发者手动移除。当手动移除了某个不需要的 bundle，那么此 bundle 的缓存也会被移除，如果需要再次使用，则必须再重新加载一次。 let bundle = assetManager.getBundle('bundle1'); assetManager.removeBundle(bundle); 注意：在移除 Asset Bundle 时，并不会释放该 bundle 中被加载过的资源。如果需要释放，请先使用 Asset Bundle 的 release / releaseAll 方法： let bundle = assetManager.getBundle('bundle1'); // 释放在 Asset Bundle 中的单个资源 bundle.release(`image`, SpriteFrame); assetManager.removeBundle(bundle); let bundle = assetManager.getBundle('bundle1'); // 释放所有属于 Asset Bundle 的资源 bundle.releaseAll(); assetManager.removeBundle(bundle); FAQ Q：Asset Bundle 与 v2.4 之前的资源分包有什么区别？ A： 资源分包实际上是将一些图片和网格拆分出去单独放在一个包内，但这个包是不完整的、无逻辑的，无法复用。 Asset Bundle 是通过逻辑划分对资源进行模块化。Asset Bundle 中包含资源、脚本、元数据和资源清单，所以 Asset Bundle 是完整的、有逻辑的、可复用的，我们可以从 Asset Bundle 中加载出整个场景或其他任何资源。Asset Bundle 通过拆分，可以极大减少首包中的 json 数量以及 settings.json 的大小。 资源分包本质上是由小游戏平台控制的一项基础功能。例如微信小游戏支持分包功能，Creator 就在此基础上做了一层封装，帮助开发者设置资源分包，如果微信小游戏不支持分包功能了，则 Creator 也不支持。 Asset Bundle 则完全由 Creator 设计实现，是一个帮助开发者对资源进行划分的模块化工具，与游戏平台无关，理论上可支持所有平台。 资源分包与平台相关，意味着需要按照平台要求的方式设置，比如微信小游戏的分包无法放在远程服务器上，只能放在腾讯的服务器上。 而 Asset Bundle 不受这些限制，Asset Bundle 可以放在本地、远程服务器，甚至就放在微信小游戏的分包中。 Q：Asset Bundle 是否支持大厅加子游戏的模式？ A：支持，子游戏的场景可以放在 Asset Bundle 中，在需要时加载，子游戏甚至可以在其它项目中预先以 Asset Bundle 的形式构建出来，然后在主项目中加载使用。 Q：Asset Bundle 可以减少 settings.json 的大小吗？ A：当然可以。实际上从 v2.4 开始，打包后的项目完全是基于 Asset Bundle 的，settings.json 不再存储跟资源相关的任何配置信息，所有的配置信息都会存储在每个 Asset Bundle 的 config.json 中。每一个 config.json 只存储各自 Asset Bundle 中的资源信息，也就减小了首包的包体。可以简单地理解为所有的 config.json 加起来等于之前的 settings.json。 Q：Asset Bundle 支持跨项目复用吗？ A：当然支持，不过需要满足以下条件： 引擎版本相同。 Asset Bundle 中引用到的所有脚本都要放在 Asset bundle 下。 Asset Bundle 没有其他外部依赖 bundle，如果有的话，必须加载。 Q：Asset Bundle 支持分离首场景吗？ A：目前仅支持小游戏平台。你可以在 构建发布 面板中勾选 初始场景分包，则首场景会被放到内置 Asset Bundle 的 start-scene 中，从而实现分离首场景。 Q：Asset Bundle 支持嵌套设置吗？比如 A 文件夹中有 B 文件夹，A 和 B 都可以设置为 Asset Bundle？ A：Asset Bundle 不支持嵌套。 "},"asset/release-manager.html":{"url":"asset/release-manager.html","title":"资源释放","keywords":"","body":"资源释放 文：Santy-Wang、Xunyi Asset Manager 中提供了资源释放模块，用于管理资源的释放。 在资源加载完成后，会被临时缓存到 assetManager 中，以便下次复用。但是这也会造成内存和显存的持续增长，所以有些资源如果不需要用到，可以通过 自动释放 或者 手动释放 的方式进行释放。释放资源将会销毁资源的所有内部属性，比如渲染层的相关数据，并移出缓存，从而释放内存和显存（对纹理而言）。 首先最为重要的一点就是：资源之间是互相依赖的。 比如下图，Prefab 资源中的 Node 包含 Sprite 组件，Sprite 组件依赖于 SpriteFrame，SpriteFrame 资源依赖于 Texture 资源，而 Prefab，SpriteFrame 和 Texture 资源都被 assetManager 缓存起来了。这样做的好处是，有可能有另一个 SpriteAtlas 资源依赖于同样的一个 SpriteFrame 和 Texture，那么当你手动加载这个 SpriteAtlas 的时候，就不需要再重新请求贴图资源了，assetManager 会自动使用缓存中的资源。 自动释放 场景的自动释放可以直接在编辑器中设置。在 资源管理器 选中场景后，属性检查器 中会出现 自动释放资源 选项。 勾选后，点击右上方的 应用 按钮，之后在切换该场景时便会自动释放该场景所有的依赖资源。建议场景尽量都勾选自动释放选项，以确保内存占用较低，除了部分高频使用的场景（例如主场景）。 另外，所有 Asset 实例都拥有成员函数 Asset.addRef 和 Asset.decRef，分别用于增加和减少引用计数。一旦引用计数为零，Creator 会对资源进行自动释放（需要先通过释放检查，具体可参考下部分内容的介绍） start () { resources.load('images/background', Texture2D, (err, texture) => { this.texture = texture; // 当需要使用资源时，增加其引用 texture.addRef(); // ... }); } onDestroy () { // 当不需要使用资源时，减少引用 // Creator 会在调用 decRef 后尝试对其进行自动释放 this.texture.decRef(); } 自动释放的优势在于不用显式地调用释放接口，开发者只需要维护好资源的引用计数，Creator 会根据引用计数自动进行释放。这大大降低了错误释放资源的可能性，并且开发者不需要了解资源之间复杂的引用关系。对于没有特殊需求的项目，建议尽量使用自动释放的方式来释放资源。 释放检查 为了避免错误释放正在使用的资源造成渲染或其他问题，Creator 会在自动释放资源之前进行一系列的检查，只有检查通过了，才会进行自动释放。 如果资源的引用计数为 0，即没有其他地方引用到该资源，则无需做后续检查，直接摧毁该资源，移除缓存。 资源一旦被移除，会同步触发其依赖资源的释放检查，将移除缓存后的资源的 直接 依赖资源（不包含后代）的引用都减 1，并同步触发释放检查。 如果资源的引用计数不为 0，即存在其他地方引用到该资源，此时需要进行循环引用检查，避免出现自己的后代引用自己的情况。如果循环引用检查完成之后引用计数仍不为 0，则终止释放，否则直接摧毁该资源，移除缓存，并触发其依赖资源的释放检查（同步骤 2）。 手动释放 当项目中使用了更复杂的资源释放机制时，可以调用 Asset Manager 的相关接口来手动释放资源。例如： assetManager.releaseAsset(texture); 因为资源管理模块在 v2.4 做了升级，所以释放接口与之前的版本有一点区别： assetManager.releaseAsset 接口仅能释放单个资源，且为了统一，接口只能通过资源本身来释放资源，不能通过资源 UUID、资源 url 等属性进行释放。 在释放资源时，开发者只需要关注资源本身，引擎会 自动释放 其依赖资源，不再需要通过 getDependsRecursively 手动获取依赖。 注意：release 系列接口（例如 release、releaseAsset、releaseAll）会直接释放资源，而不会进行释放检查，只有其依赖资源会进行释放检查。所以当显式调用 release 系列接口时，可以确保资源本身一定会被释放。 引用计数统计 在 v2.4 之前，Creator 选择让开发者自行控制所有资源的释放，包括资源本身及其依赖项，开发者必须手动获取资源所有的依赖项并选择需要释放的依赖项。这种方式给予了开发者最大的控制权，对于小型项目来说工作良好。但随着 Creator 的发展，项目的规模不断扩大，场景所引用的资源不断增加，其他场景也可能复用了这些资源，这就会导致释放资源的复杂度越来越高，开发者要掌握所有资源的使用非常困难。 为了解决这个痛点，Asset Manager 提供了一套基于引用计数的资源释放机制，让开发者可以简单高效地释放资源，不用担心项目规模的急剧膨胀。需要说明的是 Asset Manager 只会自动统计资源之间的静态引用，并不能真实地反应资源在游戏中被动态引用的情况，动态引用还需要开发者进行控制以保证资源能够被正确释放。原因如下： JavaScript 是拥有垃圾回收机制的语言，会对其内存进行管理，在浏览器环境中引擎无法知道某个资源是否被销毁。 JavaScript 无法提供赋值运算符的重载，而引用计数的统计则高度依赖于赋值运算符的重载。 资源的静态引用 当开发者在编辑器中编辑资源时（例如场景、预制件、材质等），需要在这些资源的属性中配置一些其他的资源，例如在材质中设置贴图，在场景的 Sprite 组件上设置 SpriteFrame。那么这些引用关系会被记录在资源的序列化数据中，引擎可以通过这些数据分析出依赖资源列表，像这样的引用关系就是静态引用。 引擎对资源的静态引用的统计方式为： 在使用 assetManager 或者 Asset Bundle 加载某个资源时，引擎会在底层加载管线中记录该资源所有 直接依赖资源 的信息，并将所有 直接依赖资源 的引用计数加 1，然后将该资源的引用计数初始化为 0。 在释放资源时，取得该资源之前记录的所有 直接依赖资源 信息，并将所有依赖资源的引用计数减 1。 因为在释放检查时，如果资源的引用计数为 0，才可以被自动释放。所以上述步骤可以保证资源的依赖资源无法先于资源本身被释放，因为依赖资源的引用计数肯定不为 0。也就是说，只要一个资源本身不被释放，其依赖资源就不会被释放，从而保证在复用资源时不会错误地进行释放。下面我们来看一个例子： 假设现在有一个 A 预制件，其依赖的资源包括 a 材质和 b 材质。a 材质引用了 α 贴图，b 材质引用了 β 贴图。那么在加载 A 预制件之后，a、b 材质的引用计数都为 1，α、β 贴图的引用计数也都为 1。 假设现在又有一个 B 预制件，其依赖的资源包括 b 材质和 c 材质。则在加载 B 预制件之后，b 材质的引用计数为 2，因为它同时被 A 和 B 预制件所引用。而 c 材质的引用计数为 1，α、β 贴图的引用计数也仍为 1。 此时释放 A 预制件，则 a，b 材质的引用计数会各减 1 a 材质的引用计数变为 0，被释放，所以贴图 α 的引用计数减 1 变为了 0，也被释放。 b 材质的引用计数变为 1，被保留，所以贴图 β 的引用计数仍为 1，也被保留。 因为 B 预制件没有被释放，所以 c 材质的引用计数仍为 1，被保留。 资源的动态引用 当开发者在编辑器中没有对资源做任何设置，而是通过代码动态加载资源并设置到场景的组件上，则资源的引用关系不会记录在序列化数据中，引擎无法统计到这部分的引用关系，这些引用关系就是动态引用。 如果开发者在项目中使用动态加载资源来进行动态引用，例如： resources.load('images/background/spriteFrame', SpriteFrame, function (err, spriteFrame) { self.getComponent(Sprite).spriteFrame = spriteFrame; }); 此时会将 SpriteFrame 资源设置到 Sprite 组件上，引擎不会做特殊处理，SpriteFrame 的引用计数仍保持 0。如果动态加载出来的资源需要长期引用、持有，或者复用时，建议使用 addRef 接口手动增加引用计数。例如： resources.load('images/background/spriteFrame', SpriteFrame, function (err, spriteFrame) { self.getComponent(Sprite).spriteFrame = spriteFrame; spriteFrame.addRef(); }); 增加引用计数后，可以保证该资源不会被提前错误释放。而在不需要引用该资源以及相关组件，或者节点销毁时，请 务必记住 使用 decRef 移除引用计数，并将资源引用设为 null，例如： this.spriteFrame.decRef(); this.spriteFrame = null; "},"asset/downloader-parser.html":{"url":"asset/downloader-parser.html","title":"下载与解析","keywords":"","body":"下载与解析 文：Santy-Wang、Xunyi Asset Manager 底层使用了多条加载管线来加载和解析资源，每条管线中都使用了 downloader 和 parser 模块，也就是下载器和解析器。开发者可以通过 assetManager.downloader 和 assetManager.parser 来访问。 下载器 下载器是一个全局单例，包括 下载重试、下载优先级排序 和 下载并发数限制 等功能。 下载重试 下载器如果下载资源失败，会自动重试下载，开发者可以通过 maxRetryCount 和 retryInterval 属性来设置重试下载的相关参数。 maxRetryCount 属性用于设置重试下载的最大次数，默认 3 次。若不需要重试下载，可设置为 0，则下载失败时会立即返回错误。 assetManager.downloader.maxRetryCount = 0; retryInterval 属性用于设置重试下载的间隔时间，默认 2000 ms。若设置为 4000 ms，则下载失败时会先等待 4000 ms，然后再重新下载。 assetManager.downloader.retryInterval = 4000; 下载优先级 Creator 开放了四个下载优先级，下载器将会按照优先级 从大到小 的顺序来下载资源。 资源 优先级 说明 脚本或 Asset Bundle 2 优先级最高 场景资源 1 包括场景中的所有资源，确保场景能够快速加载 开发者手动加载的资源 0 预加载资源 -1 优先级最低，因为预加载更多是提前加载资源，时间要求相对较为宽松 开发者也可以通过可选参数 priority 传入一个优先级来覆盖默认设置，从而控制加载顺序。详情可参考下方的“通过可选参数设置”部分。 设置下载并发数 开发者可以通过 maxConcurrency 和 maxRequestsPerFrame 来设置下载器的最大下载并发数等限制。 maxConcurrency 用于设置下载的最大并发连接数，若当前连接数超过限制，将会进入等待队列。 assetManager.downloader.maxConcurrency = 10; maxRequestsPerFrame 用于设置每帧发起的最大请求数，从而均摊发起请求的 CPU 开销，避免单帧过于卡顿。如果此帧发起的连接数已经达到上限，将延迟到下一帧发起请求。 assetManager.downloader.maxRequestsPerFrame = 6; 另外，downloader 中使用了一个 jsb.Downloader 类的实例，用于在 原生平台 从服务器上下载资源。jsb.Downloader 与 Web 的 XMLHttpRequest 类似。目前 jsb.Downloader 类的实例的下载并发数限制默认为 32，超时时长默认为 30s，如果需要修改默认值，可以在 main.js 中修改： // main.js assetManager.init({ bundleVers: settings.bundleVers, remoteBundles: settings.remoteBundles, server: settings.server, jsbDownloaderMaxTasks: 32, // 最大并发数 jsbDownloaderTimeout: 60 // 超时时长 }); 解析器 解析器用于将文件解析为引擎可识别的资源，开发者可以通过 assetManager.parser 来访问。 通过可选参数设置 在下载器和解析器中的设置都是全局设置，若开发者需要单独设置某个资源，可以通过 可选参数 传入专有设置来覆盖全局设置，例如： assetManager.loadAny({'path': 'test'}, {priority: 2, maxRetryCount: 1, maxConcurrency: 10}, callback); 具体内容可参考文档 可选参数。 预设 Creator 预先对正常加载、预加载、场景加载、Asset Bundle 加载、远程资源加载、脚本加载这 6 种加载情况的下载/解析参数做了预设，其中预加载因为性能考虑，所以限制较大，最大并发数更小。如下所示： { 'default': { priority: 0, }, 'preload': { maxConcurrency: 2, maxRequestsPerFrame: 2, priority: -1, }, 'scene': { maxConcurrency: 8, maxRequestsPerFrame: 8, priority: 1, }, 'bundle': { maxConcurrency: 8, maxRequestsPerFrame: 8, priority: 2, }, 'remote': { maxRetryCount: 4 }, 'script': { priority: 2 } } 开发者可以通过 assetManager.presets 对每种预设进行修改，使用时需要传入预设的名称来访问对应的参数项。 // 修改预加载的预设优先级为 1 let preset = assetManager.presets.preload; preset.priority = 1; 也可以增加自定义预设，并通过可选参数 preset 传入。 // 自定义预设，并通过可选参数 preset 传入 assetManager.presets.mypreset = {maxConcurrency: 10, maxRequestsPerFrame: 6}; assetManager.loadAny({'path': 'test'}, {preset: 'mypreset'}, callback); 注意：通过可选参数、预设以及下载器/解析器本身，均能设置下载和解析过程中的相关参数（例如下载并发数、重试次数等）。当使用多种方式设置了同一个参数时，引擎会按照 可选参数 > 预设 > 下载器/解析器 的先后顺序进行选取使用。也就是说，如果引擎在可选参数中找不到相关设置时，会去预设中查找，如果预设中也找不到时，才会去下载器/解析器中查找。 自定义处理方法 下载器和解析器都拥有一张注册表，在使用 downloader 或 parser 时，下载器和解析器会根据传入的后缀名称去注册表中查找对应的下载方式和解析方式，并将参数传入对应的处理方式之中。当开发者需要修改目前格式的处理方式，或者在项目中增加一个自定义格式时，可以通过注册自定义的处理方式来实现扩展引擎。下载器与解析器都提供了 register 接口用于注册处理方法，使用方式如下： assetManager.downloader.register('.myformat', function (url, options, callback) { // 下载对应资源 ...... }); assetManager.parser.register('.myformat', function (file, options, callback) { // 解析下载完成的文件 ...... }); 自定义的处理方法需要接收三个参数： 第一个参数为处理对象，在下载器中是 url，在解析器中是文件。 第二个参数是可选参数，可选参数可以在调用加载接口时指定。 第三个参数是完成回调，当注册完成处理方法时，需要调用该函数，并传入错误信息或结果。 在注册了处理方法之后，当下载器/解析器遇到带相同扩展名的请求时，会使用对应的处理方式，这些自定义的处理方式将供全局所有加载管线使用。 assetManager.loadAny({'url': 'http://example.com/myAsset.myformat'}, callback); 需要注意的是，处理方法可以接收传入的可选参数，开发者可以利用可选参数实现自定义扩展，具体内容可查看文档 可选参数。 "},"asset/preload-load.html":{"url":"asset/preload-load.html","title":"加载与预加载","keywords":"","body":"加载与预加载 文：Santy-Wang，Xunyi 为了尽可能缩短下载时间，很多游戏都会使用预加载。Asset Manager 中的大部分加载接口包括 load、loadDir、loadScene 都有其对应的预加载版本。加载接口与预加载接口所用的参数是完全一样的，两者的区别在于： 预加载只会下载资源，不会对资源进行解析和初始化操作。 预加载在加载过程中会受到更多限制，例如最大下载并发数会更小。 预加载的下载优先级更低，当多个资源在等待下载时，预加载的资源会放在最后下载。 因为预加载没有做任何解析操作，所以当所有的预加载完成时，不会返回任何可用资源。 相比 Creator v2.4 以前的版本，以上优化手段充分降低了预加载的性能损耗，确保了游戏体验顺畅。开发者可以充分利用游戏过程中的网络带宽缩短后续资源的加载时间。 因为预加载没有去解析资源，所以需要在预加载完成后配合加载接口进行资源的解析和初始化，来完成资源加载。例如： resources.preload('images/background/spriteFrame', SpriteFrame); // wait for while resources.load('images/background/spriteFrame', SpriteFrame, function (err, spriteFrame) { spriteFrame.addRef(); self.getComponent(Sprite).spriteFrame = spriteFrame; }); 注意：加载不需要等到预加载完成后再调用，开发者可以在任何时候进行加载。正常加载接口会直接复用预加载过程中已经下载好的内容，缩短加载时间。 "},"asset/cache-manager.html":{"url":"asset/cache-manager.html","title":"缓存管理器","keywords":"","body":"缓存管理器 文：Santy-Wang、Xunyi 在 Web 平台，资源下载完成之后，缓存是由浏览器进行管理，而不是引擎。 而在某些非 Web 平台，比如微信小游戏，这类平台具备文件系统，可以利用文件系统对一些远程资源进行缓存，但并没有实现资源的缓存机制。此时需要由引擎实现一套缓存机制用于管理从网络上下载下来的资源，包括缓存资源、清除缓存资源、查询缓存资源等功能。 从 v2.4 开始，Creator 在所有存在文件系统的平台上都提供了缓存管理器，以便对缓存进行增删改查操作，开发者可以通过 assetManager.cacheManager 进行访问。 资源的下载、缓存及版本管理 引擎下载资源的逻辑如下： 判断资源是否在游戏包内，如果在则直接使用； 如果不在则查询资源是否在本地缓存中，如果在则直接使用； 如果不在则查询资源是否在临时目录中，如果在则直接使用（原生平台没有临时目录，跳过该步骤）； 如果不在就从远程服务器下载资源，资源下载到临时目录后直接使用（原生平台是将资源下载到缓存目录）； 后台缓慢地将临时目录中的资源保存到本地缓存目录中，以便再次访问时使用（原生平台跳过该步骤）； 当缓存空间占满后资源会保存失败，此时会使用 LRU 算法删除比较久远的资源（原生平台的缓存空间没有大小限制，跳过该步骤，开发者可以手动调用清理）。 对小游戏平台来说，一旦缓存空间占满，所有需要下载的资源都无法保存，只能使用下载保存在临时目录中的资源。而当退出小游戏时，所有的临时目录都会被清理，再次运行游戏时，这些资源又会被再次下载，如此循环往复。 注意：缓存空间超出限制导致文件保存失败的问题不会在微信小游戏的 微信开发者工具 上出现，因为微信开发者工具没有限制缓存大小，所以测试缓存时需要在真实的微信环境中进行测试。 当开启引擎的 md5Cache 功能后，文件的 URL 会随着文件内容的改变而改变，这样当游戏发布新版本后，旧版本的资源在缓存中就自然失效了，只能从服务器请求新的资源，也就达到了版本控制的效果。 上传资源到远程服务器 当包体过大时，需要将资源上传到远程服务器，请将资源所在的 Asset Bundle 配置为远程包。接下来我们以微信小游戏为例，来看一下具体的操作步骤： 合理分配资源，将需要模块化管理的资源文件夹（例如 resources 文件夹）配置为 Asset Bundle，并勾选 配置为远程包，具体可参考文档 配置 Asset Bundle。 如果主包需要配置为远程包，请在 构建发布 面板中勾选 配置主包为远程包。 在 构建发布 面板中勾选 MD5 Cache，设置 资源服务器地址，然后点击 构建。 构建完成后将发布包目录下的 remote 文件夹完整地上传到上一步填写的服务器上。 删除本地发布包目录下的 remote 文件夹。 注意：微信小游戏在测试阶段时，开发者可能无法将项目部署到正式服务器，那就需要在本地服务器测试，请在微信开发者工具的菜单栏中打开 工具 -> 详情 -> 本地设置 页面，勾选 不校验安全域名、web-view（业务域名）、TLS 版本以及 HTTPS 证书 选项。 查询缓存文件 缓存管理器提供了 getCache 接口以查询所有的缓存资源，开发者可以通过传入资源的原路径来查询缓存路径。 resources.load('images/background/texture', Texture2D, function (err, texture) { const cachePath = assetManager.cacheManager.getCache(texture.nativeUrl); console.log(cachePath); }); 查询临时文件 当资源下载到本地后，可能会以临时文件的形式存储在临时目录中。缓存管理器提供了 tempFiles 接口以查询所有下载到临时目录中的资源，开发者可以通过传入资源的原路径进行查询。 assetManager.loadRemote('http://example.com/background.jpg', function (err, texture) { const tempPath = assetManager.cacheManager.getTemp(texture.nativeUrl); console.log(tempPath); }); 缓存资源 缓存管理器中提供了一些参数用于控制资源的缓存： cacheManager.cacheDir —— 控制缓存资源的存储目录。 cacheManager.cacheInterval —— 控制缓存单个资源的周期，默认 500ms 缓存一次。 cacheManager.cacheEnabled —— 控制是否要缓存资源，默认为缓存。另外，开发者也可以通过指定可选参数 cacheEnabled 来覆盖全局设置，例如： assetManager.loadRemote('http://example.com/background.jpg', {cacheEnabled: true}, callback); 清除缓存资源 如果缓存资源超出限制，开发者需要手动清除资源，可以使用缓存管理器 assetManager.cacheManager 提供的 removeCache, clearCache, clearLRU 来清除缓存资源。 clearCache —— 清除缓存目录下的所有缓存资源，请慎重使用。 clearLRU —— 清除缓存目录下比较久远的资源。小游戏平台会在缓存空间满了后自动调用 clearLRU。 removeCache —— 清除单个缓存资源，使用时需要提供资源的原路径，例如： assetManager.loadRemote('http://example.com/background.jpg', function (err, texture) { assetManager.cacheManager.removeCache(texture.nativeUrl); }); 当开发者升级引擎版本后，留在本地的缓存资源还是之前旧版本引擎对应的资源，并不会自动清空。这可能会导致资源加载出错或渲染错误等问题。解决方案有以下两种： 构建时在 构建发布 面板勾选 MD5 Cache 选项，这将确保使用最新版本的资源。 手动清空之前缓存的资源。 在 真机 上通过 assetManager.cacheManager.clearCache() 清空缓存。 微信小游戏在 微信开发者工具 中点击菜单栏的 工具 -> 清除缓存 -> 全部清除 来清空缓存。 "},"asset/options.html":{"url":"asset/options.html","title":"可选参数","keywords":"","body":"可选参数 文：Santy-Wang，Xunyi 为了增加灵活性和可扩展性，Asset Manager 中大部分的加载接口包括 assetManager.loadAny 和 assetManager.preloadAny 都提供了 options 参数。options 除了可以配置 Creator 的内置参数，还可以自定义任意参数用于扩展引擎功能。如果开发者不需要配置引擎内置参数或者扩展引擎功能，可以无视它，直接使用更简单的 API 接口，比如 resources.load。 目前 options 中引擎已使用的参数包括： uuid, url, path, dir, scene, type, priority, preset, audioLoadMode, ext, bundle, onFileProgress, maxConcurrency, maxRequestsPerFrame, maxRetryCount, version, xhrResponseType, xhrWithCredentials, xhrMimeType, xhrTimeout, xhrHeader, reloadAsset, cacheAsset, cacheEnabled 注意：请 不要 使用以上字段作为自定义参数的名称，避免与引擎功能发生冲突。 控制底层加载管线 可选参数是上层业务逻辑与底层加载管线之间的沟通工具。上层业务逻辑提供参数，用于控制下载器、解析器以及加载管线。 控制下载器和解析器 可选参数 priority, maxConcurrency, maxRequestsPerFrame, maxRetryCount 分别用于控制下载器对于下载请求的优先级排序、下载并发数限制、每帧能发起的请求数限制、最大重试次数。 assetManager.loadAny({'path': 'image/background'}, {priority: 2, maxRetryCount: 10}, callback); 控制下载器和解析器的处理方法 下载器/解析器中的文本文件和二进制文件等资源的处理方法，可接受可选参数 xhrResponseType, xhrWithCredentials, xhrMimeType, xhrTimeout, xhrHeader, onFileProgress 用于设置 XHR 的返回类型、头部以及下载进度回调等参数。 // 获取 XHR 的下载进度回调 assetManager.loadAny({ 'path': 'image/background' }, { onFileProgress: function (loaded, total) { console.log(loaded/total); } }, callback); 而可选参数 audioLoadMode 则用于控制音频文件的处理方法是否使用 WebAudio 来加载音频。 // 使用 WebAudio 远程加载音频 assetManager.loadRemote('http://example.com/background.mp3', {audioLoadMode: AudioClip.LoadMode.WEB_AUDIO}, callback); 注意：想要获取资源的加载进度必须在服务器端做好相关配置。 更多关于处理方法的介绍请参考 下载与解析。 控制加载流程 可选参数 reload, cacheAsset, cacheEnabled 用于控制加载管线是否复用缓存中的资源、是否缓存资源、以及是否缓存文件。 assetManager.loadRemote(url, {reload: true, cacheAsset: false, cacheEnabled: true}, (err, asset) => {}); 而可选参数 uuid, url, path, dir, scene, type, ext, bundle 等，则是用于搜索资源。 assetManager.loadAny({'path': 'images/background', type: SpriteFrame, bundle: 'resources'}, callback); assetManager.loadAny({'dir': 'images', type: SpriteFrame, bundle: 'resources'}, callback); 这种方式完全等价于直接使用 resources.load 和 resources.loadDir。 扩展引擎 开发者可以通过在 管线 和 自定义处理方法 中使用可选参数来扩展引擎的加载功能。 // 扩展管线 assetManager.pipeline.insert(function (task, done) { const input = task.input; for (let i = 0; i 通过可选参数，再结合管线和自定义处理方法，引擎可以获得极大的扩展度。Asset Bundle 可以看做是使用可选参数扩展的第一个实例。 "},"asset/pipeline-task.html":{"url":"asset/pipeline-task.html","title":"管线与任务","keywords":"","body":"管线与任务 文：Santy-Wang，Xunyi 本文适用于对加载流程有定制需求的进阶开发者 为了更方便地修改或者扩展引擎资源加载流程，Asset Manager 底层使用了名为 管线与任务 和 下载与解析 的机制对资源进行加载，本篇内容主要介绍 管线与任务。 虽然在 v2.4 之前的 loader 已经开始使用管线的概念来进行资源加载，但是在 Asset Manager 中，我们对管线进行了重构，使得逻辑更加清晰，也更容易扩展。开发者可以扩展现有管线，也可以使用引擎提供的类 AssetManager.Pipeline 来自定义管线。 管线 管线 可以理解为一系列过程的串联组合，当一个请求经过管线时，会被管线的各个阶段依次进行处理，最后输出处理后的结果。如下图所示： 管线与一般的固定流程相比，优势在于管线中的所有环节都是可拼接和组合的，这意味着开发者可以在现有管线的任意环节插入新的阶段或者移除旧的阶段，极大地增强了灵活性和可扩展性。 内置管线 Asset Manager 中内置了三条管线： 第一条管线用于转换资源路径，找到真实资源路径。 第二条管线用于正常加载。 第三条管线用于预加载。 注意：第二条管线用到了下载器和解析器，第三条管线则用到了下载器，具体内容可参考 下载与解析。 自定义管线 开发者可以对内置管线进行自定义扩展以实现自己的定制需求： assetManager.pipeline.insert(function (task, done) { task.output = task.input; for (let i = 0; i 也可以构建一条新的管线： const pipeline = new AssetManager.Pipeline('test', [(task, done) => { console.log('first step'); done(); }, (task, done) => { console.log('second step'); done(); }]); 构建管线需要一系列方法，每个方法需要传入一个任务参数和一个完成回调参数。开发者可以在方法中访问任务的所有内容，在完成时调用完成回调即可。 任务 任务 就是在管线中流动的请求，一个任务中包括输入、输出、完成回调、可选参数 等内容。当任务在管线中流动时，管线的各个阶段会取出任务的输入，做出一定的处理后存回到输出中。 assetManager.pipeline.insert(function (task, done) { for (let i = 0; i 具体内容可参考 AssetManager.Task 类型。 "},"asset/meta.html":{"url":"asset/meta.html","title":"资源管理注意事项 - meta 文件","keywords":"","body":"资源管理注意事项 --- meta 文件 本文全文转载自 微信公众号：奎特尔星球，转载前已获得作者授权 作者：ShawnZhang Cocos Creator 会为 assets 目录下的每一个文件和目录生成一个同名的 meta 文件，相信大家一定不会太陌生。理解 Creator 生成 meta 文件的作用和机理，能帮助您和您的团队解决在多人开发时常会遇到的资源冲突、文件丢失、组件属性丢失等问题。那 meta 文件是做什么用的呢？下面我们来了解一下。 meta 文件的作用 先来看下场景中的 meta 文件长什么样子： { \"ver\": \"1.0.0\", // 版本 \"uuid\": \"911560ae-98b2-4f4f-862f-36b7499f7ce3\", // 全局唯一 id \"asyncLoadAssets\": false, // 异步加载 \"autoReleaseAssets\": false, // 自动释放资源 \"subMetas\": {} // 子元数据 } 预制件的 meta 文件与场景是一样的。我们再来看一下 png 图片的 meta 文件： { \"ver\": \"1.0.0\", \"uuid\": \"19110ebf-4dda-4c90-99d7-34b2aef4d048\", \"type\": \"sprite\", \"wrapMode\": \"clamp\", \"filterMode\": \"bilinear\", \"subMetas\": { \"img_circular\": { \"ver\": \"1.0.3\", \"uuid\": \"a2d1f885-6c18-4f67-9ad6-97b35f1fcfcf\", \"rawTextureUuid\": \"19110ebf-4dda-4c90-99d7-34b2aef4d048\", \"trimType\": \"auto\", \"trimThreshold\": 1, \"rotated\": false, \"offsetX\": 0, \"offsetY\": 0, \"trimX\": 0, \"trimY\": 0, \"width\": 100, \"height\": 100, \"rawWidth\": 100, \"rawHeight\": 100, \"borderTop\": 0, \"borderBottom\": 0, \"borderLeft\": 0, \"borderRight\": 0, \"subMetas\": {} } } } png 图片的 meta 文件信息比较多，除了基本的 ver 和 uuid 外，还记录了图片的宽高、偏移、九宫格等数据。上面这么多信息，我们这里只关心一个：UUID。 UUID: 通用唯一标识符（Universally Unique Identifier） UUID 是 Creator 用来管理游戏资源的。它会为每个文件分配一个唯一的 id，图集会生成多个。由此可以了解在 Creator 引擎中，识别一个文件不是简单地通过 路径 + 文件名 定位，而是通过 UUID 来引用文件。因此可以在编辑器资源管理中，随意删除、移动文件。 meta 文件更新时机 Creator 生成 meta 文件有以下几种情况： 1、打开工程时 打开项目工程时，Creator 会先扫描 assets 目录，如果哪个文件还没有 meta 文件，此时就会生成。 2、更新资源时 更新资源也会引发 meta 文件的更新： 在 资源管理器 中可以对资源进行文件名修改、改变目录、删除文件，添加文件等操作，请参考 资源管理器。也可以直接从桌面或操作系统的文件管理器中将文件拖入到 资源管理器 中。 还有一种情况是在操作系统的文件管理器中对 assets 目录中的文件进行增、删、改之后切换到编辑器界面，此时可以看到 资源管理器 刷新的过程。 如果一个文件的 meta 文件不存在，上面两种情况都会触发引擎去生成 meta 文件。 meta 文件出错的几种情况及解决方法 下面我们分析下 meta 文件出错的几种可能情况。 UUID 冲突 UUID 是全局唯一的，产生冲突肯定是有不同的文件的 UUID 相同了，一旦出现这个问题会导致 Cocos Creator 资源管理器目录结构加载不完整。如下图所示，遇到这种情况估计会让你吓出一身冷汗： 从提示中可以看到冲突的 UUID 字符串，然后打开操作系统文件管理或代码编辑器，搜索这个 UUID： 此时先关闭 Creator 编辑器，再任意删除其中一个 meta 文件，然后再打开 Creator 编辑器就可以解决。 这种方法虽然可以解决问题，但在编辑器中引用到这个资源的地方将会出现资源丢失，需要重新编辑或者重新配置一次。最好是通过版本管理工具还原此 meta 文件。 出现这种问题的原因一般有以下两个： 在操作系统的文件管理器中移动文件时，将剪切、粘贴不小心操作成了复制、粘贴，同时也把 meta 文件复制过去了。导致项目中同时出现两个相同的 meta 文件。 在多人协作时，从版本管理工具中，更新资源时碰巧遇到别人生成的 UUID 与你的电脑上某个文件生成的 UUID 一样了，但这种情况非常非常罕见。 总的来说，要减少 UUID 冲突发生，最好在引擎资源管理工具中进行添加、移动文件。 UUID 变化 还有一种情况是 UUID 变了，使得旧的 UUID 对应的资源无法找到，这样的话，你曾经编辑的界面将会出现资源、图片丢失，还可能出现组件属性丢失。 如果找不到旧的 UUID 对应的资源，通过 控制台 可以看到 Creator 给出了所在的场景文件名、节点路径、组件、UUID 等非常详细的警告信息。通过警告信息可以快速定位出错的地方。 这种情况又是怎么造成的呢？当有一个人将新资源添加进项目时，忘记切换到编辑器界面使其生成 meta 文件，同时又将这些新增的文件提交到了版本管理中(不包含 meta 文件)。然后，有另一个人去更新了他所提交的资源，同时切换到了编辑器界面进行编辑，这时 Creator 会检查到新资源没有 meta 文件便会立即生成。而当第一个人切换到编辑器的时候也会生成 meta 文件，这样两个人的电脑上为同一个文件，但是生成的 meta 文件中的 UUID 都不相同。 这种情况下，后面进行资源提交或更新的人，肯定也会遇到冲突，如果不明就理就强行解决冲突，就会产生上面所说的问题。下面的时序图就描述了这种错误的工作流程： 因为第一个 A 同学忘记生成 meta 文件并提交，之后其他人都编辑过项目，但每个人生成的 UUID 都不同，这样就会陷入无限的资源出错中，编辑好的东西，一提交更新又出现冲突了。 要解决这个问题注意下面几点： 提交前检查是否有新增文件，有新增文件时，注意是否有 meta 文件，需要一起提交； 拉取文件时，注意是否有新增文件，并且是有 meta 文件成对，如果没有的话，提醒之前提交文件的同学，把 meta 文件一并提交； 提交时，如果发现只有新增的 meta 文件，那这个 meta 文件肯定是自己生成的，需要注意是否使用过这个 meta 文件对应的资源（同名文件）。如果没用过，那请最早提交者把 meta 文件提交了。千万不能将这个 meta 文件提交上去。 注意上面几点基本上就可以杜绝 meta 文件 UUID 变化导致的工程出错了。 小结 meta 文件是 Creator 用于资源管理的重要手段，但在多人协同开发中稍有不慎就容易产生资源错误。要解决这个问题，不仅需要理解 meta 文件的产生机制和导致冲突的原因，同时还应该规范资源提交流程。 "},"editor/extension/readme.html":{"url":"editor/extension/readme.html","title":"扩展编辑器","keywords":"","body":"扩展编辑器 本章主要介绍一些编辑器的扩展功能，包括以下内容： 第一个扩展包 第一个面板 第一次数据交互 安装与分享 提交插件到商店 扩展面板 扩展已有功能 基础功能 "},"editor/extension/first.html":{"url":"editor/extension/first.html","title":"第一个扩展包","keywords":"","body":"第一个扩展 我们将通过本文，学会创建一个 Creator 扩展，并通过扩展执行一段自定义脚本。 创建并安装扩展 在编辑器的菜单栏中点击 扩展 -> 创建扩展，选择 全局/项目 后即可创建一个扩展包。 若选择 全局，则是将扩展包应用到所有的 Cocos Creator 项目，全局 路径为： Windows：%USERPROFILE%\\.CocosCreator\\extensions MacOS：$HOME/.CocosCreator/extensions 若选择 项目，则是将扩展包应用到指定的 Cocos Creator 项目，项目 路径为： $你的项目地址/extensions 创建扩展时会提示是否直接启动该扩展，可根据需要自行选择（示例中选择启动）： 然后点击顶部菜单栏中的 扩展 -> 扩展管理器 -> 项目/全局，即可看到刚才创建的扩展，默认名称为 simple-时间戳： ：在操作系统的文件管理器中打开扩展包 ：刷新扩展 ：删除扩展 ：启动/关闭扩展 点击 按钮打开扩展包，扩展包的目录结构如下： 定义描述文件 package.json 每个扩展都需要有一份 package.json 文件，用于描述改扩展的用途。只有完整定义了描述文件 package.json 后，编辑器才能知道这个扩展里定义的具体功能，以及加载入口等信息。 虽然 package.json 在很多字段上的定义和 node.js 的 npm package 相似，但它们显然是为不同的产品服务而特殊定制的。所以从 npm 社区中下载的 npm 模块，并不能直接放入到 Cocos Creator 中变成扩展，但是我们可以在 Creator 扩展中使用 npm 社区里的模块。 让我们接着刚刚的操作，打开 package.json 文件，可以看到以下内容： { \"name\": \"simple-1634093231454\", \"package_version\": 2, \"version\": \"1.0.0\", \"description\": \"A Simple Extension\", \"author\": \"Unknown\", \"main\": \"browser.js\" } 将其改为： { \"name\": \"hello-world\", \"package_version\": 2, \"version\": \"1.0.0\", \"description\": \"A Simple Extension\", \"author\": \"Unknown\", \"main\": \"browser.js\", \"contributions\": { \"menu\": [{ \"path\": \"Develop\", \"label\": \"test\", \"message\": \"log\" }], \"messages\": { \"log\": { \"methods\": [\"log\"] } } } } 其中字段含义如下： name String - 定义了包的名字，包的名字是全局唯一的，关系到今后在官网服务器上登录时的名字 注意：插件若要上传到 Cocos Store，对包名有一定的限制，只允许使用 小写字母、数字，连字符（-）、下划线（_） 和 点（.），并以 小写字母 或 数字 开头。 version String：版本号，我们推荐使用 semver 格式管理你的包版本。 main String（可选）：入口程序文件 description String（可选）：一句话描述你的包是做什么的 contributions Object（可选）：对编辑器已有功能进行扩展的配置对象 menu：数组，向 menu 组件提供一个菜单的基础信息，最后将这个菜单绑定到一条的消息。具体内容请参考 扩展主菜单。 messages：messages 对象，这是编辑器消息注册的方法，这个消息可以绑定一个或多个的扩展内定义的方法。更多定义数据请参考 消息通信。 更多关于 package.json 格式的定义，请参考 扩展定义。 入口程序 browser.js 定义好描述文件 package.json 之后，接下来就要书写入口程序 browser.js 了。 内容如下: 'use strict'; // 扩展内定义的方法 exports.methods = { log() { console.log('Hello World'); }, }; // 当扩展被启动的时候执行 exports.load = function() {}; // 当扩展被关闭的时候执行 exports.unload = function() {}; exports.methods 中定义的方法，将会作为操作的接口，通过 消息系统 跨扩展调用，或者是和面板通信。 这份入口程序是扩展的主进程，会在 Cocos Creator 的启动过程中被加载。因为 Creator 启动时会启动各个扩展，启动扩展便会加载扩展的主进程。 运行扩展 返回编辑器，点击顶部菜单栏中的 扩展 -> 扩展管理器 -> 项目/全局，找到之前创建的扩展。点击扩展右侧的 按钮，使上面的修改内容生效，可以看到扩展的名称改成了 hello-world。 若扩展已启动，在 Creator 顶部菜单栏区域会出现一个 Develop 菜单，里面有一个 test 菜单项。点击 test，便会根据定义触发消息发送，并根据消息定义，执行扩展里的对应方法，然后在 控制台 打印出日志信息 “Hello World”。 恭喜你已经编写了第一个简单的编辑器扩展。 "},"editor/extension/first-panel.html":{"url":"editor/extension/first-panel.html","title":"第一个面板","keywords":"","body":"第一个面板 第一个扩展包 中介绍了怎么创建一个最简单的插件。接下来我们将在这篇文档继续学习如何创建一个面板并与之通信。 在描述文件 package.json 内定义面板 在使用面板之前，需要先在 package.json 里进行定义，增加 \"panels\" 字段，并在 contributions.messages 里增加一条消息 \"open-panel\"，以及一个 \"menu\"： { \"name\": \"hello-world\", \"version\": \"1.0.0\", \"main\": \"./browser.js\", \"description\": \"一份简单的扩展\", \"panels\": { \"default\": { \"title\": \"simple panel\", \"main\": \"./panels/default.js\" } }, \"contributions\": { \"menu\": [ { \"path\": \"Develop\", \"label\": \"test\", \"message\": \"log\" }, { \"path\": \"i18n:menu.panel/Custom\", \"label\": \"Open Hello World\", \"message\": \"open-panel\" } ], \"messages\": { \"log\": { \"methods\": [\"log\"] }, \"open-panel\": { \"methods\": [\"openPanel\"] } } } } panel 字段含义可以参考 扩展面板。 增加 panels/default.js 面板文件 上个步骤我们在 panel 数据里定义了入口为 panels/default.js 文件，需要将它新建出来： 'use strict'; // 面板的内容 exports.template = 'Hello'; // 面板上的样式 exports.style = 'div { color: yellow; }'; // 快捷选择器 exports.$ = { elem: 'div', }; // 面板启动后触发的钩子函数 exports.ready = function() { this.$.elem.innerHTML = 'Hello World'; }; // 面板关闭后的钩子函数 exports.close = function() {}; template 是面板的 html 内容，style 为自定义的 style。 更多的参数请参考 编写面板。 在 browser 上增加 openPanel 方法 接下来需要在 browser.js 的 methods 中新增一个 openPanel 方法： 'use strict'; // 扩展内定义的方法 exports.methods = { log() { console.log('Hello World'); }, openPanel() { Editor.Panel.open('hello-world'); }, }; // 当扩展被启动的时候执行 exports.load = function() {}; // 当扩展被关闭的时候执行 exports.unload = function() {}; openPanel 方法里调用了 Editor.Panel.open 方法，传入参数是 插件名字 + . + 面板名，如果是 default 则可忽略，例如： Editor.Panel.open('hello-world'); Editor.Panel.open('hello-world.simple'); 刷新扩展 以上修改完成并保存后，再次打开 Cocos Creator，找到并打开顶部菜单栏中的 扩展 -> 扩展管理器，在面板上选择扩展位置（全局 或者 项目）。然后找到对应插件并点击刷新按钮，Creator 便会重新加载插件内容使之生效。 然后便可以在顶部菜单栏的 面板 -> Custom 中看到新增了 Open Hello World 按钮，点击即可打开我们创建的第一个面板。 "},"editor/extension/first-communication.html":{"url":"editor/extension/first-communication.html","title":"第一次数据交互","keywords":"","body":"第一次数据交互 我们在前面两篇文档 第一个扩展包 和 第一个面板 中介绍了怎么创建扩展，怎么在扩展中定义面板，接下来我们通过本篇文档来尝试一下它们之间的互相通讯。 在描述文件 package.json 内定义消息 首先我们需要在 contributions.messages 中增加一条消息 \"increasing\"，交给 browser 处理。再增加一条 \"hello-world:increasing\" 消息，交给 default 面板处理： { \"name\": \"hello-world\", \"version\": \"1.0.0\", \"main\": \"./browser.js\", \"description\": \"一份简单的扩展\", \"panels\": { \"default\": { \"title\": \"simple panel\", \"main\": \"./panels/default.js\" } }, \"contributions\": { \"menu\": [ { \"path\": \"Develop\", \"label\": \"test\", \"message\": \"log\" }, { \"path\": \"i18n:menu.panel/Custom\", \"label\": \"Open Hello World\", \"message\": \"open-panel\" } ], \"messages\": { \"log\": { \"methods\": [\"log\"] }, \"open-panel\": { \"methods\": [\"openPanel\"] }, \"increasing\": { \"methods\": [\"increasing\"] }, \"query-num\": { \"methods\": [\"queryNum\"] }, \"hello-world:increasing\": { \"methods\": [\"default.increasing\"] } } } } hello-world:increasing 是指我们监听了一个 hello-world 上的 increasing 消息。\"default.increasing\" 指的是交给 default 面板的 \"increasing\" 方法处理。 panel 字段含义可以参考 编写面板。 在 browser.js 里增加 increasing 然后需要在 browser.js 的 methods 中新增一个 increasing 方法，负责记录一个 num，并在每次触发的时候递增并广播出去： 'use strict'; let num = 0; // 扩展内定义的方法 exports.methods = { log() { console.log('Hello World'); }, openPanel() { Editor.Panel.open('hello-world'); }, queryNum() { return num; }, increasing() { num++; Editor.Message.broadcast('hello-world:increasing', num); }, }; // 当扩展被启动的时候执行 exports.load = function() {}; // 当扩展被关闭的时候执行 exports.unload = function() {}; 在 panel 里增加 increasing 按钮以及广播处理 接下来在界面上增加一个 increasing 按钮，以及展示 num 的区域和接受 num 变化的广播消息： 'use strict'; // 面板的内容 exports.template = ` Hello increasing Num: - `; // 面板上的样式 exports.style = 'div { color: yellow; }'; // 快捷选择器 exports.$ = { elem: 'div', button: 'ui-button', num: '.num', }; exports.methods = { increasing(num) { this.$.num.innerHTML = num; }, }; // 面板启动后触发的钩子函数 exports.ready = async function() { this.$.elem.innerHTML = 'Hello World'; this.$.button.addEventListener('confirm', () => { Editor.Message.send('hello-world', 'increasing'); }); this.$.num.innerHTML = await Editor.Message.request('hello-world', 'query-num'); }; // 面板关闭后的钩子函数 exports.close = function() {}; 刷新扩展 以上修改完成并保存后，再次打开 Cocos Creator，找到并打开顶部菜单栏中的 扩展 -> 扩展管理器，在面板上选择扩展位置（全局 或者 项目）。然后找到对应插件并点击刷新按钮，Creator 便会重新加载插件内容使之生效。 然后便可以在顶部菜单栏的 面板 -> Custom 中看到新增了 Open Hello World 选项，点击即可打开。 "},"editor/extension/install.html":{"url":"editor/extension/install.html","title":"安装与分享","keywords":"","body":"安装与分享 Cocos Creator 在启动项目的过程中会搜索并加载 全局 和 项目 两个路径下的扩展。 如果需要将扩展应用到所有的 Cocos Creator 项目，可以选择将扩展包放在 全局 扩展包路径中： Windows：%USERPROFILE%\\.CocosCreator\\extensions Mac：$HOME/.CocosCreator/extensions 如果只希望将扩展应用到指定的项目，可以选择将扩展包放在 项目 扩展包路径中： $你的项目地址/extensions 打包扩展 当编写好一个扩展后，如果要将扩展共享给其他人使用，则需要将该扩展包压缩。 例如扩展包 hello-world，如果放在项目扩展包路径中，其目录结构如下： MyProject |--assets |--extensions |--hello-world |--package.json |--browser.js ... 全选 hello-world 的内部文件（package.json 和 browser.js），将所有文件压缩成 zip 包，并命名为 hello-world.zip。 zip 包内容格式和文件格式一致： hello-world.zip |--package.json |--browser.js 请注意不要在 zip 包内再嵌套一层扩展目录 安装扩展包 首先在编辑器顶部菜单栏中点击 扩展 -> 扩展管理器，打开 扩展管理器 面板。 然后在 扩展管理器 中选择 项目/全局 选项卡，点击 + 按钮，在弹出的文件选择框中选择打包后的扩展 zip 文件，点击 打开。导入的扩展压缩包会被解压并放到指定的位置（项目/全局 扩展包路径）。 最后在 扩展管理器 对应的 项目/全局 选项卡中找到扩展，点击右边的 启用 按钮，刚刚导入的扩展就可以正常运行了。 卸载已安装的扩展 在 扩展管理器 中找到需要删除的扩展，点击 删除 图标按钮即可，同时扩展所在的文件夹也会删除。如果只需要禁用，可以只选择 \"关闭\"。 重载扩展 开发过程中，有时候需要修改扩展的内容，但修改后扩展已经运行的逻辑不会自动更新，这时候就需要在编辑器内手动重新载入一次扩展。 在 扩展管理器 中找到对应的扩展，然后点击 重新载入 图标按钮，这时候编辑器中的扩展将使用最新的代码和文件重新运行。 "},"editor/extension/store/upload-store.html":{"url":"editor/extension/store/upload-store.html","title":"提交插件到商店","keywords":"","body":"提交资源到商店 Cocos Creator 内置了 扩展商店，可供用户浏览、下载和自动安装官方或者第三方插件、资源。同时用户也可以将自己开发的扩展插件、美术素材、音乐音效等资源提交到扩展商店以便分享或者售卖。接下来我们以提交扩展插件为例来看一下具体的提交流程。 打包插件 假设开发者完成的插件扩展包目录结构如下： foobar |--panel |--index.js |--package.json |--main.js 开发者需要将 foobar 文件夹打包成 foobar.zip 文件，然后提交到 Cocos 开发者中心。 更多关于插件扩展包的内容，可参考文档 创建扩展包。 第三方库 目前扩展包安装系统中没有安装 NPM 等包括管理系统的工作流程，因此使用了第三方库的扩展包应该将 node_modules 等文件夹也一起打包到 zip 包中。 提交插件 访问 Cocos 开发者中心 并登录，然后进入 商店 栏目，点击右上方的 发布新资源。 然后进入 资源类别 页面，填写 名称 和 类别，勾选已阅读协议。 名称：插件显示在扩展商店中的名称。需要注意的是，名称一经确认后不可更改，请谨慎填写。 类别：要提交的资源类别，我们这里选择 Creator 扩展 -> 插件。 设置完成后点击 下一步，进入 资源介绍 页面。 在 资源介绍 页面填写相关信息。 关键字：方便用户更快搜索到您的插件，支持多个关键字 支持平台：包括 Android、iOS、HTML5 图标：图标尺寸为 256 * 256，大小不超过 500KB，png 格式。 截图：最多上传 5 张截图，jpg / png 格式。每张截图的尺寸限制范围为最小 640px，最大 2048px，且大小不超过 1000KB。 资源介绍：填写插件的基本功能和使用方法。包括 中文 和 英文 两种语言，填写后才会显示在对应语言版本的扩展商店中。扩展商店对插件的资源介绍有一定的格式规范要求，详情请参考 资源介绍模板。 填写完成后点击 下一步 进入 定价 页面。 在 定价 页面设置插件的售价，包括 CNY 和 USD 两种，如果免费请填写 0。 填写完成后点击 下一步 进入 上传资源 页面 在 上传资源 页面上传插件扩展包资源并填写相关信息。 资源包：zip 格式，最大 100MB。 插件扩展包名：插件扩展包的名称，定义在扩展包的 package.json 文件中。 版本号：插件版本号，定义在扩展包的 package.json 文件中。书写规范请遵守 semver 规范。 Creator 版本要求：插件对 Creator 版本的要求。 注意：由于 Creator 2.x 和 3.x 插件互不兼容，如果没有对应的版本支持插件包，作品将不会显示到对应版本的 Creator 插件商店中。 填写完成后点击 下一步 进入 提交审核 页面。 在 提交审核 页面点击 提交审核 按钮即可，也可以点击 查看 按钮重新编辑该插件资源。 提交审核后，扩展商店的管理人员会在 3 个工作日内审核插件内容和信息： "},"editor/extension/panel.html":{"url":"editor/extension/panel.html","title":"扩展面板","keywords":"","body":"扩展面板 在实现一个功能的同时，很可能需要界面上的 UI 交互，Cocos Creator 3.0 也提供了扩展功能。 在扩展里声明面板 在 package.json 里可以定义 panels 字段： { \"name\": \"hello-world\", \"panels\": { \"default\": { \"title\": \"world panel\", \"type\": \"dockable\", \"main\": \"./panels/default.js\", \"icon\": \"./static/default.png\" }, \"list\": { \"title\": \"world list\", \"type\": \"simple\", \"main\": \"./panels/list.js\", \"icon\": \"./static/list.png\", \"flags\": {}, \"size\": {} } } } 这个字段是个 object，定义如下： // panels 定义 interface PanelMap { [name: string]: PanelInfo; } // 每个 panel 的定义 interface PanelInfo { // 面板标题，支持 i18n:key 格式 title: string; // 面板入口，一个相对路径 main: string; // 面板图标，一个相对路径 icon?: string; // 面板类型，默认 dockable type?: 'dockable' | 'simple'; flags?: PanelFlags; size?: PanelSize; } // panel 里的一些标记 interface PanelFlags { // 是否允许缩放，默认 true resizable?: boolean; // 是否需要保存，默认 false save?: boolean; } // panel 的一些尺寸限制 interface PanelSize { width?: number; height?: number; 'min-width'?: number; 'min-height'?: number; } 编写面板 上面我们注册的时候定义了 panel 入口文件 panels/default.js： 'use strict'; // 监听面板事件 exports.listeners = { // 面板显示的时候触发的钩子 show() {}, // 面板隐藏的时候触发的钩子 hide() {}, }; // 面板的内容 exports.template = 'Hello'; // 面板上的样式 exports.style = 'div { color: yellow; }'; // 快捷选择器 exports.$ = { elem: 'div', }; // 面板启动后触发的钩子函数 exports.ready = function() { this.$.elem.innerHTML = 'Hello World'; }; // 面板准备关闭的时候会触发的函数，return false 的话，会终止关闭面板 exports.beforeClose = function() {}; // 面板关闭后的钩子函数 exports.close = function() {}; 另外我们还定义了一个 list 面板，也需要按照上面的格式编写一个 list.js 文件。 "},"editor/extension/panel-boot.html":{"url":"editor/extension/panel-boot.html","title":"编写面板","keywords":"","body":"编写面板 我们已经在 package.json 里写好了面板的定义，这时候就需要实现面板的逻辑功能了。 这时候就需要在 panel 定义中标识 main 入口文件，并填充其内容： 'use strict'; // html 文本 exports.template = ''; // 样式文本 exports.style = ''; // 渲染后 html 选择器 exports.$ = {}; // 面板上的方法 exports.methods = {}; // 面板上触发的事件 exports.listeners = {}; // 当面板渲染成功后触发 exports.ready = async function() {}; // 尝试关闭面板的时候触发 exports.beforeClose = async function() {}; // 当面板实际关闭后触发 exports.close = async function() {}; template html 字符串，例如： exports.template = ` Header Section `; 也可以直接读取一个 html 文件： const { readFileSync } = require('fs'); const { join } = require('path'); exports.template = readFileSync(join(__dirname, '../static/default.html'), 'utf8'); 当定义好 template 后，面板被打开的时候，将自动把 template 的内容渲染到界面上。 此外编辑器也提供了一些 custom element，可以参考 UI 组件 使用。 style 有了 html，还需要自定义一些样式就需要使用 style 了，style 和 template 一样是一个字符串。 exports.style = ` header { padding: 10px; } `; 当然，也可以读取一个 css 文件： const { readFileSync } = require('fs'); const { join } = require('path'); exports.style = readFileSync(join(__dirname, '../static/default.css'), 'utf8'); $ 这是一个 html 元素选择器，直接调用 querySelector 查找到指定元素后，作为一个快捷方式使用。 exports.$ = { header: 'header', test: '.test', }; 首先定义好选择器，编辑器会在 template 渲染完成后，自动调用 document.querySelector 找到对应的元素，并挂在 this.$ 上： exports.ready = function() { console.log(this.$.header); // console.log(this.$.test); // } methods 面板上定义的方法。面板对外的功能都需要封装成方法，以函数为单位对外提供。消息也可以直接触发面板上的方法，详细请参考 消息通信 这个对象里都是函数，请不要挂载其他类型的对象到这里。 const packageJSON = require('./package.json'); exports.methods = { open() { Editor.Panel.open(packageJSON.name); }, }; listeners 基础的布局完成后，我们有时候需要根据一些情况，去更新一些面板上的状态，这时候就需要使用 listeners 功能了。 exports.listeners = { /** * 面板隐藏的时候触发 */ hide() { console.log(this.hidden); }, /** * 面板显示的时候触发 */ show() { console.log(this.hidden); }, /** * 面板大小更改的时候触发 */ resize() { console.log(this.clientHeight); console.log(this.clientWidth); }, }; ready 当面板启动完成的时候，将会触发这个生命周期函数。 beforeClose 当面板尝试被关闭的时候，将会触发这个函数，beforeClose 可以是一个 async 函数，可以进行异步判断，如果 return false，则会终止当前的关闭操作。 请不要在这个函数里执行实际的销毁和关闭相关的逻辑代码，这一步骤只是进行询问，实际的销毁请放到 close 函数里。 请谨慎使用 如果判断错误，可能导致编辑器或者面板窗口无法正常关闭。 close 当窗口内的所有面板允许关闭后，会触发面板的 close，一旦触发 close，结束后将强制关闭窗口，所以请在 close 进行数据的保存，如果出现异常关闭，请做好数据的备份，以便在重新启动的时候尽可能恢复数据。 "},"editor/extension/panel-messages.html":{"url":"editor/extension/panel-messages.html","title":"面板与插件的通信","keywords":"","body":"面板与扩展的通信 一些实用工具或者是简单的功能可以直接写在面板上，但是面板不是可靠的数据存储位置，窗口随时可能被关闭，面板也会被关闭。 最常见的例子就是某个面板被拖拽停靠到主窗口里。这时候面板会先关闭，然后在主窗口内重新打开，而面板上使用的内存里的数据如果不进行存储和备份，则会随着重启而丢失。 这时候就需要与扩展主体进行一定程度的数据交互。 在看这章节前，需要对 消息系统 有一定程度的了解。 定义扩展上和面板的方法 首先我们定义一份 package.json： { \"name\": \"hello-world\", \"main\": \"./browser.js\", \"panels\": { \"default\": { \"title\": \"hw\", \"main\": \"./panel.js\" } }, \"contributions\": { \"messages\": { \"upload\": { \"methods\": [\"saveData\"] }, \"query\": { \"methods\": [\"queryData\"] } } } } 然后定义扩展的 main 文件 browser.js： exports.methods = { saveData(path, data) { // 收到数据后缓存起来 this.cache[path] = data; }, queryData(path) { const result = this.cache[path]; delete this.cache[path]; return result; }, }; exports.load = function() {}; exports.unload = function() {}; 然后定义面板的 main 文件： const packageJSON = require('./package.json'); exports.ready = async () => { const tab = await Editor.Message.request(packageJSON.name, 'query', 'tab'); const subTab = await Editor.Message.request(packageJSON.name, 'query', 'subTab'); // 打印查询到的数据 console.log(tab, subTab): // TODO 使用这两个数据初始化 }; exports.close() { // 收到数据后上传到扩展进程 Editor.Message.send(packageJSON.name, 'upload', 'tab', 1); Editor.Message.send(packageJSON.name, 'upload', 'subTab', 0); }; 发送消息 当定义好扩展和扩展里的面板后，就可以尝试触发这些消息。 按下 ctrl(cmd) + shift + i 打开控制台。在控制台打开面板： // default 可以省略，如果面板名字是非 default，则需要填写 'hello-world.xxx' Editor.Panel.open('hello-world'); 打开面板后，控制台会打印出一句： undefined, undefined 这是因为数据还没有提交。关闭这个面板，然后再次打开，这时候控制台打印出了数据： 1, 0 这是因为面板在关闭的时候，发送了两条消息： Editor.Message.send(packageJSON.name, 'upload', 'tab', 1); Editor.Message.send(packageJSON.name, 'upload', 'subTab', 0); 通过这两条消息，Message 系统首先根据 messages 里的 upload 定义 \"methods\": [\"saveData\"]，将数据保存到扩展进程里。当再次打开面板时，通过以下代码查询到刚刚保存的数据，并初始化界面、打印到控制台： const tab = await Editor.Message.send(packageJSON.name, 'query', 'tab'); const subTab = await Editor.Message.send(packageJSON.name, 'query', 'subTab'); 至此，我们完成了一次面板与扩展进程的交互。 "},"editor/extension/to-panel-messages.html":{"url":"editor/extension/to-panel-messages.html","title":"与其他面板的通信","keywords":"","body":"与面板通信 一般情况下，我们的交互模型是 \"扩展进程\" 为主，\"面板\" 为数据展示。对位传统 web 的话，就是 \"插件\" 功能是服务端，\"面板\" 功能是客户电脑上的浏览器。 这种情况下，一般不会有直接发送数据给面板的情况，有的大部分是一些状态的同步，使用 broadcast 广播即可。 但一些简单的扩展，或者需要浏览器环境的扩展，实际功能可能放在面板上，这时候就需要向面板上发送请求。 在看这章节前，需要对 消息系统 有一定程度的了解。 定义扩展上和面板的方法 首先我们定义一份 package.json： { \"name\": \"hello-world\", \"panels\": { \"default\": { \"title\": \"hw\", \"main\": \"./panel.js\" } }, \"contributions\": { \"messages\": { \"console\": { \"methods\": [\"default.console\"] } } } } messages.console 里的 methods 定义的方法名称是 default.console。表示发给 default 面板里的 console 方法。 (发送到插件进程的话，是直接填写 methodName) 然后定义面板的 panel.js 文件： exports.template = ''; exports.style = ''; exports.methods = { console(str) { console.log(str); }, }; exports.ready = async function() {}; exports.close = function() {}; 发送消息 当我们定义好扩展和扩展里的面板后，就可以尝试触发这些消息。 按下 ctrl(cmd) + shift + i 打开控制台。在控制台打开面板: // default 可以省略，如果面板名字是非 default，则需要填写 'hello-world.xxx' Editor.Panel.open('hello-world'); // 向 hello-world 插件发送一个 console 消息 Editor.Message.send('hello-world', 'console', 'log'); hello world 插件收到消息后，会转给 panel.js 里的 methods.console 进行处理。 所以会在控制台输出一个字符串 \"log\" 至此，我们完成了一次与面板的交互。 "},"editor/extension/contributions.html":{"url":"editor/extension/contributions.html","title":"扩展已有功能","keywords":"","body":"扩展已有的功能 Cocos Creator 支持各个扩展间互相提供数据（contributions）。 我们在编写一个扩展的时候，可以查询编辑器内已有功能是否提供了对外接收 contributions 的功能。如果对应功能提供该功能，则能够在编写扩展的时候使用这些功能。 contributions 数据定义 contributions 功能，统一在 package.json 里的 contributions 字段定义。 { \"name\": \"hello-world\", \"contributions\": {} } contributions 定义规范: interface contributions { [name: string]: any; } name 是功能或者扩展的名字，value 则是 any 类型，由 name 功能（扩展）的作者自行定义。 现阶段只开放了对编辑器内部功能的 contributions，未来我们会为插件之间互相使用 contributions 提供更为便捷的使用方式。 "},"editor/extension/contributions-messages.html":{"url":"editor/extension/contributions-messages.html","title":"自定义消息","keywords":"","body":"消息通信 Cocos Creator 内，所有的交互都是通过 消息系统。 而消息也需要在 \"contributions\" 里定义后才能使用。 查看已有功能的公开消息 编辑器在顶部菜单 \"开发者\" - \"消息列表\" 里，预置了一个消息管理面板，面板里可以显示每个功能定义的公开消息及其说明。 定义一条消息 { \"name\": \"hello-world\", \"contributions\": { \"messages\": { // name 是消息的名称 \"name\": { \"public\": false, \"description\": \"\", \"doc\": \"\", \"methods\": [] } } } } public 类型 {string} 可选 是否对外显示这条消息，如果为 true，则会在消息列表界面显示这条消息的基本信息。 description 类型 {string} 可选 如果 public 为 true，则会在消息列表显示一些简单的描述，支持 i18n:key 语法 doc 类型 {string} 可选 如果 public 为 true，则会显示这条消息的一些文档，支持 i18n:key 语法。 这个文档使用 markdown 格式撰写并渲染。 methods 类型 {string[]} 可选 消息触发的方法队列。 这是一个字符串数组，字符串为扩展或者面板上的方法（methods）。 如果是扩展上的方法，则直接定义 \"methodName\"，如果要触发扩展里定义的面板上的方法，则要填写 \"panelName.methodName\"。例如场景管理器的 ready 方法，就是 scene:ready。 定义广播消息 开发一个扩展的时候，完成一个动作后需要向其他功能发送一些通知，这些通知也需要显示在 \"消息列表\" 面板上的话，可以这样定义消息： { \"name\": \"hello-world\", \"contributions\": { \"messages\": { \"hello-world:ready\": { \"public\": true, \"description\": \"hello-world 插件准备就绪通知\" } } } } "},"editor/extension/contributions-shortcuts.html":{"url":"editor/extension/contributions-shortcuts.html","title":"快捷键","keywords":"","body":"快捷键 编辑器内的快捷键由 \"快捷键管理器\" 统一管理。每一个快捷键都需要绑定一个消息，当快捷键按下的时候，触发绑定的消息。 定义快捷键 { \"name\": \"hello-world\", \"panels\": { \"default\": { \"main\": \"./panel.js\" } }, \"contributions\": { \"messages\": { \"undo\": { \"title\": \"i18n:hello.messages.undo.title\", \"methods\": [\"say-undo\"] } }, \"shortcuts\": [ { \"message\": \"undo\", \"when\": \"panel.hello-world\", \"win\": \"ctrl+z\", \"mac\": \"cmd+z\", } ] } } contributions.messages 详情请参考 消息通信 contributions.shortcuts 参数说明请继续查看下文介绍。 message 类型 {string} 必填 快捷键绑定的消息，当这个快捷键被触发的时候，发送这条消息。快捷键按下的消息只能发送给自己。 when(experimental) 类型 {string} 可选 实验性功能，这个功能语法可能会进行调整 在某些条件下才会触发这个快捷键。 panel.hello-world 则是在 hello-world 面板获得焦点的时候，快捷键才会生效。 win 类型 {string} 必填 在 windows 平台上，监听的按键 mac 类型 {string} 必填 在 MacOS 上，监听的按键 "},"editor/extension/scene-script.html":{"url":"editor/extension/scene-script.html","title":"场景脚本","keywords":"","body":"调用引擎 API 和项目脚本 在插件中可以声明一个特殊的脚本文件（场景脚本），该脚本和项目中的脚本（assets\\ 目录下的脚本）具有相同的环境，也就是说在这个脚本里可以调用引擎 API 和其他项目脚本，实现： 遍历场景中的节点，获取或改动数据 调用项目中的其他脚本完成工作 注册场景脚本 首先在 pacakge.json 的 contributions 属性中添加 scene 字段，该字段的值是一个脚本文件的路径，相对于扩展包目录： { \"name\": \"engine\", \"contributions\": { \"scene\": { \"script\": \"./scene.js\" } } } 编写场景脚本 定义 scene.js 的方法如下： // 模块加载的时候触发的函数 exports.load = function() {}; // 模块卸载的时候触发的函数 exports.unload = function() {}; // 模块内定义的方法 exports.methods = { log() { const { director } = require('cc') director.getScene() } }; 注意：由于升级了脚本系统，原本使用和项目脚本相同的模块引用机制的 cc.require 方法被弃用。 发送消息到 scene.js 在扩展包程序的主进程和渲染进程中，都可以使用下方的接口向 scene.js 发送消息（假设扩展包名是 foobar）： interface ExecuteSceneScriptMethodOptions { // Name of extension name: string; method: string; args: any[]; } const options: ExecuteSceneScriptMethodOptions = { name: 'foobar', method: 'log', args: [] }; await Editor.Message.request('scene', 'execute-scene-script', options); 这样就可以在扩展包中获取到场景所有节点的名字，当然还可以用来对场景节点进行更多的查询和操作。 注意：由于通讯基于 Electron 的底层 IPC 实现，所以切记传输的数据不可以包含原生对象，否则可能导致进程崩溃或者内存暴涨。建议只传输纯 JSON 对象。 "},"editor/extension/contributions-menu.html":{"url":"editor/extension/contributions-menu.html","title":"扩展主菜单","keywords":"","body":"主菜单 编辑器顶部有一栏主菜单，在扩展内可以方便的拓展这一个菜单栏。 注册菜单 当扩展插件需要添加菜单的时候，只需要填写 contributions.menu 对象。例如我们在 \"扩展\" 菜单里增加一个菜单项： { \"name\": \"hello-world\", \"contributions\": { \"messages\": { \"open-panel\": { \"methods\": [\"openPanel\"] } }, \"menu\": [ { \"path\": \"i18n:menu.extension\", \"label\": \"Open Hello World\", \"icon\": \"./static/icon.png\", \"message\": \"open-panel\" } ] } } 这样编辑器将在 \"扩展\" 菜单里新增一个 \"Open Hello World\" 菜单。点击这个菜单后，将会发送一条消息 openPanel 消息给注册菜单的扩展。然后触发扩展里的 openPanel 方法。 path 类型 {string} 必填 顶部菜单的搜索路径，预设的有： i18n:menu.project i18n:menu.node i18n:menu.panel i18n:menu.extension i18n:menu.develop 也可以填写多级菜单，例如 i18n:menu.extension/Hello World label 类型 {string} 必填 菜单项目的名称，支持 i18n:key 语法。 icon 类型 {string} 可选 菜单的图标，传入一个图标相对路径 message 类型 {string} 可选 菜单点击后触发的消息 "},"editor/assets/extension.html":{"url":"editor/assets/extension.html","title":"扩展资源管理器面板","keywords":"","body":"扩展资源管理器面板 扩展右击菜单 右击菜单的显示机制，是在显示之前获取实时的菜单数据。插件预先在自己的 package.json 中注册 assets 模块，就能获取 资源管理器 面板的右击菜单显示事件，并通过事件返回要显示的菜单数据，然后再统一显示出来。注册完成的菜单一般显示在现有菜单的后面。 假设 资源管理器 面板的某个位置 (where) 有右击菜单事件，目前支持扩展的位置 (where) 有： createMenu -- 创建资源的两个入口: 一是面板左上角的 + 按钮；二是右击菜单中的 新建 选项。 dbMenu -- 资源数据库根节点 assetMenu -- 资源普通节点 panelMenu -- 面板空白区域 具体实现步骤： 在编辑器顶部的菜单栏中选择 扩展 -> 创建扩展，根据需要在 全局/项目 目录下新建一个插件。插件包就会生成在根目录/项目目录的 extensions 目录下。 打开插件包的 package.json 文件，然后配置 contributions.assets.menu 属性，其中 methods 引入 assets-menu.js 文件。其他属性如 createMenu 为上述 where 的显式声明，对应的 onCreateMenu 是 assets-menu.js export 出来的方法: // package.json { contributions: { assets: { menu: { methods: './assets-menu.js', // 下面 Demo 示例中有这个文件 createMenu: 'onCreateMenu', assetMenu: 'onAssetMenu', dbMenu: 'onDBMenu', panelMenu: 'onPanelMenu', }, }, }, } 文末的 Demo 示例 中 assets-menu.js 部分代码示例如下： // assets-menu.js exports.onCreateMenu = function (assetInfo) { return [ { label: 'i18n:extend-assets-demo.menu.createAsset', click() { if (!assetInfo) { console.log('get create command from header menu'); } else { console.log('get create command, the detail of diretory asset is:'); console.log(assetInfo); } }, }, ]; }; exports.onAssetMenu = function (assetInfo) { return [ { label: 'i18n:extend-assets-demo.menu.assetCommandParent', submenu: [ { label: 'i18n:extend-assets-demo.menu.assetCommand1', enabled: assetInfo.isDirectory, click() { console.log('get it'); console.log(assetInfo); }, }, { label: 'i18n:extend-assets-demo.menu.assetCommand2', enabled: !assetInfo.isDirectory, click() { console.log('yes, you clicked'); console.log(assetInfo); }, }, ], }, ]; }; assets-menu.js 中 onCreateMenu(assetInfo) 函数及同类函数说明： 参数 assetInfo Object displayName String - 资源用于显示的名字 extends (可选) String[] - 继承类 importer String - 导入器名字 isDirectory Boolean - 是否是文件夹 instantiation (可选) String - 虚拟资源可以实例化成实体的话，会带上这个扩展名 imported Boolean - 是否导入完成 invalid Boolean - 是否导入失败 name String - 资源名字 file String - 资源文件所在的磁盘绝对路径 redirect Object - 跳转指向资源 type String - 资源类型 uuid String - 资源 ID readonly Boolean - 是否只读 type String - 资源类型 url String - db:// 开头的资源地址 uuid String - 资源 ID 返回值 MenuItem[], MenuItem Object type (可选) String - 可选，normal、separator、submenu、checkbox 或 radio label (可选) String - 显示的文本 sublabel (可选) String - 显示的二级文本 submenu (可选) MenuItem[] - 子项菜单 click (可选) Function - 点击事件 enable (可选) Boolean - 是否可用，不可用会有置灰样式 visible (可选) Boolean - 是否显示 accelerator (可选) String - 显示快捷键 checked (可选) Boolean - 当 type 为 checkbox / radio 时是否选中 更多属性可参考 electron menu-item 的数据格式。 实现扩展的效果图如下： 扩展拖入识别 识别一个可被接受的类型，需要编辑器 UI 组件 的支持，其中一个重要的属性是 type, 。自定义一个拖入类型，并注入到 资源管理器 面板的识别范围内，后续在编辑器其他面板将含有该自定义类型的 元素拖入 资源管理器 面板时，资源管理器 面板便能识别到它，并给自定义类型的注册方（插件）发送消息，注册方便能执行一个自定义的动作，比如执行新建一组资源。 具体实现步骤，大致跟上述的 扩展右击菜单 一样，打开插件的 package.json 文件做对应的配置。 // package.json { contributions: { assets: { drop: [ { type: 'my-defined-asset-type-for-drop', // 对应 Demo 示例中 panel.html 的用法 message: 'drop-asset', }, ], menu: './assets-menu.js', }, }, messages: { 'drop-asset': { methods: ['default.dropAsset'], // 'default' 是指当前插件的默认面板 }, }, } 文末的 Demo 示例 中 panel.js 文件： exports.methods = { dropAsset(assetInfo, dragInfo) { console.log(Editor.I18n.t('extend-assets-demo.drop.callback')); console.log(assetInfo); console.log(dragInfo); }, }; assetInfo 参数说明： uuid String - 拖拽资源时，鼠标释放位置的资源 uuid type String - 该资源的类型 isDirectory Boolean - 该资源是否是文件夹 文末的 Demo 示例 中 panel.html 文件： Drag me to assets panel, and look conosole log. Demo 示例 两个扩展功能的可执行代码可下载 范例 查看 "},"editor/extension/contributions-project.html":{"url":"editor/extension/contributions-project.html","title":"扩展项目设置面板","keywords":"","body":"扩展项目设置面板 项目设置 里存放的是和项目运行相关的配置。这部分配置允许进入版本管理，多人共享配置。 例如构建的模块配置、项目内 layers 的配置。这部分配置如果不同步可能造成不同机器上的运行效果不一致。 如果是编辑器相关的配置，请移步至 扩展偏好设置 文档。 面板简介 项目设置分成左右两部分: 左侧是功能模块内部的功能选项卡 右侧则是配置的修改界面 项目设置允许一个功能插件注册多个选项卡，所以左侧选项卡上会有一行小字，标示选项卡属于哪一个功能。 注册方式 我们首先需要在 contributions.profile.project 里定义好配置。然后就可以在 contributions.project 里定义项目设置里需要显示的数据。 注意：项目设置里配置的数据，都应该存放在 project 位置。 注册项目设置数据 定义一份简单的扩展 package.json { \"name\": \"project-test\", \"contributions\": { \"profile\": { \"project\": { \"foo\": { \"default\": 1, } } }, \"project\": { \"tab1\": { \"label\": \"test\", \"content\": { \"foo\": { \"ui\": \"ui-num-input\" } } } } } } 这样我们就在项目设置左边新增了一个叫 test 的标签页， 通过主菜单的 项目->项目设置 菜单打开项目设置, 选中后我们即可在右边的面板修改我们的 foo 配置。 关于如何定义 profile 详细请参看 Profile。 interface Package { 'name': string; 'contributions': { 'profile': { 'project': { [key:string]: ProfileItem; }; }; \"project\": { [key:string]: ProjectGroup; } } } interface ProjectGroup { /** * 项目设置中左侧标签的文字，支持i18n。 **/ label: string; /** * project字段对应注入到项目设置的配置信息，定义的都是 object 对象。 * object 的 key 作为项目设置的唯一标识，value 则是描述这个项目设置的基本信息。 **/ content?: { [key: string]: UIInfo }; /** * 如果配置比较复杂，自动渲染无法满足需求，可以填写 custom 数据。 * 自定义在项目设置中的渲染面板，该面板会在自动渲染的下方出现（如果定义了 properties）。 **/ custom?: string; } /** * 渲染一个配置所需要的信息 **/ interface UIInfo { // 使用哪种 ui 元素渲染，例如 \"ui-num-input\" ui: string; attributes: { // ui 元素上允许传入的 attribute 数据，每一种 ui 允许传入的参数不一样，详细参考 ui-kit 章节 // 假设 ui 为 \"ui-num-input\",此处可以填入 \"step\": 1 [key:string]: any; }; } 点击查看面板的定义 "},"editor/extension/contributions-preferences.html":{"url":"editor/extension/contributions-preferences.html","title":"扩展偏好设置面板","keywords":"","body":"扩展偏好设置面板 编辑器允许每个扩展注册自己的配置，然后在偏好设置面板内显示部分或全部的编辑器配置。在这个面板里，修改的是编辑器功能相关的配置。 如果是项目相关的配置，请移步 项目设置 说明。 偏好设置的面板说明 我们通过顶部菜单 Cocos Creator -> 偏好设置 打开偏好设置面板。 偏好设置面板分成左右两侧： 左侧显示的是提供配置项目的功能插件的名字。 右侧是根据配置渲染出来的操作面板。 面板上的修改，会立即修改到对应的配置项目上。 通常情况下看到的配置都存储在 global 这一层级。如果有些配置有需要放到项目里，则可以将鼠标移动到配置条目上，在左侧出现的小图标上选择 “记录到项目”。那么这个数据将会被保存到项目里，对其修改不会影响到其他项目。 注意： 如果自动渲染的配置存储在项目里，左侧的图标会变黄提示。如果想重新使用全局配置，则点击左侧图标，选择还原到全局配置，这么做将会丢弃项目设置。 只有自动渲染的配置会自动添加图标。如果没有定义 properties，则需要自己在面板上实现图标的变化功能。 另外有一些配置是无法切换全局、本地存储位置的，例如预览场景，必须存储在项目。所以这部分配置应该使用自定义面板。 更多关于 偏好设置 面板的介绍，请参考 偏好设置 文档。 注册方式 偏好设置允许以两种方式显示配置： 通用配置 实验室配置 通用设置直接以选项卡的形式展示，而实验室开关则单独一个选项卡集中展示。 当插件提供的功能比较稳定时建议将配置数据放在通用功能内。 当插件提供的功能处于开发阶段时建议将功能的开关配置数据放在实验室配置中。 我们首先需要在 contributions.profile.editor 里定义好配置。然后就可以在 contributions.preferences 里定义偏好设置里需要显示的数据。 关于如何定义 profile 详细请参看 Profile。 注册偏好设置数据 package.json { \"name\": \"hello-world\", \"contributions\": { \"profile\": { \"editor\": { \"foo\": { \"default\": 0, \"label\": \"foo\" }, \"bar\": { \"default\": false, \"label\": \"bar\" } } }, \"preferences\": { \"properties\": { \"foo\": { \"ui\": \"ui-num-input\" } }, \"laboratory\": [\"bar\"] } } } 这样我们就分别定义了 foo 和 bar 两个编辑器配置，并且将配置添加到了偏好设置中。 其中 foo 被存放在通用配置中，bar 被存放在实验室配置中。 定义好的 profile 数据会被自动注册到 default 上。使用 Editor.Profile.getConfig 将能够获取到默认值。 package.json 的 contributions 需要像下面这样定义。 interface package { \"name\": string; \"contributions\": { \"profile\": { \"editor\": { [key:string]: ProfileItem; }; }; \"preferences\": { /** * 可以填写 properties 数据来自动渲染配置。 * properties 中的 key 对应编辑器配置的 key，value 对应着自动渲染需要的信息。 * 如果 properties 中有定义 ui 则会自动渲染到功能插件名字的选项卡下。 **/ \"properties\": { [key:string]: UIInfo }; /** * 如果配置比较复杂，自动渲染无法满足需求，可以填写 custom 数据。 * 在该处填写自定义面板的入口， * 该面板会在自动渲染的下方出现（如果定义了 properties）。 **/ \"custom\": string; /** * 编辑器内将实验室单独列成了一个选项卡，主要是提供一些实验功能的开关显示。 * 可以填写 laboratory 数据将类型为 Boolean 的编辑器配置添加到实验室开关中。 * laboratory 是一个数组，数组里的 key 指向到编辑器配置内的 key，对应的数据的必须是 Boolean 类型的。 * 在此处填写的 key 将会在偏好设置的实验室选项卡内显示出来。 **/ \"laboratory\": string[]; }; ... } ... } interface UIInfo { // 使用哪种 ui 元素渲染，例如 \"ui-num-input\" ui: string; attributes: { // ui 元素上允许传入的 attribute 数据，每一种 ui 允许传入的参数不一样，详细参考 ui-kit 章节 // 假设 ui 为 \"ui-num-input\" // 此处可以填入 \"step\": 1 [key:string]: any; }; } 关于如何自定义面板请点击查看 面板的定义。 "},"editor/publish/custom-build-plugin.html":{"url":"editor/publish/custom-build-plugin.html","title":"扩展构建流程","keywords":"","body":"扩展构建流程 开发者如果想要扩展构建流程的话，可以通过插件来实现，需要使用到 扩展包。扩展构建功能的前提是需要对构建的整体处理流程有所了解，不熟悉的开发者建议先阅读 构建流程简介与常见问题指南。 基本操作流程 在编辑器的菜单栏中点击 项目 -> 新建构建扩展包，选择 全局/项目 后即可创建一个构建扩展插件包。 若选择 全局，则是将构建扩展包应用到所有的 Cocos Creator 项目，全局 路径为： Windows：%USERPROFILE%\\.CocosCreator\\extensions Mac：$HOME/.CocosCreator/extensions 若选择 项目，则是将构建扩展包应用到指定的 Cocos Creator 项目，项目 路径为： $你的项目地址/extensions 构建扩展包创建完成后会在 控制台 输出生成路径，点击路径即可在操作系统的文件管理器中打开构建扩展包。 启用构建扩展插件之前需要先在目录下执行 npm install 安装一些依赖的 @types 模块才能正常编译。编辑器自带的接口定义已经生成在编辑器根目录的 resources\\3d\\engine\\@types 文件夹下了，后续通过编辑器主菜单的 开发者 -> 导出 .d.ts 即可获取到最新的接口定义。 点击编辑器主菜单中的 扩展 -> 扩展管理器，打开 扩展管理器 面板。然后在 扩展管理器 中选择 项目/全局 选项卡，即可看到刚刚添加的构建扩展插件。然后点击右上方的 启用 按钮，即可正常运行插件。 启用构建扩展插件后，打开 构建发布 面板，可以看到构建扩展插件的展开栏。点击 构建 即可加入构建流程。 如果需要修改构建扩展插件的内容，直接修改 extensions 目录下的构建扩展包即可，具体内容请参考构建扩展包目录下的 readme.md 文件。然后在 扩展管理器 中找到对应的构建扩展插件，点击 重新载入 图标按钮，编辑器中的构建扩展插件便会使用最新的代码和文件重新运行。 入口脚本 构建扩展包需要在 package.json 的 contributions 中添加 builder 字段，然后在 builder 字段中指定一个 JavaScript 脚本的 相对路径，作为构建扩展插件参与到构建流程的入口脚本。 例如： // package.json { \"contributions\": { \"builder\": \"./dist/builder.js\" } } 注意：builder 字段里指定的 ./dist/builder.js 入口脚本是编译后的脚本，入口脚本的源文件则位于 ./source/builder.ts，若需要配置入口脚本，请在源文件中修改。 入口脚本配置 关于入口脚本的配置，代码示例如下： // builder.ts export const configs: IConfigs = { 'web-mobile': { hooks: './hooks', options: { remoteAddress: { label: 'i18n:xxx', render: { ui: 'ui-input', attributes: { placeholder: 'Enter remote address...', }, }, // 校验规则，目前内置了几种常用的校验规则，需要自定义的规则可以在 \"verifyRuleMap\" 字段中配置 verifyRules: ['require', 'http'], }, enterCocos: { label: 'i18n:cocos-build-template.options.enterCocos', description: 'i18n:cocos-build-template.options.enterCocos', default: '', render: { // 请点击编辑器菜单栏中的“开发者 -> UI 组件”，查看所有支持的 UI 组件列表。 ui: 'ui-input', attributes: { placeholder: 'i18n:cocos-build-template.options.enterCocos', }, }, verifyRules: ['ruleTest'] } }, verifyRuleMap: { ruleTest: { message: 'i18n:cocos-build-template.ruleTest_msg', func(val, option) { if (val === 'cocos') { return true; } return false; } } } }, }; 在编写入口脚本时还需要额外注意以下几点： 不同进程中的环境变量会有所差异。入口脚本会同时被 渲染进程 和 主进程 加载，所以请不要在入口脚本中使用仅存在于单一进程中的编辑器接口。进程相关详情请参考下文 调试构建扩展插件 部分的内容。 config 的 key 有两种配置方式： 针对 单个平台 的配置，key 值填写为 平台构建插件名，参考上面的代码示例。各平台对应的构建插件名可在编辑器主菜单的 扩展 -> 扩展管理器 -> 内置 中查看。 针对 所有平台 的配置，key 值填写为 *，参考通过编辑器菜单栏的 新建构建扩展包 生成的 source/builder.ts 文件。 注意：这两种配置方式是互斥的，请不要在同一个构建扩展包中同时使用。否则单个平台的配置（key 值为 平台构建插件名）会覆盖掉所有平台的配置（key 值为 *）。 入口脚本接口定义 关于入口脚本详细的接口定义，说明如下： declare type IConfigs = Record; declare interface IBuildPlugin { hooks?: string; // 钩子函数的存储路径 options?: IDisplayOptions; // 需要注入的平台参数配置 verifyRuleMap?: IVerificationRuleMap; // 注册参数校验规则函数 } declare type IDisplayOptions = Record; declare interface IConfigItem { // 默认值，注册的默认值将会在插件自身配置里的 \"options.[platform].xxx\" 字段内 default?: any; render: ?{ // 渲染 UI 组件规则，与 \"ui-prop\" 处统一规则一致，只有指定了 UI 属性的配置才会在构建发布面板上显示 ui?: string; // 传给 UI 组件的配置参数 attributes?: IUiOptions; }; // 配置显示的名字，如果需要翻译，则传入 \"i18n:${key}\" label?: string; // 简单说明，当鼠标上移到配置名称时会显示在 title 中 description?: string; // 配置的类型 type?: 'array' | 'object'; // 如果 type 是 array，则会按照指定数据类型和 \"itemConfigs\" 来渲染数据 itemConfigs?: Record | IConfigItem[]; } declare interface IUiOptions extends IOptionsBase { // 校验规则数组，构建提供一些基础规则，也可以通过 \"verifyRuleMap\" 来指定新的校验规则，只有当传入 \"require\" 时才会做无值的校验，否则仅存在值时才会校验 verifyRules?: string[]; } declare interface IUiOptions extends IOptionsBase { class?: string | string[]; // 需要设置在当前 \"ui-prop\" 上的样式名称 } 其中 IOptionsBase 的接口定义需要参考 ui-prop 自动渲染规则定义。 钩子函数 在入口脚本的 hooks 字段中定义的脚本，可用于编写构建生命周期的钩子函数。所有的钩子函数都是在构建进程中按照顺序依次执行，不同的钩子函数接收到的数据会有所差异。在构建进程中可以直接使用引擎提供的 API 和 Editor 全局变量，关于 Editor 详细的接口定义请点击编辑器主菜单的 开发者 —> 导出 .d.ts 获取和查看。关于构建进程的说明请参考下文 构建进程 部分的内容。 公开的钩子函数与构建的生命周期的关系请参考下图： 钩子函数大致的接口定义如下所示： declare interface IHook { throwError?: boolean; // 插件注入的钩子函数，表示在执行失败时是否直接退出构建流程，并显示构建失败 // ------------------ 钩子函数 -------------------------- onBeforeBuild?: IBaseHooks; onBeforeCompressSettings?: IBaseHooks; onAfterCompressSettings?: IBaseHooks; onAfterBuild?: IBaseHooks; // 编译生成的钩子函数（仅在构建有“生成”步骤的平台时才有效） onBeforeMake?: (root: string, options: IBuildTaskOptions) => void | Promise; onAfterMake?: (root: string, options: IBuildTaskOptions) => void | Promise; } type IBaseHooks = (options: IBuildTaskOptions, result?: IBuildResult) => void | Promise; 注意： 在 onBeforeCompressSettings 开始才能访问到 result 参数，并且传递到钩子函数中的 options 是实际构建进程中使用的 options 的一个副本，仅作为信息获取的参考，因而直接修改它虽然能修改成功但并不会真正地影响构建流程。构建参数请在入口脚本的 options 字段中修改。由于接口定义比较多，详细的接口定义可以参考构建扩展包中 @types/packages/builder 目录下的内容。 钩子函数允许为异步函数，构建执行钩子函数时默认会 await 等待其执行完毕才会执行下一个流程。 简单的代码示例： export function onBeforeBuild(options) { // To do something... } export async function onBeforeCompressSettings(options, result) { // To do something... } 调试构建扩展插件 构建扩展插件参与到构建流程时，相关代码会运行在以下三种进程： 主进程：执行入口脚本及其依赖资源 渲染进程：执行入口脚本中注册到 构建发布 面板上的部分字段 构建进程：执行入口脚本中 hooks 字段定义的脚本 主进程（入口脚本） 主进程主要执行构建扩展插件中用于参与构建流程的入口脚本（builder 字段中指定的脚本），以及插件自身的入口脚本（main 字段中指定的脚本）。 当修改了运行在主进程中的代码时，必须要重启插件，然后再刷新需要更新的进程（这一点会在之后优化，尽量通过一次重启便解决代码更新问题，但刷新依旧是最彻底的重载方法）。主进程目前没有比较合适的调试方法，可以使用命令行打开编辑器查看主进程代码日志来辅助调试： // Mac /Applications/CocosCreator/Creator/3.0.0/CocosCreator.app/Contents/MacOS/CocosCreator --project projectPath // Windows ...\\CocosCreator.exe --project projectPath 渲染进程（构建面板） 构建扩展插件的入口脚本中，有部分字段是注册到 构建发布 面板上的，例如 options 的显示配置、panel 字段，以及 panel 脚本本身，这部分内容会在渲染进程载入执行。渲染进程其实就是窗口自己的执行进程，打开调试工具，可以调试 构建发布 面板上的 dom 元素、样式、脚本等。 如果是修改了注册到 构建发布 面板上的代码时，只需要刷新面板即可，无需重启插件。 打开构建发布面板渲染进程的调试工具 点击 构建发布 面板，然后按下快捷键 Ctrl + Shift + i（Windows）或者 Cmd + Option + i（Mac），即可打开 构建发布 面板的调试工具。 重新载入（刷新）面板方式 点击 构建发布 面板或者 构建发布 面板的调试工具后，按下 Ctrl/Cmd + R 即可。 构建进程（hooks 脚本） 构建的实际执行阶段是单独的一个 worker 进程，确保即使发生异常崩溃也不会影响到其他窗口的正常使用。在入口脚本的 hooks 字段中定义的脚本也是在这个单独的 worker 进程中载入执行的。 如果仅修改 hook 字段定义的脚本，刷新构建进程即可，无需重启插件。刷新方式同上文的 构建发布 面板一致，打开构建调试工具后，按下快捷键 Ctrl/Cmd + R 即可。 打开构建进程的调试工具 包括以下三种方式： 在 构建发布 面板点击构建任务窗口右上方的 打开构建调试工具 按钮。 点击编辑器主菜单中的 开发者 -> 打开构建调试工具 即可。 在任意插件代码或者控制台中，执行以下代码： Editor.Message.send('builder', 'open-devtools'); 可以在这个消息方法的基础上，根据自己的需要进行扩展。例如：可以在自己编写的构建插件的代码中捕获错误，一旦有异常就自动打开调试工具之类的。 "},"editor/extension/basic.html":{"url":"editor/extension/basic.html","title":"基础功能","keywords":"","body":"基础功能 编辑器内提供了许多功能，这里主要介绍一些常用的功能。 扩展包定义 扩展系统 消息系统 多语言系统 配置系统 UI 组件 "},"editor/extension/define.html":{"url":"editor/extension/define.html","title":"扩展包定义","keywords":"","body":"扩展包的定义 扩展包需要预先定义好所有功能以及一些基础信息，这些信息都需要填写并存放在 package.json 文件里。 { \"name\": \"hello-world\", \"version\": \"1.0.0\", \"author\": \"Creator\", \"description\": \"description\", \"main\": \"./browser.js\", \"panels\": { \"default\": { ... }, \"list\": { ... } }, \"contributions\": {} } name 类型 {string} 必填 扩展的名称，这个名字需要和扩展文件夹一一对应 version 类型 {string} 必填 扩展的版本号，用于提交扩展的版本校验，以及扩展自身的一些升级，数据迁移作为对比的依据。 author 类型 {string} 可选 扩展作者的名字，将会显示在 \"扩展管理器\" 内。 description 类型 {string} 可选 扩展的描述，简单概括一下扩展的功能。支持 i18n:key 的多语言语法。 main 类型 {string} 可选 一个 js 文件的相对路径，定义功能入口文件，当扩展启动的时候，就会执行 main 字段指向的 js 文件，并根据流程触发或执行对应的方法。 panels 类型 {[name: string]: PanelInfo} 可选 扩展内定义的面板信息。可以使用 Editor.Panel.open('hello-world.list'); 打开定义好的面板。详细信息请参看 扩展面板 contributions 类型 {[name: string]: any} 可选 扩展已经存在的功能，能够在定制一些其他功能模块对外开放的功能。详细信息请参看 扩展已有功能 "},"editor/extension/package.html":{"url":"editor/extension/package.html","title":"插件系统","keywords":"","body":"扩展系统 在编写扩展之前，我们首先需要了解一下 Cocos Creator 内，扩展的基础结构。 Cocos Creator 编辑器是基于 GitHub 的 Electron 内核开发。Electron 是一个集成了 Node.js 和 Chromimu 的跨平台开发框架。 在 Electron 的架构中，一份应用程序由主进程和渲染进程组成，其主进程负责管理平台相关的调度，如窗口的开启关闭，菜单选项，基础对话框等等。而每一个新开启的窗口就是一个独立的渲染进程。在 Electron 中，每个进程独立享有自己的 JavaScript 内容，彼此之间无法直接访问。当需要在进程之间传递数据时，就需要使用进程间通信（IPC）。 相关功能可以通过阅读 Electron's introduction document 更深入的理解 Electron 中的主进程和渲染进程的关系。简单点说，Electron 的主进程相当于一个 Node.js 服务端程序，而每一个窗口（渲染进程）则相当于一份客户端网页程序。 Cocos Creator 3.0 编辑器沿用了 Electron 的主进程和渲染进程的结构设计。所以扩展在编辑器内启动并运行的时候，扩展定义的 main 其实是在主进程启动，而 panels 定义的面板，则在渲染进程启动。进程结构简要概括如下： Browser |- panelA |- panelB ... 通信 前面我们已经说到了两个进程之间的 JavaScript 内容是相互独立的，必须靠进程间通信的方式来交换数据。进程间通信实际上就是在一个进程中发消息，然后在另外一个进程中监听消息的过程。Electron 提供了进程间通信对应的模块 ipcMain 和 ipcRenderer 来帮助我们完成这个任务。由于这两个模块仅完成了非常基本的通信功能，并不能满足编辑器，扩展面板与主进程之间的通信需求，所以 Cocos Creator 3.0 在这之上又进行了封装，扩展了进程间消息收发的方法，方便扩展开发者和编辑器开发者制作更多复杂情景。更多说明请查看 消息系统。 扩展的能力 扩展内拥有完整的 nodejs 环境，可以很方便的使用 npm 市场上大量的工具。用于完成自己想要的功能。 如果需要和其他功能交互，则需要对应功能开放对应的操作消息，我们在自己的扩展内，通过 消息系统 触发、查询、处理编辑器内的功能或者数据。已经开放的消息列表可以在顶部菜单 开发者 -> 消息列表 面板里查看。 此外，还可以使用一些工具方便扩展的开发，比如： 使用 TypeScript 开发扩展，编译成 js 后，将编译后的 js 填入 package.json 里供编辑器运行。 面板里 template 渲染完成后，使用 vue 绑定数据，方便面板的交互开发。 扩展只约定了入口，在这中间可以使用大量的外部库进行开发流程的优化。 "},"editor/extension/messages.html":{"url":"editor/extension/messages.html","title":"消息系统","keywords":"","body":"消息系统 Cocos Creator 3.0 中有许多独立运行进程，这些进程间是相互隔离的。所以在编辑器内需要与其他功能进行交互的时候，需要通过\"消息\"进行交互。 编辑器里的\"消息系统\"是 IPC（进程间通信）的功能扩展封装。这个系统承担起了整个编辑器内通讯交互的重担。 消息类型 消息交互分成了两种情况： 普通消息：主动发送某条消息到某个功能（扩展） 广播消息：某个功能（扩展）完成了一个操作后向所有人发送通知，告知操作已经完成 普通消息 可以理解成一种对外的 api，例如 场景编辑器 定义好了一个\"消息\"API query-node（查询节点） { \"name\": \"scene\", \"contributions\": { \"messages\": { \"query-node\": { \"methods\": [\"queryNode\"] } } } } 在编写扩展的时候，就可以使用这个 API 发送消息: const info = await Editor.Message.request('scene', 'query-node', uuid); 这时候就会返回一个 promise 对象，在 await 后，拿到的 info 对象就是实际查询的节点上的部分数据。这种消息类似一种远程调用 API。 广播消息 广播消息是某一个功能内的操作完成后，对外进行的一种通知。还是以 场景编辑器 为例。 场景编辑器 在启动一个 scene 后，通知所有人\"场景\"已经启动完毕： Editor.Message.broadcast('scene:ready', sceneUUID); 在扩展里需要这样定义： { \"name\": \"hello-world\", \"contributions\": { \"messages\": { \"scene:ready\": { \"methods\": [\"initData\"] } } } } 之后，每当场景准备就绪后，广播 scene: ready，就会触发 \"hello-world\" 扩展里的 initData 方法。 消息的命名规范 普通消息 请使用 小写 单词，并且不能包含特殊字符，单词间以 - 连接。 广播消息 不能包含除了 : 以外的特殊字符。格式为 packageName: actionName。 加上 packageName 是为了防止命名出现冲突。在自己的扩展里，监听的时候需要直接标明监听的是哪一个扩展的哪个广播（动作），这样在 package.json 中能够更加直观的了解扩展对消息的处理流程。 编辑器以及扩展开放的消息列表 编辑器内的功能以及扩展对外开放的消息列表，可以通过 开发者 -> 消息列表 面板查看。详细定义规则请参考 contributions.messages 发送消息 Editor.Message.send(pkgName, message, ...args); send 方法只发送消息，并不会等待返回。如果不需要返回数据，且不关心是否执行完成，请使用这个方法。 await Editor.Message.request(pkgName, message, ...args); request 方法返回一个 promise 对象，这个 promise 会接收消息处理后返回的数据。 Editor.Message.broadcast(${pkgName}:${actionName}, ...args); broadcast 方法只发送，并且发送给所有监听对应消息的功能扩展。 "},"editor/extension/i18n.html":{"url":"editor/extension/i18n.html","title":"多语言系统","keywords":"","body":"多语言系统(i18n) 编辑器扩展系统中内置的多语言方案允许扩展配置多份语言的键值映射，并根据编辑器当前的语言设置在扩展里使用不同语言的文字。 要启用多语言功能（以下简称 i18n），请在扩展的目录下新建一个名叫 i18n 的文件夹，并为每种语言添加一个相应的 JavaScript 文件，作为键值映射数据。数据文件名应该和语言的代号一致，如 en.js 对应英语映射数据。 下面是键值映射数据源的例子： en.js module.exports = { 'search': 'Search', 'edit': 'Edit', }; zh.js exports.search = '搜索'; exports.edit = '编辑'; 假设注册的扩展名字叫做 hello-world，则对应的文本翻译 key 为 hello-world.search： Editor.I18n.t('hello-world.search'); 显示对应语言的文本 在脚本中使用 在 JavaScript 或者 TypeScript 脚本中，可以通过 Editor.I18n.t 接口获取当前语言对应的翻译后的文本： Editor.I18n.t('hello-world.search'); 在模版内使用 在 html 模版里需要翻译的话可以使用 ui-label 元素进行翻译： ui-label 是一个普通的行内元素，类似 span。 在 json 或者其他文本定义内使用 一些文本信息，例如在扩展包的 package.json 中注册菜单路径时需要使用翻译功能的时候，只要这个字段支持 i18n 格式的路径，该路径就可以用 i18n:${key} 的形式表示。我们可以写 \"i18n:menu.extension/i18n:hello-world.edit\"，对应的功能模块会帮助查找正确的字符串进行替换。 "},"editor/extension/profile.html":{"url":"editor/extension/profile.html","title":"配置系统","keywords":"","body":"配置系统 在编写扩展的时候，有可能需要保存一些配置，并提供一些配置让用户进行自定义设置。 所以编辑器内就提供了一套配置管理机制。 配置类型 编辑器里的配置分成了两种： 编辑器设置 项目设置 编辑器设置 存放一些编辑器相关的功能设置。这部分也是编辑器的主要配置。 编辑器设置分成三个层级，优先级从高到低： local -> global -> default 项目设置 存放一些和项目相关的配置，这些配置允许，并且需要在项目间共享。 local -> default 注册配置 { \"name\": \"hello-world\", \"contributions\": { \"profile\": { \"editor\": { \"test.a\": { \"default\": 0, \"message\": \"editorTestAChanged\", \"label\": \"测试编辑器配置\" } }, \"project\": { \"test.a\": { \"default\": 1, \"message\": \"projectTestAChanged\", \"label\": \"测试项目配置\" } } } }, } interface ProfileInfo { editor: { [ key: string ]: ProfileItem }; project: { [ key: string ]: ProfileItem }; } interface ProfileItem { // 配置的默认数据 default: any; // 配置更改后，会自动发送这个消息进行通知 message: string; // 简单的描述配置信息的作用，支持 i18n:key 语法 label: string; } contributions.profile 分成 editor 和 project 两种配置，这两中配置的定义都是 object 对象。 object 的 key 为配置的 key，value 则是描述这个配置的基本信息。 default 类型 {any} 可选 配置的默认值。可以是任何类型。 message 类型 {string} 可选 当消息修改后，会触发定义的消息。用于配置改变的时候动态更新一些数据。 label 类型 {string} 可选 简单的描述这个配置。在可以显示配置的地方，可能会显示这个描述。支持 i18n:key 格式 读取配置 读取编辑器配置 const packageJSON = require('./package.json'); // await Editor.Profile.getConfig(pkgName, key, protocol); await Editor.Profile.getConfig(packageJSON.name, 'test.a'); // 0 await Editor.Profile.getConfig(packageJSON.name, 'test.a', 'local'); // undefined await Editor.Profile.getConfig(packageJSON.name, 'test.a', 'global'); // undefined 读取项目配置 const packageJSON = require('./package.json'); // await Editor.Profile.getConfig(pkgName, key, protocol); await Editor.Profile.getProject(packageJSON.name, 'test.a'); // 1 await Editor.Profile.getProject(packageJSON.name, 'test.a', 'project'); // undefined 配置存放的地方 编辑器配置存放的地方 层级 路径 local {projectPath}/profiles/v2/extensions/{extensionName}.json global(mac) Users/{name}/.CocosCreator/profiles/v2/extensions/{extensionName}.json global(window) c/Users/{name}/.CocosCreator/profiles/v2/extensions/{extensionName}.json default {extensionPath}/package.json 项目配置存放的地方 层级 路径 local {projectPath}/settings/v2/extensions/{extensionName}.json default {extensionPath}/package.json "},"editor/extension/ui.html":{"url":"editor/extension/ui.html","title":"UI 组件","keywords":"","body":"UI 组件 为了方便布局，编辑器内提供了许多预设的 UI 组件。 当我们在编写 html 的时候，可以方便地使用这些 UI 组件。 具体的使用方式，请点击编辑器顶部主菜单中的 开发者 -> UI 组件 查看。 "},"advanced-topics/":{"url":"advanced-topics/","title":"进阶主题","keywords":"","body":"进阶主题 如何向 Cocos 提交代码 热更新 热更新范例教程 热更新管理器 动态合图 引擎定制工作流程 网页预览定制工作流程 JSB 2.0 使用指南 JSB 手动绑定 JSB 自动绑定 Java 原生反射机制 Objective-C 原生反射机制 CMake 使用简介 使用 WebSocket 服务器 "},"advanced-topics/hot-update.html":{"url":"advanced-topics/hot-update.html","title":"热更新范例教程","keywords":"","body":"资源热更新教程 前言 之所以这篇文档的标题为教程，是因为目前 Cocos Creator 资源热更新的工作流还没有彻底集成到编辑器中，不过引擎本身对于热更新的支持是完备的，所以借助一些外围脚本和一些额外的工作就可以达成。 本篇文档的范例工程可以从 GitHub | Gitee 获取（master 分支）。 使用场景和设计思路 资源热更新的使用场景相信游戏开发者都非常熟悉，对于已发布的游戏，在游戏内通过从服务器动态下载新的游戏内容，来时刻保持玩家对游戏的新鲜感，是保持一款游戏长盛不衰非常重要的手段。当然热更新还有一些其他的用途，不过在此不再深入讨论，我们下面将主要讨论 Cocos Creator 对热更新支持的原理和手段。 Cocos Creator 中的热更新主要源于 Cocos 引擎中的 AssetsManager 模块对热更新的支持。它有个非常重要的特点： 服务端和本地均保存完整版本的游戏资源，热更新过程中通过比较服务端和本地版本的差异来决定更新哪些内容。这样即可天然支持跨版本更新，比如本地版本为 A，远程版本是 C，则直接更新 A 和 C 之间的差异，并不需要生成 A 到 B 和 B 到 C 的更新包，依次更新。所以，在这种设计思路下，新版本的文件以离散的方式保存在服务端，更新时以文件为单位下载。 除此之外，由于 WEB 版本可以通过服务器直接进行版本更新，所以资源热更新只适用于原生发布版本。AssetsManager 类也只在 jsb 命名空间下，在使用的时候需要注意判断运行环境。 Manifest 文件 对于不同版本的文件级差异，AssetsManager 中使用 Manifest 文件来进行版本比对。本地和远端的 Manifest 文件分别标示了本地和远端的当前版本包含的文件列表和文件版本，这样就可以通过比对每个文件的版本来确定需要更新的文件列表。 Manifest 文件中包含以下几个重要信息： 远程资源包的根路径 远程 Manifest 文件地址 远程 Version 文件地址（非必需） 主版本号 文件列表：以文件路径来索引，包含文件版本信息，一般推荐用文件的 md5 校验码来作为版本号 搜索路径列表 其中 Version 文件内容是 Manifest 文件内容的一部分，不包含文件列表。由于 Manifest 文件可能比较大，每次检查更新的时候都完整下载的话可能影响体验，所以开发者可以额外提供一个非常小的 Version 文件。AssetsManager 会首先检查 Version 文件提供的主版本号来判断是否需要继续下载 Manifest 文件并更新。 在 Cocos Creator 项目中支持热更新 在这篇教程中，将提出一种针对 Cocos Creator 项目可行的热更新方案，我们也在 cocos2d-x 的中开放了 Downloader 的 JavaScript 接口，用户可以自由开发自己的热更新方案。 对于 Cocos Creator 来说，引擎脚本将会打包到 src 目录中，其他 Assets 资源将会被导出到 assets 目录。 基于这样的项目结构，本篇教程中的热更新思路很简单： 基于原生打包目录中的 assets 和 src 目录生成本地 Manifest 文件。 创建一个热更新组件来负责热更新逻辑。 游戏发布后，若需要更新版本，则生成一套远程版本资源，包含 assets 目录、src 目录和 Manifest 文件，将远程版本部署到服务端。 当热更新组件检测到服务端 Manifest 版本不一致时，就会开始热更新 为了展示热更新的过程，教程所使用的范例工程已经在 remote-assets 目录中保存了包含 1.1.0 信息的完整版本，而项目默认构建生成版本为 1.0.0 版本。游戏开始时会检查远程是否有版本更新，如果发现远程版本则提示用户更新，更新完成后，用户重新进入游戏即可看到 1.1.0 版本信息。 注意：项目中包含的 remote-assets 为 debug 模式，开发者在测试的时候必须使用 debug 模式构建项目才有效，否则 release 模式的 jsc 文件优先级会高于 remote-assets 中的资源而导致脚本失效。 使用 Version Generator 来生成 Manifest 文件 在范例工程中，我们提供了一个 version_generator.js（GitHub | Gitee），这是一个用于生成 Manifest 文件的 NodeJS 脚本。使用方式如下： > node version_generator.js -v 1.0.0 -u http://your-server-address/tutorial-hot-update/remote-assets/ -s native/package/ -d assets/ 下面是参数说明： -v 指定 Manifest 文件的主版本号。 -u 指定服务器远程包的地址，这个地址需要和最初发布版本中 Manifest 文件的远程包地址一致，否则无法检测到更新，。 -s 本地原生打包版本的目录相对路径, 比如 ./build/android/assets。 -d 保存 Manifest 文件的相对路径。 热更新组件 在范例工程中，热更新组件的实现位于 assets/hotupdate/HotUpdate.ts（GitHub | Gitee）中，开发者可以参考这种实现，也可以自由的按自己的需求修改。 除此之外，范例工程中还搭配了一个 Scene/Canvas/update 节点用于提示更新和显示更新进度供参考。 部署远程服务器 为了让游戏可以检测到远程版本，可以在本机上模拟一个远程服务器，搭建服务器的方案多种多样（比如 Python SimpleHTTPServer），这里不做讨论，开发者可以使用自己习惯的方式。搭建成功后，访问远程包和 Manifest 文件的地址与范例工程中不同，所以需要修改以下几个地方来让游戏可以成功找到远程包： assets/project.manifest：游戏的本地 Manifest 文件中的 packageUrl、remoteManifestUrl 和 remoteVersionUrl remote-assets/project.manifest：远程包的 Manifest 文件中的 packageUrl、remoteManifestUrl 和 remoteVersionUrl remote-assets/version.manifest：远程包的 Version 文件中的 packageUrl、remoteManifestUrl 和 remoteVersionUrl 打包原生版本 下载完成范例工程后，可以用 Cocos Creator 直接打开这个工程。打开 构建发布 面板，构建原生版本，建议使用 Windows / Mac 来测试。 注意： 构建时请不要勾选 MD5 Cache，否则会导致热更新无效。 并且应该确保在工程目录的 extensions 文件夹里导入 hot-update 编辑器插件（范例工程里已经导入了该插件） 该编辑器插件会在每次构建结束后，自动给 main.js 附加上搜索路径设置的逻辑和更新中断修复代码： // 在 main.js 的开头添加如下代码 (function () { if (typeof window.jsb === 'object') { var hotUpdateSearchPaths = localStorage.getItem('HotUpdateSearchPaths'); if (hotUpdateSearchPaths) { var paths = JSON.parse(hotUpdateSearchPaths); jsb.fileUtils.setSearchPaths(paths); var fileList = []; var storagePath = paths[0] || ''; var tempPath = storagePath + '_temp/'; var baseOffset = tempPath.length; if (jsb.fileUtils.isDirectoryExist(tempPath) && !jsb.fileUtils.isFileExist(tempPath + 'project.manifest.temp')) { jsb.fileUtils.listFilesRecursively(tempPath, fileList); fileList.forEach(srcPath => { var relativePath = srcPath.substr(baseOffset); var dstPath = storagePath + relativePath; if (srcPath[srcPath.length] == '/') { jsb.fileUtils.createDirectory(dstPath) } else { if (jsb.fileUtils.isFileExist(dstPath)) { jsb.fileUtils.removeFile(dstPath) } jsb.fileUtils.renameFile(srcPath, dstPath); } }) jsb.fileUtils.removeDirectory(tempPath); } } } })(); 这一步是必须要做的原因是，热更新的本质是用远程下载的文件取代原始游戏包中的文件。Cocos2d-x 的搜索路径恰好满足这个需求，它可以用来指定远程包的下载地址作为默认的搜索路径，这样游戏运行过程中就会使用下载好的远程版本。另外，这里搜索路径是在上一次更新的过程中使用 localStorage（它符合 WEB 标准的 Local Storage API）固化保存在用户机器上，HotUpdateSearchPaths 这个键值是在 HotUpdate.js 中指定的，保存和读取过程使用的名字必须匹配。 此外，打开工程过程中如果遇到这个警告可以忽略：loader for [.manifest] not exists!。 运行范例工程 如果一切正常，此时运行原生版本的范例工程，就会发现检测到新版本，提示更新，更新之后会自动重启游戏，此时会进入新版本场景。 结语 以上介绍的是目前一种可能的热更新方案，Cocos Creator 在未来版本中提供更成熟的热更新方案，直接集成到编辑器中。当然，也会提供底层 Downloader API 来允许用户自由实现自己的热更新方案，并通过插件机制在编辑器中搭建完整可视化的工作流。这篇教程和范例工程提供给大家参考，也鼓励开发者针对自己的工作流进行定制。如果有问题和交流也欢迎反馈到 论坛。 Next Step 热更新管理器文档 "},"advanced-topics/hot-update-manager.html":{"url":"advanced-topics/hot-update-manager.html","title":"热更新管理器","keywords":"","body":"热更新管理器 AssetsManager 这篇文档将全面覆盖热更新管理器 AssetsManager 的设计思路，技术细节以及使用方式。由于热更新机制的需求对于开发者来说可能各不相同，在维护过程中开发者也提出了各个层面的各种问题，说明开发者需要充分了解热更新机制的细节才能够定制出符合自己需要的工作流。所以这篇文档比较长，也尽力循序渐进得介绍热更新机制，但是并不会介绍过多使用层面的代码，对于想要先了解具体如何使用热更新机制来更新自己游戏的开发者，可以先尝试我们提供的一个 简易教程。 资源热更新简介 资源热更新是为游戏运行时动态更新资源而设计的，这里的资源可以是图片，音频甚至游戏逻辑。在游戏漫长的运营维护过程中，你将可以上传新的资源到你的服务器，让你的游戏跟踪远程服务器上的修改，自动下载新的资源到用户的设备上。就这样，全新的设计，新的游玩体验甚至全新的游戏内容都将立刻被推送到你的用户手上。重要的是，你不需要针对各个渠道去重新打包你的应用并经历痛苦的应用更新审核！ 资源热更新管理器经历过三个重要的阶段： 在 Cocos2d-JS v3.0 中初次设计并实现。 在 Cocos2d-x v3.9 中升级了 Downloader 和多线程并发实现。 在 Cocos Creator v1.4.0 和 Cocos2d-x v3.15 中经过一次重大重构，系统性解决了热更新过程中的 bug。 所以请配合使用最新版本的引擎来使用，这篇文档也是基于最后一次重构来编写的。 设计目标和基本原理 热更新机制本质上是从服务器下载需要的资源到本地，并且可以执行新的游戏逻辑，让新资源可以被游戏所使用。这意味着两个最为核心的目标：下载新资源，覆盖使用新逻辑和资源。同时，由于热更新机制最初在 Cocos2d-JS 中设计，我们考虑了什么样的热更新机制才更适合 Cocos 的 JavaScript 用户群。最终我们决定使用类似 Web 网页的更新模式来更新游戏内容，我们先看一下 Web 的更新模式： Web 页面在服务端保存完整的页面内容 浏览器请求到一个网页之后会在本地缓存它的资源 当浏览器重新请求这个网页的时候会查询服务器版本的最后修改时间（Last-Modified）或者是唯一标识（Etag），如果不同则下载新的文件来更新缓存，否则继续使用缓存 浏览器的缓存机制远比上面描述的要复杂，不过基本思路我们已经有了，那么对于游戏资源来说，也可以在资源服务器上保存一份完整的资源，客户端更新时与服务端进行比对，下载有差异的文件并替换缓存。无差异的部分继续使用包内版本或是缓存文件。这样我们更新游戏需要的就是： 服务端保存最新版本的完整资源（开发者可以随时更新服务器） 客户端发送请求和服务端版本进行比对获得差异列表 从服务端下载所有新版本中有改动的资源文件 用新资源覆盖旧缓存以及应用包内的文件 这就是整个热更新流程的设计思路，当然里面还有非常多具体的细节，后面会结合实际流程进行梳理。这里需要特别指出的是： Cocos 默认的热更新机制并不是基于补丁包更新的机制，传统的热更新经常对多个版本之间分别生成补丁包，按顺序下载补丁包并更新到最新版本。Cocos 的热更新机制通过直接比较最新版本和本地版本的差异来生成差异列表并更新。这样即可天然支持跨版本更新，比如本地版本为 A，远程版本是 C，则直接更新 A 和 C 之间的差异，并不需要生成 A 到 B 和 B 到 C 的更新包，依次更新。所以，在这种设计思路下，新版本的文件以离散的方式保存在服务端，更新时以文件为单位下载。 热更新基本流程 在理解了上面基本的设计思路之后，我们来看一次典型的热更新流程。我们使用 manifest 资源描述文件来描述本地或远程包含的资源列表及资源版本，manifest 文件的定义会在后面详述。运行环境假定为用户安装好 app 后，第一次检查到服务端的版本更新： 上图分为三个部分，中间是热更新的流程，左边是更新过程中 AssetsManager 向用户发送的消息，右边则是各个步骤产出的中间结果，其中粗体字表示中间结果所在的位置，比如内存中、临时文件夹中或者是缓存文件夹。 相信看完这张图还是有很多疑问，下面会从细节上来解析各个步骤中需要注意或者不容易理解的地方。 技术细节解析 Manifest 格式 Manifest 格式是我们用来比较本地和远程资源差异的一种 json 格式，其中保存了主版本信息、引擎版本信息、资源列表及资源信息等： { \"packageUrl\" : 远程资源的本地缓存根路径 \"remoteVersionUrl\" : [可选项] 远程版本文件的路径，用来判断服务器端是否有新版本的资源 \"remoteManifestUrl\" : 远程资源 Manifest 文件的路径，包含版本信息以及所有资源信息 \"version\" : 资源的版本 \"engineVersion\" : 引擎版本 \"assets\" : 所有资源列表 \"key\" : 资源的相对路径（相对于资源根目录） \"md5\" : md5 值代表资源文件的版本信息 \"compressed\" : [可选项] 如果值为 true，文件被下载后会自动被解压，目前仅支持 zip 压缩格式 \"size\" : [可选项] 文件的字节尺寸，用于快速获取进度信息 \"searchPaths\" : 需要添加到 FileUtils 中的搜索路径列表 } Manifest 文件可以通过 Cocos Creator 热更新范例中的 version_generator.js（GitHub | Gitee）来自动生成。 这里需要注意的是，remote 信息（包括 packageUrl、remoteVersionUrl、remoteManifestUrl）是该 manifest 所指向远程包信息，也就是说，当这个 manifest 成为本地包或者缓存 manifest 之后，它们才有意义（偷偷透露个小秘密，更新版本时更改远程包地址也是一种玩法呢）。另外，md5 信息可以不是文件的 md5 码，也可以是某个版本号，这完全是由用户决定的，本地和远程 manifest 对比时，只要 md5 信息不同，我们就认为这个文件有改动。 工程资源和游戏包内资源的区别 大家在创建一个 Cocos Creator 工程的时候，可以看到它的目录下有 assets 目录，里面保存了你的场景、脚本、prefab 等，对应编辑器中的资源管理器面板。但是这些工程资源并不等同于打包后的资源，在使用构建发布面板构建原生版本时，我们会在构建目录下找到 assets 和 src 文件夹，这两个文件夹内保存的才是真正让游戏运行起来的游戏包内资源。其中 src 包含引擎脚本，assets 包含其他资源。 所以我们的资源热更新自然应该更新构建出来的资源，而不是工程的 assets 目录。 包内资源、本地缓存资源和临时资源 在开发者的游戏安装到用户的手机上时，它的游戏是以 .ipa（iOS）或者 .apk（Android）形式存在的，这种应用包在安装后，它的内容是无法被修改或者添加的，应用包内的任何资源都会一直存在。所以热更新机制中，我们只能更新本地缓存到手机的可写目录下（应用存储空间或者 SD 卡指定目录），并通过 FileUtils 的搜索路径机制完成本地缓存对包内资源的覆盖。同时为了保障更新的可靠性，我们在更新过程中会首先将新版本资源放到一个临时文件夹中，只有当本次更新正常完成，才会替换到本地缓存文件夹内。如果中途中断更新或者更新失败，此时的失败版本都不会污染现有的本地缓存。这一步骤在上一章节的流程图中有详细介绍： 在长期多次更新的情况下，本地缓存会一直被替换为最新的版本，而应用包只有等到用户在应用商店中更新到新版本才会被修改。 进度信息 在前面章节的流程图中，可以看到热更新管理器有发送 UPDATE_PROGRESSION 消息给用户。目前版本中，用户可以接收到下面进度信息： 字节级进度（百分比） 文件级进度（百分比） 已接收到的字节数 总字节数 已接收到的文件数 总文件数 function updateCb (event) { switch (event.getEventCode()) { case jsb.EventAssetsManager.UPDATE_PROGRESSION: log(\"Byte progression : \" + event.getPercent() / 100); log(\"File progression : \" + event.getPercentByFile() / 100); log(\"Total files : \" + event.getTotalFiles()); log(\"Downloaded files : \" + event.getDownloadedFiles()); log(\"Total bytes : \" + event.getTotalBytes()); log(\"Downloaded bytes : \" + event.getDownloadedBytes()); break; } } 断点续传 肯定有开发者会问，如果在更新过程中网络中断会怎么样？答案是热更新管理器支持断点续传，并且同时支持文件级别和字节级别的断点续传。 那么具体是怎么做的呢？首先我们使用 Manifest 文件来标识每个资源的状态，比如未开始、下载中、下载成功，在热更新过程中，文件下载完成会被标识到内存的 Manifest 中，当下载完成的文件数量每到一个进度节点（默认以 10% 为一个节点）都会将内存中的 Manifest 序列化并保存到临时文件夹中。具体的步骤展示在流程图多线程并发下载资源部分： 在中断之后，再次启动热更新流程时，会去检查临时文件夹中是否有未完成的更新，校验版本是否和远程匹配后，则直接使用临时文件夹中的 Manifest 作为 Remote Manifest 继续更新。此时，对于下载状态为已完成的，不会重新下载，对于下载中的文件，会尝试发送续传请求给服务器（服务器需要支持 Accept-Ranges，否则从头开始下载）。 控制并发 热更新管理器提供了控制下载并发数量的 API，使用方式如下： assetsManager.setMaxConcurrentTask(10); 版本对比函数 热更新流程中很重要的步骤是比较客户端和服务端的版本，默认情况下只有当服务端主版本比客户端主版本更新时才会去更新。引擎中实现了一个支持 x.x.x.x 四个序列版本的对比函数（x 为纯数字），不符合这种版本号模式的情况下会继续使用字符串比较函数。 除此之外，我们还允许用户使用自己的版本对比函数，使用方法如下： // versionA 和 versionB 都是字符串类型 assetsManager.setVersionCompareHandle(function (versionA, versionB) { var sub = parseFloat(versionA) - parseFloat(versionB); // 当返回值大于 0 时，versionA > versionB // 当返回值等于 0 时，versionA = versionB // 当返回值小于 0 时，versionA 下载后文件校验 由于下载过程中仍然有小概率可能由于网络原因或其他网络库的问题导致下载的文件内容有问题，所以我们提供了用户文件校验接口，在文件下载完成后热更新管理器会调用这个接口（用户实现的情况下），如果返回 true 表示文件正常，返回 false 表示文件有问题。 assetsManager.setVerifyCallback(function (filePath, asset) { var md5 = calculateMD5(filePath); if (md5 === asset.md5) return true; else return false; }); 由于 Manifest 中的资源版本建议使用 md5 码，那么在校验函数中计算下载文件的 md5 码去和 asset 的 md5 码对比即可判断文件是否正常。除了 md5 信息之外，asset 对象还包含下面的属性： 属性 说明 path 服务器端相对路径 compressed 是否被压缩 size 文件尺寸 downloadState 下载状态，包含 UNSTARTED、DOWNLOADING、SUCCESSED、UNMARKED 错误处理和失败重试 在流程图的左侧，大家应该注意到了不少的用户消息，这些用户消息都是可以通过热更新的事件监听器来获得通知的，具体可以参考 范例（GitHub | Gitee）。流程图标识了所有错误信息的触发时机和原因，开发者可以根据自己的系统设计来做出相应的处理。 最重要的就是当下载过程中出现异常，比如下载失败、解压失败、校验失败，最后都会触发 UPDATE_FAILED 事件。而所有下载失败的资源列表会被记录在热更新管理器中，可以通过以下方式下载重试： assetsManager.downloadFailedAssets(); 这个接口调用之后，会重新进入热更新流程，仅下载之前失败的资源。该流程和正常的热更新流程是一致的。 重启的必要性 如果要使用热更新之后的资源，需要重启游戏。有两个原因，第一是更新之后的脚本需要干净的 JS 环境才能正常运行。第二是场景配置，AssetManager 中的配置都需要更新到最新才能够正常加载场景和资源。 JS 脚本的刷新 在热更新之前，游戏中的所有脚本已经执行过了，所有的类、组件、对象已经存在 JS context 中。所以热更新之后如果不重启游戏就直接加载脚本，同名的类和对象虽然会被覆盖，但是之前旧的类创建的对象是一直存在的。而被直接覆盖的全局对象，原先的状态也被重置了，就会导致新版本和旧版本的对象混杂在一起。并且对内存也会造成额外开销。 资源配置的刷新 因为 Creator 的场景和资源都依赖于 Asset Bundle。如果 Asset Bundle 没有被重新加载，并被 Asset Manager 重新读取，那么游戏中是加载不到热更新后的场景和资源的。 而如何启用新的资源，就需要依赖 Cocos 引擎的搜索路径机制了。Cocos 中所有文件的读取都是通过 FileUtils，而 FileUtils 会按照搜索路径的优先级顺序查找文件。所以我们只要将热更新的缓存目录添加到搜索路径中并且前置，就会优先搜索到缓存目录中的资源。以下是示例代码： if (jsb) { // 创建 AssetsManager var assetsManager = new jsb.AssetsManager(manifestUrl, storagePath); // 初始化后的 AssetsManager 的 local manifest 就是缓存目录中的 manifest var hotUpdateSearchPaths = assetsManager.getLocalManifest().getSearchPaths(); // 默认的搜索路径 var searchPaths = jsb.fileUtils.getSearchPaths(); // hotUpdateSearchPaths 会前置在 searchPaths 数组的开头 Array.prototype.unshift.apply(searchPaths, hotUpdateSearchPaths); jsb.fileUtils.setSearchPaths(searchPaths); } 需要注意的是，这段代码必须放在 main.js 中 require 其他脚本之前执行，否则还是会加载到应用包内的脚本。 进阶主题 上面的章节介绍了热更新管理器的大部分实现和使用细节，应该可以解答开发者的大多数疑问。不过在一些特殊的应用场景下，可能需要一些特殊的技巧来避免热更新引发的问题。 迭代升级 对于游戏开发者来说，热更新是比较频繁的需求，从一个大版本升级到另一个大版本的过程中，中间可能会发布多个热更新版本。那么下面两个问题是开发者比较关心的： 在本地缓存覆盖过程中会发生什么问题 当用户环境中已经包含一个本地缓存版本时，热更新管理器会比较缓存版本和应用包内版本，使用较新的版本作为本地版本。如果此时远程版本有更新，热更新管理器在更新过程中，按照正常流程会使用临时文件夹来下载远程版本。当远程版本更新成功后，临时文件夹中的内容会被复制到本地缓存文件夹中。如果本地缓存文件夹中有同名文件则直接覆盖，而其他文件则保留，因为这些文件仍然可能是有效的，只是它们没有在这次版本中被修改。最后删除临时文件夹。 所以理论上小版本的持续热更新不会遇到什么问题。 游戏大版本更新过程中，如何清理本地缓存 在游戏包更新过程中，若要彻底清理本地的热更新缓存有很多种做法，比如可以记录当前的游戏版本号，检查与 sys.localStorage 中保存的版本是否匹配，如果两者不匹配则执行以下清理操作： // 之前保存在 local Storage 中的版本号，如果没有，则认为是新版本 var previousVersion = parseFloat( sys.localStorage.getItem('currentVersion') ); // game.currentVersion 为当前版本的版本号 if (previousVersion 更新引擎 升级游戏使用的引擎版本可能会对热更新产生巨大影响，开发者们可能有注意到在原生项目中存在 src/cocos-js/cc.js 文件，这个文件是 JS 引擎编译出来的。在不同版本的引擎中，它的代码会产生比较大的差异，而 C++ 底层也会随之发生一些改变。这种情况下，如果游戏包内的 C++ 引擎版本和 src/cocos-js/cc.js 的引擎版本不一致，可能会导致严重的问题，甚至游戏完全无法运行。 建议更新引擎之后，尽量推送大版本到应用商店。如果仍采用热更新方案，请一定要仔细完成各个旧版本更新到新版本的测试。 "},"advanced-topics/dynamic-atlas.html":{"url":"advanced-topics/dynamic-atlas.html","title":"动态合图","keywords":"","body":"动态合图 降低 DrawCall 是提升游戏渲染效率一个非常直接有效的办法，而两个 DrawCall 是否可以合并为一个 DrawCall 的其中一个重要因素就是这两个 DrawCall 是否使用了同一张贴图。 Cocos Creator 提供了 动态合图（Dynamic Atlas）的功能，它能在项目运行时动态地将贴图合并到一张大贴图中。当渲染一张贴图的时候，动态合图系统会自动检测这张贴图是否已经被合并到了图集（图片集合）中，如果没有，并且此贴图又符合动态合图的条件，就会将此贴图合并到图集中。 动态合图是按照 渲染顺序 来选取要将哪些贴图合并到一张大图中的，这样就能确保相邻的 DrawCall 能合并为一个 DrawCall（又称“合批”）。 启用、禁用动态合图 Cocos Creator 在初始化过程中，会根据不同的平台设置不同的 CLEANUP_IMAGE_CACHE 参数，当禁用 CLEANUP_IMAGE_CACHE 时，动态合图就会默认开启。 启用动态合图会占用额外的内存，不同平台占用的内存大小不一样。目前在小游戏和原生平台上默认会禁用动态合图，但如果你的项目内存空间仍有富余的话建议开启。 若希望强制开启动态合图，请在代码中加入： macro.CLEANUP_IMAGE_CACHE = false; dynamicAtlasManager.enabled = true; 注意：这些代码请写在项目脚本中的最外层，不要写在 onLoad/start 等类函数中，才能确保在项目加载过程中即时生效。否则如果在部分贴图缓存已经释放的情况下才启用动态图集，可能会导致报错。 若希望强制禁用动态合图，可以直接通过代码控制： dynamicAtlasManager.enabled = false; 贴图限制 动态合图系统限制了能够进行合图的贴图大小，默认只有贴图宽高都小于 512 的贴图才可以进入到动态合图系统。开发者可以根据需求修改这个限制： dynamicAtlasManager.maxFrameSize = 512; 详情可在 API 文档中查找 DynamicAtlasManager 进行参考。 "},"advanced-topics/engine-customization.html":{"url":"advanced-topics/engine-customization.html","title":"引擎定制工作流程","keywords":"","body":"引擎定制工作流程 Cocos Creator 3.0 的引擎部分包括 TypeScript 和 engine-native，全部都在 GitHub 上开源。地址在： TypeScript 引擎：GitHub | Gitee engine-native 引擎：GitHub | Gitee 建议通过 GitHub 的 fork 工作流程来维护自己定制的代码，以便在将来引擎升级时，可以方便地将定制的部分更新上去，具体操作方式请阅读 Fork a repo。如果你愿意帮助 Cocos 越做越好，欢迎在 GitHub 提交你的修改，请参考 如何向 Cocos 提交代码。关于更多 GitHub 相关工作流程请参考 GitHub Help。 另外，根据不同的 Creator 版本，还需要切换不同的引擎分支。通常建议使用和所用 Creator 相同版本的分支。 1 定制 TypeScript 引擎 如果您只需要定制 Web 版游戏的引擎功能，或只需要修改纯 TypeScript 层逻辑（如 UI 系统，动画系统），那么您只要按照下面的流程修改 TypeScript 引擎就可以了。 1.1 获取 TypeScript 引擎 如果只需基于当前的版本做一些调整，那么在 Cocos Creator 3.0 内置的引擎基础上修改就可以了。点击 Creator 编辑器右上方的 编辑器 按钮，然后将内置的 engine 目录拷贝到本地其他路径。 如果想获得官方正在开发中的最新版本，首先需要从 GitHub 上 fork 或者克隆 TypeScript 引擎的原始版本（地址见上文）。TypeScript 引擎在使用前请根据 Creator 版本切换相对应的分支。下载完成后存放到任意本地路径。 1.2 修改 TypeScript 引擎路径 通过 Cocos Creator -> 偏好设置 的 Engine 管理器 选项卡来设置需要定制的 TypeScript 引擎路径。 注意：修改引擎路径后需要重启编辑器。 1.3 安装编译依赖 # 在命令行中进入引擎路径 cd E:/engine # 安装 gulp 构建工具 npm install -g gulp # 安装依赖的模块 npm install # 编译一些数据，包括 debug infos 和 .d.ts gulp build 注意：生成 debug infos 需要 gulp 构建工具。 1.4 进行修改然后编译 接下来可以定制引擎修改了，修改完成之后在 Cocos Creator 编辑器的菜单栏中点击 开发者 -> 编译引擎 进行编译。 该命令会在引擎目录下生成一个 bin 文件夹，并将引擎源码编译到 bin 目录下。 2 定制 engine-native 引擎 如果需要定制和原生平台相关的引擎功能，在修改 TypeScript 引擎的基础上，可能还需要同步修改 engine-native 引擎。 2.1 获取 engine-native 引擎 如果只需要基于当前的版本做一些调整，那么在 Cocos Creator 3.0 内置的 engine-native 引擎基础上修改就可以了。操作步骤和获取 TypeScript 引擎一致，点击 Creator 编辑器右上方的 编辑器 按钮，然后将内置的 cocos2d-x-lite 目录拷贝到本地其他路径。 如果想获得官方正在开发中的最新版本，需要从上文中指定的 GitHub 仓库下载或者克隆。和 TypeScript 引擎类似，engine-native 引擎在使用前也请确认当前所在分支。 2.2 初始化 下载或者克隆好 engine-native 引擎仓库后，在命令行进入引擎路径然后执行以下命令。 注意：如果是从编辑器拷贝出来的内置 cocos2d-x-lite 目录，可以跳过该步骤。 # 在命令行进入 engine-native 引擎路径 cd E:/cocos2d-x-lite # 安装 gulp 构建工具 npm install -g gulp # 安装依赖的模块 npm install # 初始化仓库 gulp init 2.3 在 Cocos Creator 3.0 中配置定制版原生引擎 通过 Cocos Creator -> 偏好设置 的 Engine 管理器 选项卡来设置需要定制的 engine-native 引擎路径。 2.4 修改引擎 接下来可以对 engine-native 引擎进行定制修改了，由于只有在 构建发布 过程中才会编译代码，所以修改引擎后可以直接打开 构建发布 面板，选择 link 模板进行构建和编译。 2.5 定制原生引擎模拟器 为了防止包体过大，Creator 在发布时剔除了原生引擎模拟器相关工程，如果需要使用定制的原生模拟器可以通过以下步骤重新编译生成： 参考 CMake 官方文档 安装 CMake 并配置系统环境变量。 编译原生模拟器引擎，可分为 TypeScript 和 C++ 两部分： 若开发者定制的是 TypeScript 部分，定制完成后，点击编辑器顶部菜单栏中的 开发者 -> 编译原生模拟器引擎 即可。 若开发者定制的是 C++ 部分，定制完成后在 engine-native 目录下依次执行以下命令： # 安装依赖的模块 npm install # 生成原生模拟器相关文件 gulp gen-simulator 执行完成后，会在 engine-native/simulator 路径下生成一个模拟器工程和模拟器可执行文件，便可运行原生模拟器了。 "},"editor/preview/browser.html":{"url":"editor/preview/browser.html","title":"网页预览定制工作流程","keywords":"","body":"网页预览定制工作流程 自定义预览模板 预览支持自定义模板方便用户自定义需要的预览效果，自定义的预览模板可以放置在项目目录的 preview-template 文件夹中。或者点击编辑器主菜单中的 项目 -> 生成预览模板 就可以在项目目录下创建一个最新的预览模板。编辑器中的预览也是使用模板来注入最新的项目数据，预览时将会查找该目录下的 index 文件，如果存在就是要该文件作为预览的模板。 preview-template 文件夹的结构类似： project-folder |--assets |--build |--preview-template // 必须的入口文件 |--index.ejs // 其他文件可根据想要实现的预览效果进行添加 开始自定义网页预览，需要注意的是，预览模板中存在一些预览菜单项以及预览调试工具等内容，所以在增删一些模板语法的内容时要稍加注意，如果随意修改可能会导致预览模板不可用。建议使用 ejs 注入的内容都保留，然后在此基础上添加需要的内容即可。另外，假如 index.html 与 index.ejs 共存时，index.html 将会替代 index.ejs 成为预览的页面内容。 使用示例 以下示例可以在 GitHub | Gitee 查找到。 点击编辑器主菜单中的 项目 -> 生成预览模板，控制台 便会输出“预览模板生成成功”的提示，并显示预览模板的生成路径。 添加需要使用的脚本如 test.js，其中 中包含的是默认的启动游戏逻辑，添加的脚本可以根据需要在游戏逻辑启动前/后来决定存放的位置。下面的 test.js 是在游戏启动后加载。 打开 index.ejs 修改如下： ... ... // 游戏启动处理逻辑 // 新增脚本 test.js 放置在页面内标识的相对路径（只能在 preview-template 文件夹中） |--preview-template |--index.ejs |--test.js "},"advanced-topics/JSB2.0-learning.html":{"url":"advanced-topics/JSB2.0-learning.html","title":"JSB 2.0 使用指南","keywords":"","body":"JSB 2.0 绑定教程 抽象层 架构 宏（Macro） 抽象层必然会比直接使用 JS 引擎 API 的方式多占用一些 CPU 执行时间，如何把抽象层本身的开销降到最低成为设计的第一目标。 JS 绑定的大部分工作其实就是设定 JS 相关操作的 CPP 回调，在回调函数中关联 CPP 对象。其实主要包含如下两种类型： 注册 JS 函数（包含全局函数，类构造函数、类析构函数、类成员函数，类静态成员函数），绑定一个 CPP 回调 注册 JS 对象的属性读写访问器，分别绑定读与写的 CPP 回调 如何做到抽象层开销最小而且暴露统一的 API 供上层使用？ 以注册 JS 函数的回调定义为例，JavaScriptCore、SpiderMonkey、V8、ChakraCore 的定义各不相同，具体如下： JavaScriptCore JSValueRef JSB_foo_func( JSContextRef _cx, JSObjectRef _function, JSObjectRef _thisObject, size_t argc, const JSValueRef _argv[], JSValueRef* _exception ); SpiderMonkey bool JSB_foo_func( JSContext* _cx, unsigned argc, JS::Value* _vp ); V8 void JSB_foo_func( const v8::FunctionCallbackInfo& v8args ); ChakraCore JsValueRef JSB_foo_func( JsValueRef _callee, bool _isConstructCall, JsValueRef* _argv, unsigned short argc, void* _callbackState ); 我们评估了几种方案，最终确定使用 宏 来抹平不同 JS 引擎回调函数定义与参数类型的不同，不管底层是使用什么引擎，开发者统一使用一种回调函数的定义。我们借鉴了 lua 的回调函数定义方式，抽象层所有的 JS 到 CPP 的回调函数的定义为： bool foo(se::State& s) { ... ... } SE_BIND_FUNC(foo) // 此处以回调函数的定义为例 开发者编写完回调函数后，记住使用 SE_BIND_XXX 系列的宏对回调函数进行包装。目前提供了如下几个宏： SE_BIND_PROP_GET：包装一个 JS 对象属性读取的回调函数 SE_BIND_PROP_SET：包装一个 JS 对象属性写入的回调函数 SE_BIND_FUNC：包装一个 JS 函数，可用于全局函数、类成员函数、类静态函数 SE_DECLARE_FUNC：声明一个 JS 函数，一般在 .h 头文件中使用 SE_BIND_CTOR：包装一个 JS 构造函数 SE_BIND_SUB_CLS_CTOR：包装一个 JS 子类的构造函数，此子类可以继承 SE_BIND_FINALIZE_FUNC：包装一个 JS 对象被 GC 回收后的回调函数 SE_DECLARE_FINALIZE_FUNC：声明一个 JS 对象被 GC 回收后的回调函数 _SE：包装回调函数的名称，转义为每个 JS 引擎能够识别的回调函数的定义 注意：第一个字符为下划线，类似 Windows 下用的 _T(\"xxx\") 来包装 Unicode 或者 MultiBytes 字符串。 API CPP 命名空间（namespace） CPP 抽象层所有的类型都在 se 命名空间下，其为 ScriptEngine 的缩写。 类型 se::ScriptEngine se::ScriptEngine 为 JS 引擎的管理员，掌管 JS 引擎初始化、销毁、重启、Native 模块注册、加载脚本、强制垃圾回收、JS 异常清理、是否启用调试器。它是一个单例，可通过 se::ScriptEngine::getInstance() 得到对应的实例。 se::Value se::Value 可以被理解为 JS 变量在 CPP 层的引用。JS 变量有 object、number、string、boolean、null 和 undefined 六种类型。因此 se::Value 使用 union 包含 object、number、string、boolean 4 种 有值类型。无值类型 包含 null 和 undefined，可由 _type 直接表示。 namespace se { class Value { enum class Type : char { Undefined = 0, Null, Number, Boolean, String, Object }; ... ... private: union { bool _boolean; double _number; std::string* _string; Object* _object; } _u; Type _type; ... ... }; } 如果 se::Value 中保存基础数据类型，比如 number，string，boolean，其内部是直接存储一份值副本。 object 的存储比较特殊，是通过 se::Object* 对 JS 对象的弱引用 (weak reference)。 se::Object se::Object 继承于 se::RefCounter 引用计数管理类。目前抽象层中只有 se::Object 继承于 se::RefCounter。 上一小节我们说到，se::Object 是保存了对 JS 对象的弱引用，这里有必要解释一下为什么是弱引用。 原因一：JS 对象控制 CPP 对象的生命周期的需要 当在脚本层中通过 var xhr = new XMLHttpRequest(); 创建了一个 XMLHttpRequest 后，在构造回调函数绑定中我们会创建一个 se::Object 并保留在一个全局的 map (NativePtrToObjectMap) 中，此 map 用于查询 XMLHttpRequest* 指针获取对应的 JS 对象 se::Object*。 static bool XMLHttpRequest_finalize(se::State& s) { CCLOG(\"jsbindings: finalizing JS object %p (XMLHttpRequest)\", s.nativeThisObject()); XMLHttpRequest* cobj = (XMLHttpRequest*)s.nativeThisObject(); if (cobj->getReferenceCount() == 1) cobj->autorelease(); else cobj->release(); return true; } SE_BIND_FINALIZE_FUNC(XMLHttpRequest_finalize) static bool XMLHttpRequest_constructor(se::State& s) { XMLHttpRequest* cobj = JSB_ALLOC(XMLHttpRequest); s.thisObject()->setPrivateData(cobj); return true; } SE_BIND_CTOR(XMLHttpRequest_constructor, __jsb_XMLHttpRequest_class, XMLHttpRequest_finalize) 设想如果强制要求 se::Object 为 JS 对象的强引用(strong reference)，即让 JS 对象不受 GC 控制，由于 se::Object 一直存在于 map 中，finalize 回调将永远无法被触发，从而导致内存泄露。 正是由于 se::Object 保存的是 JS 对象的弱引用，JS 对象控制 CPP 对象的生命周期才能够实现。以上代码中，当 JS 对象被释放后，会触发 finalize 回调，开发者只需要在 XMLHttpRequest_finalize 中释放对应的 c++ 对象即可，se::Object 的释放已经被包含在 SE_BIND_FINALIZE_FUNC 宏中自动处理，开发者无需管理在 JS 对象控制 CPP 对象 模式中 se::Object 的释放，但是在 CPP 对象控制 JS 对象 模式中，开发者需要管理对 se::Object 的释放，具体下一节中会举例说明。 原因二：更加灵活，手动调用 root 方法以支持强引用 se::Object 中提供了 root/unroot 方法供开发者调用，root 会把 JS 对象放入到不受 GC 扫描到的区域，调用 root 后，se::Object 就强引用了 JS 对象，只有当 unroot 被调用，或者 se::Object 被释放后，JS 对象才会放回到受 GC 扫描到的区域。 一般情况下，如果对象是非 cc::Ref 的子类，会采用 CPP 对象控制 JS 对象的生命周期的方式去绑定。引擎内 Spine, DragonBones, Box2d 等第三方库的绑定就是采用此方式。当 CPP 对象被释放的时候，需要在 NativePtrToObjectMap 中查找对应的 se::Object，然后手动 unroot 和 decRef。以 Spine 中 spTrackEntry 的绑定为例： spTrackEntry_setDisposeCallback([](spTrackEntry* entry) { // spTrackEntry 的销毁回调 se::Object* seObj = nullptr; auto iter = se::NativePtrToObjectMap::find(entry); if (iter != se::NativePtrToObjectMap::end()) { // 保存 se::Object 指针，用于在下面的 cleanup 函数中释放其内存 seObj = iter->second; // Native 对象 entry 的内存已经被释放，因此需要立马解除 Native 对象与 JS 对象的关联。 // 如果解除引用关系放在下面的 cleanup 函数中处理，有可能触发 se::Object::setPrivateData 中 // 的断言，因为新生成的 Native 对象的地址可能与当前对象相同，而 cleanup 可能被延迟到帧结束前执行。 se::NativePtrToObjectMap::erase(iter); } else { return; } auto cleanup = [seObj]() { auto se = se::ScriptEngine::getInstance(); if (!se->isValid() || se->isInCleanup()) return; se::AutoHandleScope hs; se->clearException(); // 由于上面逻辑已经把映射关系解除了，这里传入 false 表示不用再次解除映射关系, // 因为当前 seObj 的 private data 可能已经是另外一个不同的对象 seObj->clearPrivateData(false); seObj->unroot(); // unroot，使 JS 对象受 GC 管理 seObj->decRef(); // 释放 se::Object }; // 确保不再垃圾回收中去操作 JS 引擎的 API if (!se::ScriptEngine::getInstance()->isGarbageCollecting()) { cleanup(); } else { // 如果在垃圾回收，把清理任务放在帧结束中进行 CleanupTask::pushTaskToAutoReleasePool(cleanup); } }); 对象类型 绑定对象的创建已经被隐藏在对应的 SE_BIND_CTOR 和 SE_BIND_SUB_CLS_CTOR 函数中，开发者在绑定回调中如果需要用到当前对象对应的 se::Object，只需要通过 s.thisObject() 即可获取。其中 s 为 se::State 类型，具体会在后续章节中说明。 此外，se::Object 目前支持以下几种对象的手动创建： Plain Object：通过 se::Object::createPlainObject 创建，类似 JS 中的 var a = {}; Array Object：通过 se::Object::createArrayObject 创建，类似 JS 中的 var a = []; Uint8 Typed Array Object：通过 se::Object::createTypedArray 创建，类似 JS 中的 var a = new Uint8Array(buffer); Array Buffer Object：通过 se::Object::createArrayBufferObject，类似 JS 中的 var a = new ArrayBuffer(len); 手动创建对象的释放 se::Object::createXXX 方法与 Cocos Creator 中的 create 方法不同，抽象层是完全独立的一个模块，并不依赖与 Cocos Creator 的 autorelease 机制。虽然 se::Object 也是继承引用计数类，但开发者需要处理 手动创建出来的对象 的释放。 se::Object* obj = se::Object::createPlainObject(); ... ... obj->decRef(); // 释放引用，避免内存泄露 se::HandleObject（推荐的管理手动创建对象的辅助类） 在比较复杂的逻辑中使用手动创建对象，开发者往往会忘记在不同的逻辑中处理 decRef bool foo() { se::Object* obj = se::Object::createPlainObject(); if (var1) return false; // 这里直接返回了，忘记做 decRef 释放操作 if (var2) return false; // 这里直接返回了，忘记做 decRef 释放操作 ... ... obj->decRef(); return true; } 就算在不同的返回条件分支中加上了 decRef 也会导致逻辑复杂，难以维护，如果后期加入另外一个返回分支，很容易忘记 decRef。 JS 引擎在 se::Object::createXXX 后，如果由于某种原因 JS 引擎做了 GC 操作，导致后续使用的 se::Object 内部引用了一个非法指针，引发程序崩溃 为了解决上述两个问题，抽象层定义了一个辅助管理 手动创建对象 的类型，即 se::HandleObject。 se::HandleObject 是一个辅助类，用于更加简单地管理手动创建的 se::Object 对象的释放、root 和 unroot 操作。 以下两种代码写法是等价的，使用 se::HandleObject 的代码量明显少很多，而且更加安全。 { se::HandleObject obj(se::Object::createPlainObject()); obj->setProperty(...); otherObject->setProperty(\"foo\", se::Value(obj)); } 等价于： { se::Object* obj = se::Object::createPlainObject(); obj->root(); // 在手动创建完对象后立马 root，防止对象被 GC obj->setProperty(...); otherObject->setProperty(\"foo\", se::Value(obj)); obj->unroot(); // 当对象被使用完后，调用 unroot obj->decRef(); // 引用计数减一，避免内存泄露 } 注意： 不要尝试使用 se::HandleObject 创建一个 native 与 JS 的绑定对象，在 JS 控制 CPP 的模式中，绑定对象的释放会被抽象层自动处理，在 CPP 控制 JS 的模式中，前一章节中已经有描述了。 se::HandleObject 对象只能够在栈上被分配，而且栈上构造的时候必须传入一个 se::Object 指针。 se::Class se::Class 用于暴露 CPP 类到 JS 中，它会在 JS 中创建一个对应名称的 constructor function。 它有如下方法： static se::Class* create(className, obj, parentProto, ctor)：创建一个 Class，注册成功后，在 JS 层中可以通过var xxx = new SomeClass();的方式创建一个对象 bool defineFunction(name, func)：定义 Class 中的成员函数 bool defineProperty(name, getter, setter)：定义 Class 属性读写器 bool defineStaticFunction(name, func)：定义 Class 的静态成员函数，可通过 SomeClass.foo() 这种非 new 的方式访问，与类实例对象无关 bool defineStaticProperty(name, getter, setter)：定义 Class 的静态属性读写器，可通过 SomeClass.propertyA 直接读写，与类实例对象无关 bool defineFinalizeFunction(func)：定义 JS 对象被 GC 后的 CPP 回调 bool install()：注册此类到 JS 虚拟机中 Object* getProto()：获取注册到 JS 中的类（其实是 JS 的 constructor）的 prototype 对象，类似 function Foo(){} 的 Foo.prototype const char* getName() const：获取当前 Class 的名称 注意：Class 类型创建后，不需要手动释放内存，它会被封装层自动处理。 更具体 API 说明可以翻看 API 文档或者代码注释。 se::AutoHandleScope se::AutoHandleScope 对象类型完全是为了解决 V8 的兼容问题而引入的概念。V8 中，当有 CPP 函数中需要触发 JS 相关操作，比如调用 JS 函数，访问 JS 属性等任何调用 v8::Local<> 的操作，V8 强制要求在调用这些操作前必须存在一个 v8::HandleScope 作用域，否则会引发程序崩溃。 因此抽象层中引入了 se::AutoHandleScope 的概念，其只在 V8 上有实现，其他 JS 引擎目前都只是空实现。 开发者需要记住，在任何代码执行中，需要调用 JS 的逻辑前，声明一个 se::AutoHandleScope 即可，比如： class SomeClass { void update(float dt) { se::ScriptEngine::getInstance()->clearException(); se::AutoHandleScope hs; se::Object* obj = ...; obj->setProperty(...); ... ... obj->call(...); } }; se::State 之前章节我们有提及 State 类型，它是绑定回调中的一个环境，我们通过 se::State 可以取得当前的 CPP 指针、se::Object 对象指针、参数列表、返回值引用。 bool foo(se::State& s) { // 获取 native 对象指针 SomeClass* cobj = (SomeClass*)s.nativeThisObject(); // 获取 se::Object 对象指针 se::Object* thisObject = s.thisObject(); // 获取参数列表 const se::ValueArray& args = s.args(); // 设置返回值 s.rval().setInt32(100); return true; } SE_BIND_FUNC(foo) 抽象层依赖 Cocos Creator 引擎么？ 不依赖。 ScriptEngine 这层设计之初就将其定义为一个独立模块，完全不依赖 Cocos Creator 引擎。开发者可以通过 copy、paste 把 cocos/bindings/jswrapper 下的所有抽象层源码拷贝到其他项目中直接使用。 手动绑定 回调函数声明 static bool Foo_balabala(se::State& s) { const auto& args = s.args(); int argc = (int)args.size(); if (argc >= 2) // 这里约定参数个数必须大于等于 2，否则抛出错误到 JS 层且返回 false { ... ... return true; } SE_REPORT_ERROR(\"wrong number of arguments: %d, was expecting %d\", argc, 2); return false; } // 如果是绑定函数，则用 SE_BIND_FUNC，构造函数、析构函数、子类构造函数等类似 SE_BIND_FUNC(Foo_balabala) 为 JS 对象设置一个属性值 se::Object* globalObj = se::ScriptEngine::getInstance()->getGlobalObject(); // 这里为了演示方便，获取全局对象 globalObj->setProperty(\"foo\", se::Value(100)); // 给全局对象设置一个 foo 属性，值为 100 在 JS 中就可以直接使用 foo 这个全局变量了 log(\"foo value: \" + foo); // 打印出 foo value: 100 为 JS 对象定义一个属性读写回调 // 全局对象的 foo 属性的读回调 static bool Global_get_foo(se::State& s) { NativeObj* cobj = (NativeObj*)s.nativeThisObject(); int32_t ret = cobj->getValue(); s.rval().setInt32(ret); return true; } SE_BIND_PROP_GET(Global_get_foo) // 全局对象的 foo 属性的写回调 static bool Global_set_foo(se::State& s) { const auto& args = s.args(); int argc = (int)args.size(); if (argc >= 1) { NativeObj* cobj = (NativeObj*)s.nativeThisObject(); int32_t arg1 = args[0].toInt32(); cobj->setValue(arg1); // void 类型的函数，无需设置 s.rval，未设置默认返回 undefined 给 JS 层 return true; } SE_REPORT_ERROR(\"wrong number of arguments: %d, was expecting %d\", argc, 1); return false; } SE_BIND_PROP_SET(Global_set_foo) void some_func() { se::Object* globalObj = se::ScriptEngine::getInstance()->getGlobalObject(); // 这里为了演示方便，获取全局对象 globalObj->defineProperty(\"foo\", _SE(Global_get_foo), _SE(Global_set_foo)); // 使用_SE 宏包装一下具体的函数名称 } 为 JS 对象设置一个函数 static bool Foo_function(se::State& s) { ... ... } SE_BIND_FUNC(Foo_function) void some_func() { se::Object* globalObj = se::ScriptEngine::getInstance()->getGlobalObject(); // 这里为了演示方便，获取全局对象 globalObj->defineFunction(\"foo\", _SE(Foo_function)); // 使用_SE 宏包装一下具体的函数名称 } 注册一个 CPP 类到 JS 虚拟机中 static se::Object* __jsb_ns_SomeClass_proto = nullptr; static se::Class* __jsb_ns_SomeClass_class = nullptr; namespace ns { class SomeClass { public: SomeClass() : xxx(0) {} void foo() { printf(\"SomeClass::foo\\n\"); Director::getInstance()->getScheduler()->schedule([this](float dt){ static int counter = 0; ++counter; if (_cb != nullptr) _cb(counter); }, this, 1.0f, CC_REPEAT_FOREVER, 0.0f, false, \"iamkey\"); } static void static_func() { printf(\"SomeClass::static_func\\n\"); } void setCallback(const std::function& cb) { _cb = cb; if (_cb != nullptr) { printf(\"setCallback(cb)\\n\"); } else { printf(\"setCallback(nullptr)\\n\"); } } int xxx; private: std::function _cb; }; } // namespace ns { static bool js_SomeClass_finalize(se::State& s) { ns::SomeClass* cobj = (ns::SomeClass*)s.nativeThisObject(); delete cobj; return true; } SE_BIND_FINALIZE_FUNC(js_SomeClass_finalize) static bool js_SomeClass_constructor(se::State& s) { ns::SomeClass* cobj = new ns::SomeClass(); s.thisObject()->setPrivateData(cobj); return true; } SE_BIND_CTOR(js_SomeClass_constructor, __jsb_ns_SomeClass_class, js_SomeClass_finalize) static bool js_SomeClass_foo(se::State& s) { ns::SomeClass* cobj = (ns::SomeClass*)s.nativeThisObject(); cobj->foo(); return true; } SE_BIND_FUNC(js_SomeClass_foo) static bool js_SomeClass_get_xxx(se::State& s) { ns::SomeClass* cobj = (ns::SomeClass*)s.nativeThisObject(); s.rval().setInt32(cobj->xxx); return true; } SE_BIND_PROP_GET(js_SomeClass_get_xxx) static bool js_SomeClass_set_xxx(se::State& s) { const auto& args = s.args(); int argc = (int)args.size(); if (argc > 0) { ns::SomeClass* cobj = (ns::SomeClass*)s.nativeThisObject(); cobj->xxx = args[0].toInt32(); return true; } SE_REPORT_ERROR(\"wrong number of arguments: %d, was expecting %d\", argc, 1); return false; } SE_BIND_PROP_SET(js_SomeClass_set_xxx) static bool js_SomeClass_static_func(se::State& s) { ns::SomeClass::static_func(); return true; } SE_BIND_FUNC(js_SomeClass_static_func) bool js_register_ns_SomeClass(se::Object* global) { // 保证 namespace 对象存在 se::Value nsVal; if (!global->getProperty(\"ns\", &nsVal)) { // 不存在则创建一个 JS 对象，相当于 var ns = {}; se::HandleObject jsobj(se::Object::createPlainObject()); nsVal.setObject(jsobj); // 将 ns 对象挂载到 global 对象中，名称为 ns global->setProperty(\"ns\", nsVal); } se::Object* ns = nsVal.toObject(); // 创建一个 Class 对象，开发者无需考虑 Class 对象的释放，其交由 ScriptEngine 内部自动处理 auto cls = se::Class::create(\"SomeClass\", ns, nullptr, _SE(js_SomeClass_constructor)); // 如果无构造函数，最后一个参数可传入 nullptr，则这个类在 JS 中无法被 new SomeClass() 出来 // 为这个 Class 对象定义成员函数、属性、静态函数、析构函数 cls->defineFunction(\"foo\", _SE(js_SomeClass_foo)); cls->defineProperty(\"xxx\", _SE(js_SomeClass_get_xxx), _SE(js_SomeClass_set_xxx)); cls->defineFinalizeFunction(_SE(js_SomeClass_finalize)); // 注册类型到 JS VirtualMachine 的操作 cls->install(); // JSBClassType 为 Cocos Creator 引擎绑定层封装的类型注册的辅助函数，此函数不属于 ScriptEngine 这层 JSBClassType::registerClass(cls); // 保存注册的结果，便于其他地方使用，比如类继承 __jsb_ns_SomeClass_proto = cls->getProto(); __jsb_ns_SomeClass_class = cls; // 为每个此 Class 实例化出来的对象附加一个属性 __jsb_ns_SomeClass_proto->setProperty(\"yyy\", se::Value(\"helloyyy\")); // 注册静态成员变量和静态成员函数 se::Value ctorVal; if (ns->getProperty(\"SomeClass\", &ctorVal) && ctorVal.isObject()) { ctorVal.toObject()->setProperty(\"static_val\", se::Value(200)); ctorVal.toObject()->defineFunction(\"static_func\", _SE(js_SomeClass_static_func)); } // 清空异常 se::ScriptEngine::getInstance()->clearException(); return true; } 如何绑定 CPP 接口中的回调函数？ static bool js_SomeClass_setCallback(se::State& s) { const auto& args = s.args(); int argc = (int)args.size(); if (argc >= 1) { ns::SomeClass* cobj = (ns::SomeClass*)s.nativeThisObject(); se::Value jsFunc = args[0]; se::Value jsTarget = argc > 1 ? args[1] : se::Value::Undefined; if (jsFunc.isNullOrUndefined()) { cobj->setCallback(nullptr); } else { assert(jsFunc.isObject() && jsFunc.toObject()->isFunction()); // 如果当前 SomeClass 是可以被 new 出来的类，我们 使用 se::Object::attachObject 把 jsFunc 和 jsTarget 关联到当前对象中 s.thisObject()->attachObject(jsFunc.toObject()); s.thisObject()->attachObject(jsTarget.toObject()); // 如果当前 SomeClass 类是一个单例类，或者永远只有一个实例的类，我们不能用 se::Object::attachObject 去关联 // 必须使用 se::Object::root，开发者无需关系 unroot，unroot 的操作会随着 lambda 的销毁触发 jsFunc 的析构，在 se::Object 的析构函数中进行 unroot 操作。 // js_audio_AudioEngine_setFinishCallback 的绑定代码就是使用此方式，因为 AudioEngine 始终只有一个实例， // 如果使用 s.thisObject->attachObject(jsFunc.toObject);会导致对应的 func 和 target 永远无法被释放，引发内存泄露。 // jsFunc.toObject()->root(); // jsTarget.toObject()->root(); cobj->setCallback([jsFunc, jsTarget](int counter){ // CPP 回调函数中要传递数据给 JS 或者调用 JS 函数，在回调函数开始需要添加如下两行代码。 se::ScriptEngine::getInstance()->clearException(); se::AutoHandleScope hs; se::ValueArray args; args.push_back(se::Value(counter)); se::Object* target = jsTarget.isObject() ? jsTarget.toObject() : nullptr; jsFunc.toObject()->call(args, target); }); } return true; } SE_REPORT_ERROR(\"wrong number of arguments: %d, was expecting %d\", argc, 1); return false; } SE_BIND_FUNC(js_SomeClass_setCallback) SomeClass 类注册后，就可以在 JS 中这样使用了： var myObj = new ns.SomeClass(); myObj.foo(); ns.SomeClass.static_func(); log(\"ns.SomeClass.static_val: \" + ns.SomeClass.static_val); log(\"Old myObj.xxx:\" + myObj.xxx); myObj.xxx = 1234; log(\"New myObj.xxx:\" + myObj.xxx); log(\"myObj.yyy: \" + myObj.yyy); var delegateObj = { onCallback: function(counter) { log(\"Delegate obj, onCallback: \" + counter + \", this.myVar: \" + this.myVar); this.setVar(); }, setVar: function() { this.myVar++; }, myVar: 100 }; myObj.setCallback(delegateObj.onCallback, delegateObj); setTimeout(function(){ myObj.setCallback(null); }, 6000); // 6 秒后清空 callback Console 中会输出： SomeClass::foo SomeClass::static_func ns.SomeClass.static_val: 200 Old myObj.xxx:0 New myObj.xxx:1234 myObj.yyy: helloyyy setCallback(cb) Delegate obj, onCallback: 1, this.myVar: 100 Delegate obj, onCallback: 2, this.myVar: 101 Delegate obj, onCallback: 3, this.myVar: 102 Delegate obj, onCallback: 4, this.myVar: 103 Delegate obj, onCallback: 5, this.myVar: 104 Delegate obj, onCallback: 6, this.myVar: 105 setCallback(nullptr) 如何使用 Cocos Creator bindings 这层的类型转换辅助函数？ 类型转换辅助函数位于 cocos/bindings/manual/jsb_conversions.h/.cpp 中，其包含以下内容。 se::Value 转换为 C++ 类型 bool seval_to_int32(const se::Value &v, int32_t *ret); bool seval_to_uint32(const se::Value &v, uint32_t *ret); bool seval_to_int8(const se::Value &v, int8_t *ret); bool seval_to_uint8(const se::Value &v, uint8_t *ret); bool seval_to_int16(const se::Value &v, int16_t *ret); bool seval_to_uint16(const se::Value &v, uint16_t *ret); bool seval_to_boolean(const se::Value &v, bool *ret); bool seval_to_float(const se::Value &v, float *ret); bool seval_to_double(const se::Value &v, double *ret); bool seval_to_size(const se::Value &v, size_t *ret); bool seval_to_std_string(const se::Value &v, std::string *ret); bool seval_to_Vec2(const se::Value &v, cc::Vec2 *pt); bool seval_to_Vec3(const se::Value &v, cc::Vec3 *pt); bool seval_to_Vec4(const se::Value &v, cc::Vec4 *pt); bool seval_to_Mat4(const se::Value &v, cc::Mat4 *mat); bool seval_to_Size(const se::Value &v, cc::Size *size); bool seval_to_ccvalue(const se::Value &v, cc::Value *ret); bool seval_to_ccvaluemap(const se::Value &v, cc::ValueMap *ret); bool seval_to_ccvaluemapintkey(const se::Value &v, cc::ValueMapIntKey *ret); bool seval_to_ccvaluevector(const se::Value &v, cc::ValueVector *ret); bool sevals_variadic_to_ccvaluevector(const se::ValueArray &args, cc::ValueVector *ret); bool seval_to_std_vector_string(const se::Value &v, std::vector *ret); bool seval_to_std_vector_int(const se::Value &v, std::vector *ret); bool seval_to_std_vector_uint16(const se::Value &v, std::vector *ret); bool seval_to_std_vector_float(const se::Value &v, std::vector *ret); bool seval_to_std_vector_Vec2(const se::Value &v, std::vector *ret); bool seval_to_Uint8Array(const se::Value &v, uint8_t *ret); bool seval_to_uintptr_t(const se::Value &v, uintptr_t *ret); bool seval_to_std_map_string_string(const se::Value &v, std::map *ret); bool seval_to_Data(const se::Value &v, cc::Data *ret); bool seval_to_DownloaderHints(const se::Value &v, cc::network::DownloaderHints *ret); template bool seval_to_native_ptr(const se::Value& v, T* ret); template typename std::enable_if::value && !std::is_same::value, T>::type seval_to_type(const se::Value &v, bool &ok); template typename std::enable_if::value, T>::type seval_to_type(const se::Value &v, bool &ok); template typename std::enable_if::value, T>::type seval_to_type(const se::Value &v, bool &ok); template typename std::enable_if::value, T>::type seval_to_type(const se::Value &v, bool &ok); template typename std::enable_if::value, T>::type seval_to_type(const se::Value &v, bool &ok); template typename std::enable_if::value && std::is_class::type>::value, bool>::type seval_to_std_vector(const se::Value &v, std::vector *ret); template typename std::enable_if::value, bool>::type seval_to_std_vector(const se::Value &v, std::vector *ret); template bool seval_to_Map_string_key(const se::Value& v, cc::Map* ret) C++ 类型转换为 se::Value bool int8_to_seval(int8_t v, se::Value *ret); bool uint8_to_seval(uint8_t v, se::Value *ret); bool int32_to_seval(int32_t v, se::Value *ret); bool uint32_to_seval(uint32_t v, se::Value *ret); bool int16_to_seval(uint16_t v, se::Value *ret); bool uint16_to_seval(uint16_t v, se::Value *ret); bool boolean_to_seval(bool v, se::Value *ret); bool float_to_seval(float v, se::Value *ret); bool double_to_seval(double v, se::Value *ret); bool long_to_seval(long v, se::Value *ret); bool ulong_to_seval(unsigned long v, se::Value *ret); bool longlong_to_seval(long long v, se::Value *ret); bool uintptr_t_to_seval(uintptr_t v, se::Value *ret); bool size_to_seval(size_t v, se::Value *ret); bool std_string_to_seval(const std::string &v, se::Value *ret); bool Vec2_to_seval(const cc::Vec2 &v, se::Value *ret); bool Vec3_to_seval(const cc::Vec3 &v, se::Value *ret); bool Vec4_to_seval(const cc::Vec4 &v, se::Value *ret); bool Mat4_to_seval(const cc::Mat4 &v, se::Value *ret); bool Size_to_seval(const cc::Size &v, se::Value *ret); bool Rect_to_seval(const cc::Rect &v, se::Value *ret); bool ccvalue_to_seval(const cc::Value &v, se::Value *ret); bool ccvaluemap_to_seval(const cc::ValueMap &v, se::Value *ret); bool ccvaluemapintkey_to_seval(const cc::ValueMapIntKey &v, se::Value *ret); bool ccvaluevector_to_seval(const cc::ValueVector &v, se::Value *ret); bool std_vector_string_to_seval(const std::vector &v, se::Value *ret); bool std_vector_int_to_seval(const std::vector &v, se::Value *ret); bool std_vector_uint16_to_seval(const std::vector &v, se::Value *ret); bool std_vector_float_to_seval(const std::vector &v, se::Value *ret); bool std_map_string_string_to_seval(const std::map &v, se::Value *ret); bool ManifestAsset_to_seval(const cc::extension::ManifestAsset &v, se::Value *ret); bool Data_to_seval(const cc::Data &v, se::Value *ret); bool DownloadTask_to_seval(const cc::network::DownloadTask &v, se::Value *ret); template typename std::enable_if::value, bool>::type native_ptr_to_seval(T *v_c, se::Value *ret, bool *isReturnCachedValue = nullptr); template typename std::enable_if::value && !std::is_pointer::value, bool>::type native_ptr_to_seval(T &v_ref, se::Value *ret, bool *isReturnCachedValue = nullptr); template bool native_ptr_to_rooted_seval( typename std::enable_if::value, T>::type *v, se::Value *ret, bool *isReturnCachedValue = nullptr); template typename std::enable_if::value, bool>::type native_ptr_to_seval(T *vp, se::Class *cls, se::Value *ret, bool *isReturnCachedValue = nullptr); template typename std::enable_if::value, bool>::type native_ptr_to_seval(T &v_ref, se::Class *cls, se::Value *ret, bool *isReturnCachedValue = nullptr); template bool native_ptr_to_rooted_seval( typename std::enable_if::value, T>::type *v, se::Class *cls, se::Value *ret, bool *isReturnCachedValue = nullptr); template typename std::enable_if::value, bool>::type native_ptr_to_seval(T *vp, se::Value *ret, bool *isReturnCachedValue = nullptr); template typename std::enable_if::value, bool>::type native_ptr_to_seval(T *vp, se::Class *cls, se::Value *ret, bool *isReturnCachedValue = nullptr); template bool std_vector_to_seval(const std::vector &v, se::Value *ret); template bool seval_to_reference(const se::Value &v, T **ret); 辅助转换函数不属于 Script Engine Wrapper 抽象层，属于 Cocos Creator 绑定层，封装这些函数是为了在绑定代码中更加方便的转换。每个转换函数都返回 bool 类型，表示转换是否成功，开发者如果调用这些接口，需要去判断这个返回值。 以上接口，直接根据接口名称即可知道具体的用法，接口中第一个参数为输入，第二个参数为输出参数。用法如下： se::Value v; bool ok = int32_to_seval(100, &v); // 第二个参数为输出参数，传入输出参数的地址 int32_t v; bool ok = seval_to_int32(args[0], &v); // 第二个参数为输出参数，传入输出参数的地址 (IMPORTANT)理解 native_ptr_to_seval 与 native_ptr_to_rooted_seval 的区别 开发者一定要理解清楚这二者的区别，才不会因为误用导致 JS 层内存泄露这种比较难查的 bug。 native_ptr_to_seval 用于 JS 控制 CPP 对象生命周期 的模式。当在绑定层需要根据一个 CPP 对象指针获取一个 se::Value 的时候，可调用此方法。引擎内大部分继承于 cc::Ref 的子类都采取这种方式去获取 se::Value。记住一点，当你管理的绑定对象是由 JS 控制生命周期，需要转换为 seval 的时候，请用此方法，否则考虑用 native_ptr_to_rooted_seval。 native_ptr_to_rooted_seval 用于 CPP 控制 JS 对象生命周期 的模式。一般而言，第三方库中的对象绑定都会用到此方法。此方法会根据传入的 CPP 对象指针查找 cache 的 se::Object，如果不存在，则创建一个 rooted 的 se::Object，即这个创建出来的 JS 对象将不受 GC 控制，并永远在内存中。开发者需要监听 CPP 对象的释放，并在释放的时候去做 se::Object 的 unroot 操作，具体可参照前面章节中描述的 spTrackEntry_setDisposeCallback 中的内容。 更多关于手动绑定的内容可参考 使用 JSB 手动绑定。 自动绑定 配置模块 ini 文件 配置方法与 1.6 中的方法相同，主要注意的是：1.7 中废弃了 script_control_cpp，因为 script_control_cpp 字段会影响到整个模块，如果模块中需要绑定 cc::Ref 子类和非 cc::Ref 子类，原来的绑定配置则无法满足需求。1.7 中取而代之的新字段为 classes_owned_by_cpp，表示哪些类是需要由 CPP 来控制 JS 对象的生命周期。 1.7 中另外加入的一个配置字段为 persistent_classes，用于表示哪些类是在游戏运行中一直存在的，比如：FileUtils。 其他字段与 1.6 一致。 具体可以参考引擎目录下的 tools/tojs/cocos.ini 等 ini 配置。 理解 ini 文件中每个字段的意义 # 模块名称 [cocos] # 绑定回调函数的前缀，也是生成的自动绑定文件的前缀 prefix = engine # 绑定的类挂载在 JS 中的哪个对象中，类似命名空间 target_namespace = jsb # 自动绑定工具基于 Android 编译环境，此处配置 Android 头文件搜索路径 android_headers = # 配置 Android 编译参数 android_flags = -target armv7-none-linux-androideabi -D_LIBCPP_DISABLE_VISIBILITY_ANNOTATIONS -DANDROID -D__ANDROID_API__=14 -gcc-toolchain %(gcc_toolchain_dir)s --sysroot=%(androidndkdir)s/platforms/android-14/arch-arm -idirafter %(androidndkdir)s/sources/android/support/include -idirafter %(androidndkdir)s/sysroot/usr/include -idirafter %(androidndkdir)s/sysroot/usr/include/arm-linux-androideabi -idirafter %(clangllvmdir)s/lib64/clang/5.0/include -I%(androidndkdir)s/sources/cxx-stl/llvm-libc++/include # 配置 clang 头文件搜索路径 clang_headers = # 配置 clang 编译参数 clang_flags = -nostdinc -x c++ -std=c++17 -fsigned-char -mfloat-abi=soft -U__SSE__ # 配置引擎的头文件搜索路径 cocos_headers = -I%(cocosdir)s/cocos -I%(cocosdir)s/cocos/platform/android -I%(cocosdir)s/external/sources # 配置引擎编译参数 cocos_flags = -DANDROID -DCC_PLATFORM=3 -DCC_PLATFORM_MAC_IOS=1 -DCC_PLATFORM_MAC_OSX=4 -DCC_PLATFORM_WINDOWS=2 -DCC_PLATFORM_ANDROID=3 # 配置额外的编译参数 extra_arguments = %(android_headers)s %(clang_headers)s %(cxxgenerator_headers)s %(cocos_headers)s %(android_flags)s %(clang_flags)s %(cocos_flags)s %(extra_flags)s # 需要自动绑定工具解析哪些头文件 headers = %(cocosdir)s/cocos/platform/FileUtils.h %(cocosdir)s/cocos/platform/CanvasRenderingContext2D.h %(cocosdir)s/cocos/platform/Device.h %(cocosdir)s/cocos/platform/SAXParser.h # 在生成的绑定代码中，重命名头文件 replace_headers= # 需要绑定哪些类，可以使用正则表达式，以空格为间隔 classes = FileUtils$ SAXParser CanvasRenderingContext2D CanvasGradient Device DownloaderHints # 哪些类需要在 JS 层扩展，以空格为间隔 classes_need_extend = # 需要为哪些类绑定属性，以逗号为间隔 field = # 需要忽略绑定哪些类，以逗号为间隔 skip = FileUtils::[getFileData setFilenameLookupDictionary destroyInstance getFullPathCache getContents listFilesRecursively], SAXParser::[(?!(init))], Device::[getDeviceMotionValue], CanvasRenderingContext2D::[setCanvasBufferUpdatedCallback set_.+ fillText strokeText fillRect measureText], Data::[takeBuffer getBytes fastSet copy], Value::[asValueVector asValueMap asIntKeyMap] # 需要为哪些类绑定访问属性，以逗号为间隔 getter_setter = CanvasRenderingContext2D::[width//setWidth height//setHeight fillStyle//setFillStyle font//setFont globalCompositeOperation//setGlobalCompositeOperation lineCap//setLineCap lineJoin//setLineJoin lineWidth//setLineWidth strokeStyle//setStrokeStyle textAlign//setTextAlign textBaseline//setTextBaseline] # 重命名函数，以逗号为间隔 rename_functions = FileUtils::[loadFilenameLookupDictionaryFromFile=loadFilenameLookup] # 重命名类，以逗号为间隔 rename_classes = SAXParser::PlistParser # 配置哪些类不需要搜索其父类 classes_have_no_parents = SAXParser # 配置哪些父类需要被忽略 base_classes_to_skip = Ref Clonable # 配置哪些类是抽象类，抽象类没有构造函数，即在 js 层无法通过 var a = new SomeClass();的方式构造 JS 对象 abstract_classes = SAXParser Device # 配置哪些类是始终以一个实例的方式存在的，游戏运行过程中不会被销毁 persistent_classes = FileUtils # 配置哪些类是需要由 CPP 对象来控制 JS 对象生命周期的，未配置的类，默认采用 JS 控制 CPP 对象生命周期 classes_owned_by_cpp = 更多关于自动绑定的内容可参考 使用 JSB 自动绑定。 远程调试与 Profile 默认远程调试和 Profile 是在 debug 模式中生效的，如果需要在 release 模式下也启用，需要手动修改 cocos/bindings/jswrapper/config.h 中的宏开关。 #ifndef USE_V8_DEBUGGER #if defined(CC_DEBUG) && CC_DEBUG > 0 #define USE_V8_DEBUGGER 1 #else #define USE_V8_DEBUGGER 0 #endif #endif 改为： #ifndef USE_V8_DEBUGGER #if defined(CC_DEBUG) && CC_DEBUG > 0 #define USE_V8_DEBUGGER 1 #else #define USE_V8_DEBUGGER 1 // 这里改为 1，强制启用调试 #endif #endif Chrome 远程调试 V8 Windows/Mac 编译、运行游戏（或在 Creator 中直接使用模拟器运行） 用 Chrome 浏览器打开 devtools://devtools/bundled/js_app.html?v8only=true&ws=127.0.0.1:5086/00010002-0003-4004-8005-000600070008。（若使用的是旧版 Chrome，则需要将地址开头的 devtools 改成 chrome-devtools） 断点调试： 抓取 JS Heap： Profile： Android/iOS 保证 Android/iOS 设备与 PC 或者 Mac 在同一个局域网中 编译，运行游戏 用 Chrome 浏览器打开 devtools://devtools/bundled/js_app.html?v8only=true&ws=xxx.xxx.xxx.xxx:6086/00010002-0003-4004-8005-000600070008，其中 xxx.xxx.xxx.xxx 为局域网中 Android/iOS 设备的 IP 地址。（若使用的是旧版 Chrome，则需要将地址开头的 devtools 改成 chrome-devtools） 调试界面与 Windows 相同 Q & A se::ScriptEngine 与 ScriptingCore 的区别，为什么还要保留 ScriptingCore? 在 1.7 中，抽象层被设计为一个与引擎没有关系的独立模块，对 JS 引擎的管理从 ScriptingCore 被移动到了 se::ScriptEngine 类中，ScriptingCore 被保留下来是希望通过它把引擎的一些事件传递给封装层，充当适配器的角色。 ScriptingCore 只需要在 AppDelegate 中被使用一次即可，之后的所有操作都只需要用到 se::ScriptEngine。 bool AppDelegate::applicationDidFinishLaunching() { ... ... director->setAnimationInterval(1.0 / 60); // 这两行把 ScriptingCore 这个适配器设置给引擎，用于传递引擎的一些事件， // 比如 Node 的 onEnter, onExit, Action 的 update，JS 对象的持有与解除持有 ScriptingCore* sc = ScriptingCore::getInstance(); ScriptEngineManager::getInstance()->setScriptEngine(sc); se::ScriptEngine* se = se::ScriptEngine::getInstance(); ... ... } se::Object::root/unroot 与 se::Object::incRef/decRef 的区别? root/unroot 用于控制 JS 对象是否受 GC 控制，root 表示不受 GC 控制，unroot 则相反，表示交由 GC 控制，对一个 se::Object 来说，root 和 unroot 可以被调用多次，se::Object 内部有 _rootCount 变量用于表示 root 的次数。当 unroot 被调用，且 _rootCount 为 0 时，se::Object 关联的 JS 对象将交由 GC 管理。还有一种情况，即如果 se::Object 的析构被触发了，如果 _rootCount > 0，则强制把 JS 对象交由 GC 控制。 incRef/decRef 用于控制 se::Object 这个 cpp 对象的生命周期，前面章节已经提及，建议用户使用 se::HandleObject 来控制 手动创建非绑定对象 的方式控制 se::Object 的生命周期。因此，一般情况下，开发者不需要接触到 incRef/decRef。 对象生命周期的关联与解除关联 使用 se::Object::attachObject 关联对象的生命周期 使用 se::Object::dettachObject 解除对象的生命周期。 objA->attachObject(objB); 类似于 JS 中执行 objA.__nativeRefs[index] = objB，只有当 objA 被 GC 后，objB 才有可能被 GC。 objA->dettachObject(objB); 类似于 JS 中执行 delete objA.__nativeRefs[index];，这样 objB 的生命周期就不受 objA 控制了。 cc::Ref 子类与非 cc::Ref 子类 JS/CPP 对象生命周期管理有何不同？ 目前引擎中 cc::Ref 子类的绑定采用 JS 对象控制 CPP 对象生命周期的方式，这样做的好处是，解决了一直以来被诟病的需要在 JS 层 retain，release 对象的烦恼。 非 cc::Ref 子类采用 CPP 对象控制 JS 对象生命周期的方式。此方式要求，CPP 对象销毁后需要通知绑定层去调用对应 se::Object 的 clearPrivateData, unroot, decRef 的方法。JS 代码中一定要慎重操作对象，当有可能出现非法对象的逻辑中，使用 sys.isObjectValid 来判断 CPP 对象是否被释放了。 绑定 cc::Ref 子类的析构函数需要注意的事项 如果在 JS 对象的 finalize 回调中调用任何 JS 引擎的 API，可能导致崩溃。因为当前引擎正在进行垃圾回收的流程，无法被打断处理其他操作。finalize 回调中是告诉 CPP 层是否对应的 CPP 对象的内存，不能在 CPP 对象的析构中又去操作 JS 引擎 API。 那如果必须调用，应该如何处理？ Cocos Creator 的绑定中，如果引用计数为 1 了，我们不使用 release，而是使用 autorelease 延时 CPP 类的析构到帧结束去执行。 static bool XMLHttpRequest_finalize(se::State& s) { CCLOG(\"jsbindings: finalizing JS object %p (XMLHttpRequest)\", s.nativeThisObject()); XMLHttpRequest* cobj = (XMLHttpRequest*)s.nativeThisObject(); if (cobj->getReferenceCount() == 1) cobj->autorelease(); else cobj->release(); return true; } SE_BIND_FINALIZE_FUNC(XMLHttpRequest_finalize) 请不要在栈（Stack）上分配 cc::Ref 的子类对象 Ref 的子类必须在堆（Heap）上分配，即通过 new，然后通过 release 来释放。当 JS 对象的 finalize 回调函数中统一使用 autorelease 或 release 来释放。如果是在栈上的对象，reference count 很有可能为 0，而这时调用 release，其内部会调用 delete，从而导致程序崩溃。所以为了防止这个行为的出现，开发者可以在继承于 cc::Ref 的绑定类中，标识析构函数为 protected 或者 private，保证在编译阶段就能发现这个问题。 例如： class CC_EX_DLL EventAssetsManagerEx : public EventCustom { public: ... ... private: virtual ~EventAssetsManagerEx() {} ... ... }; EventAssetsManagerEx event(...); // 编译阶段报错 dispatcher->dispatchEvent(&event); // 必须改为 EventAssetsManagerEx* event = new EventAssetsManagerEx(...); dispatcher->dispatchEvent(event); event->release(); 如何监听脚本错误 在 AppDelegate.cpp 中通过 se::ScriptEngine::getInstance()->setExceptionCallback(...) 设置 JS 层异常回调。 bool AppDelegate::applicationDidFinishLaunching() { ... ... se::ScriptEngine* se = se::ScriptEngine::getInstance(); se->setExceptionCallback([](const char* location, const char* message, const char* stack){ // Send exception information to server like Tencent Bugly. // ... // ... }); jsb_register_all_modules(); ... ... return true; } "},"advanced-topics/java-reflection.html":{"url":"advanced-topics/java-reflection.html","title":"Java 原生反射机制","keywords":"","body":"如何在 Android 平台上使用 JavaScript 直接调用 Java 方法 使用 Creator 打包的安卓原生应用中，我们可以通过反射机制直接在 JavaScript 中调用 Java 的静态方法。它的使用方法很简单： var o = jsb.reflection.callStaticMethod(className, methodName, methodSignature, parameters...) 在 callStaticMethod 方法中，我们通过传入 Java 的类名、方法名和方法签名，参数就可以直接调用 Java 的静态方法，并且可以获得 Java 方法的返回值。下面介绍的类名和方法签名可能会有一点奇怪，但是 Java 的规范就是如此的。 类名 参数中的类名必须是包含 Java 包路径的完整类名，例如我们在 com.cocos.game 这个包下面写了一个 Test 类： // package \"com.cocos.game\"; public class Test { public static void hello (String msg) { System.out.println (msg); } public static int sum (int a, int b) { return a + b; } public static int sum (int a) { return a + 2; } } 那么这个 Test 类的完整类名应该是 com/cocos/game/Test，注意这里必须是斜线 /，而不是在 Java 代码中我们习惯的点 .。 方法名 方法名很简单，就是方法本来的名字，例如 sum 方法的名字就是 sum。 方法签名 方法签名稍微有一点复杂，最简单的方法签名是 ()V，它表示一个没有参数没有返回值的方法。其他一些例子： (I)V 表示参数为一个 int，没有返回值的方法 (I)I 表示参数为一个 int，返回值为int的方法 (IF)Z 表示参数为一个 int 和一个 float，返回值为 boolean 的方法 括号内的符号表示参数类型，括号后面的符号表示返回值类型。因为 Java 是允许函数重载的，可以有多个方法名相同但是参数返回值不同的方法，方法签名正是用来帮助区分这些相同名字的方法的。 目前 Cocos Creator 中支持的 Java 类型签名有以下 4 种： Java 类型 签名 int I float F boolean Z String Ljava/lang/String; 参数 参数可以是 0 个或任意多个，直接使用 JavaScript 中的 number、bool 和 string 就可以。 使用示例 我们将会调用上面的 Test 类中的静态方法： // 调用 hello 方法 jsb.reflection.callStaticMethod(\"com/cocos/game/Test\", \"hello\", \"(Ljava/lang/String;)V\", \"this is a message from JavaScript\"); // 调用第一个 sum 方法 var result = jsb.reflection.callStaticMethod(\"com/cocos/game/Test\", \"sum\", \"(II)I\", 3, 7); log(result); //10 // 调用第二个 sum 方法 var result = jsb.reflection.callStaticMethod(\"com/cocos/game/Test\", \"sum\", \"(I)I\", 3); log(result); //5 这样在 控制台 中就会有正确的输出。 注意 另外有一点需要注意的就是，在 Android 应用中，Cocos 引擎的渲染和 JavaScript 的逻辑是在 GL 线程中进行的，而 Android 本身的 UI 更新是在 App 的 UI 线程进行的，所以如果我们在 JavaScript 中调用的 Java 方法有任何刷新 UI 的操作，都需要在 UI 线程进行。 例如，在下面的例子中我们会调用一个 Java 方法，用于弹出一个 Android 的 Alert 对话框。 // 给我们熟悉的 AppActivity 类稍微加点东西 public class AppActivity extends CocosActivity { private static AppActivity app = null; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); app = this; } public static void showAlertDialog(final String title,final String message) { // 这里一定要使用 runOnUiThread app.runOnUiThread(new Runnable() { @Override public void run() { AlertDialog alertDialog = new AlertDialog.Builder(app).create(); alertDialog.setTitle(title); alertDialog.setMessage(message); alertDialog.setIcon(R.drawable.icon); alertDialog.show(); } }); } } 然后在 JavaScript 中调用： jsb.reflection.callStaticMethod(\"com/cocos/game/AppActivity\", \"showAlertDialog\", \"(Ljava/lang/String;Ljava/lang/String;)V\", \"title\", \"hahahahha\"); 这样调用之后你就可以看到一个 Android 原生的 Alert 对话框了。 Java 调用 JavaScript 现在我们可以从 JavaScript 调用 Java 了，那么能不能反过来？当然可以！ 引擎中包含 CocosJavascriptJavaBridge 类，这个类有一个 evalString 方法可以执行 JavaScript 代码，位于引擎目录的 resources\\3d\\cocos2d-x-lite\\cocos\\platform\\android\\java\\src\\com\\cocos\\lib\\CocosJavascriptJavaBridge.java 文件中。我们将会给刚才的 Alert 对话框增加一个按钮，并在它的响应中执行 JavaScript。和上面的情况相反，这次执行 JavaScript 代码必须在 GL 线程中进行。 一般来说，目前引擎并未承诺多线程下的安全性，所以在开发过程中需要避免 JavaScript 代码在其他线程被调用，以避免各种内存错误。 alertDialog.setButton(\"OK\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { // 一定要在 GL 线程中执行 CocosHelper.runOnGameThread(new Runnable() { @Override public void run() { CocosJavascriptJavaBridge.evalString(\"cc.log(\\\"Javascript Java bridge!\\\")\"); } }); } }); 如果要在 C++ 中调用 evalString，我们可以参考下面的方式，确保 evalString 在 JavaScript 引擎所在的线程被执行： Application::getInstance()->getScheduler()->performFunctionInCocosThread([=]() { se::ScriptEngine::getInstance()->evalString(script.c_str()); }); 这样在点击 OK 按钮后，便可以在控制台看到正确的输出。evalString 可以执行任何 JavaScript 代码，并且它可以访问到在 JavaScript 代码中的对象。 "},"advanced-topics/oc-reflection.html":{"url":"advanced-topics/oc-reflection.html","title":"Objective-C 原生反射机制","keywords":"","body":"如何在 iOS 平台上使用 Javascript 直接调用 Objective-C 方法 使用 Cocos Creator 打包的 iOS 或者 Mac 原生应用中，我们也提供了 JavaScript 通过原生语言的反射机制直接调用 Objective-C 函数的方法，示例代码如下： var result = jsb.reflection.callStaticMethod(className, methodName, arg1, arg2, .....); 在 jsb.reflection.callStaticMethod 方法中，我们通过传入 Objective-C 的类名、方法名、参数就可以直接调用 Objective-C 的静态方法，并且可以获得 Objective-C 方法的返回值。注意仅仅支持调用可访问类的静态方法。 警告：苹果 App Store 在 2017 年 3 月对部分应用发出了警告，原因是使用了一些有风险的方法，其中 respondsToSelector: 和 performSelector: 是反射机制使用的核心 API，在使用时请谨慎关注苹果官方对此的态度发展，相关讨论：JSPatch、React-Native、Weex。 类 参数中的类名，只需要传入 Objective-C 中的类名即可，与 Java 不同，类名并不需要路径。比如你在工程底下新建一个类 NativeOcClass，只要你将它引入工程，那么它的类名就是 NativeOcClass，你并不需要传入它的路径。 import @interface NativeOcClass : NSObject +(BOOL)callNativeUIWithTitle:(NSString *) title andContent:(NSString *)content; @end 方法 JavaScript 到 Objective-C 的反射仅支持 Objective-C 中类的静态方法。 方法名比较需要注意。我们需要传入完整的方法名，特别是当某个方法带有参数的时候，需要将它的 : 也带上。根据下面的例子，此时的方法名是 callNativeUIWithTitle:andContent:，不要漏掉了中间的 :。 +(BOOL)callNativeUIWithTitle:(NSString *)title andContent:(NSString *)content; 如果是没有参数的函数，那么就不需要 :。如下面代码中的方法名是 callNativeWithReturnString，由于没有参数，就不需要 :，跟 Objective-C 的 method 写法一致。 +(NSString *)callNativeWithReturnString; 使用示例 下面的示例代码将调用上面 NativeOcClass 的方法，在 JavaScript 层我们只需要这样调用： var ret = jsb.reflection.callStaticMethod(\"NativeOcClass\", \"callNativeUIWithTitle:andContent:\", \"cocos2d-js\", \"Yes! you call a Native UI from Reflection\"); 这里是这个方法在 Objective-C 的实现，可以看到是弹出了一个原生对话框。并把 title 和 content 设置成你传入的参数，并返回一个 boolean 类型的返回值。 +(BOOL)callNativeUIWithTitle:(NSString *) title andContent:(NSString *)content{ UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:title message:content delegate:self cancelButtonTitle:@\"Cancel\" otherButtonTitles:@\"OK\", nil]; [alertView show]; return true; } 此时，你就可以在 ret 中接收到从 Objective-C 传回的返回值（true）了。 Objective-C 执行 JavaScript 代码 反过来，我们也可以通过 evalString 在 C++ 或者 Objective-C 中执行 JavaScript 代码。 比如： Application::getInstance()->getScheduler()->performFunctionInCocosThread([=](){ se::ScriptEngine::getInstance()->evalString(script.c_str()); }); 注意：除非明确当前线程是 主线程，否则都需要将函数分发到主线程执行。 注意 在 Objective-C 的实现中，如果方法的参数需要使用 float、int 和 bool 的，请使用如下类型进行转换： float、int 请使用 NSNumber 类型 bool 请使用 BOOL 类型 例如下面代码，传入两个浮点数，然后计算它们的合并返回，我们使用 NSNumber 作为参数类型，而不是 int 和 float。 +(float) addTwoNumber:(NSNumber *)num1 and:(NSNumber *)num2{ float result = [num1 floatValue]+[num2 floatValue]; return result; } 目前参数和返回值支持 int、float、bool 和 string，其余的类型暂时不支持。 "},"advanced-topics/cmake-learning.html":{"url":"advanced-topics/cmake-learning.html","title":"CMake 使用简介","keywords":"","body":"CMake 使用简介 CMake 是一个跨平台的构建工具，可根据需要输出各种各样的 Makefile 或者 Project 文件。CMake 使用 CMakeLists.txt 来配置工程文件，开发者可以在这里集成 SDK 或者引用用于编译原生平台的库和配置，详情可参考 二次开发。 从 v3.0 开始，Creator 已经集成了 CMake 的输出过程和基础编写，本篇文档主要介绍原生平台上 CMakeLists.txt 的使用规则以及一些简单的示例。 CMakeLists 的生成和使用 生成 当选择某个原生平台进行构建时，项目目录 native\\engine 目录下会生成 当前构建的平台名称 文件夹（例如 android），以及 common 文件夹。CMake 在第一次运行时将会在这两个目录下分别生成 CMakeLists.txt 文件，作用各不相同： 当前构建的平台名称 文件夹：CMakeLists.txt 主要用于配置对应的构建平台。以 Android 平台为例： common 文件夹：CMakeLists.txt 主要用于配置整个项目。 CMakeLists.txt 的语法比较简单，由 命令、注释 和 空格 组成。其中命令是不区分大小写的，但命令中的参数和变量则是大小写敏感的。 使用 那如何利用 CMake 将项目编译成动态库提供给其他项目使用呢？简单来说就是先录入编译信息，然后 CMake 命令再根据 CMakeLists.txt 中的配置生成编译所需的 Makefile 文件。 下面我们以 Android 平台为例，具体看一下如何配置项目目录 native/engine/android 目录下的 CMakeLists.txt。 # 设置 CMake 所需的最低版本。如果使用的 CMake 版本低于该版本，会提醒用户升级到该版本之后再执行 CMake cmake_minimum_required(VERSION 3.8) # 声明项目名称 option(APP_NAME \"Project Name\" \"cmakeTest\") # 声明项目名称以及支持的编程语言，若不指定则默认支持所有编程语言，包括 C、C++ 和 JAVA 三种，分别用 C、CXX、JAVA 表示。 project(${APP_NAME} CXX) # include 从文件或模块加载和运行 CMake 代码 include(${CMAKE_CURRENT_LIST_DIR}/../common/CMakeLists.txt) # 定义一个新变量 LIB_NAME 并设置为 “cocos” set(LIB_NAME cocos) # 定义一个变量 PROJ_SOURCES set(PROJ_SOURCES ${CMAKE_CURRENT_LIST_DIR}/../common/Classes/Game.h ${CMAKE_CURRENT_LIST_DIR}/../common/Classes/Game.cpp ${CMAKE_CURRENT_LIST_DIR}/jni/main.cpp ) # 如果在该路径下不存在 jsb_module_register.cpp，则复制这个路径下的 jsb_module_register.cpp 文件到目标文件夹中 if(NOT EXISTS ${CMAKE_CURRENT_LIST_DIR}/../common/Classes/jsb_module_register.cpp) file(COPY \"${COCOS_X_PATH}/cocos/bindings/manual/jsb_module_register.cpp\" DESTINATION ${CMAKE_CURRENT_LIST_DIR}/../common/Classes/) endif() # 添加新 element 到 PROJ_SOURCES 中 list(APPEND PROJ_SOURCES ${CMAKE_CURRENT_LIST_DIR}/../common/Classes/jsb_module_register.cpp ) # 动态库 PROJ_SOURCES 生成链接文件到 LIB_NAME 中 add_library(${LIB_NAME} SHARED ${PROJ_SOURCES}) # 将目标文件 LIB_NAME 与库文件 cocos2d_jni 进行链接 target_link_libraries(${LIB_NAME} \"-Wl,--whole-archive\" cocos2d_jni \"-Wl,--no-whole-archive\" cocos2d ) # 将包含目录添加到目标文件夹。 target_include_directories(${LIB_NAME} PRIVATE ${CMAKE_CURRENT_LIST_DIR}/../common/Classes ) 项目目录 native/engine/common 目录下的 CMakeLists.txt 文件的配置方法也是一致的，但是会多一些基础的配置。例如： option(USE_SPINE \"Enable Spine\" ON) 构建后生成的发布包目录（例如 build/android）下有一个 proj/cfg.cmake 文件，用于存放当前项目的一些配置。因为 CMakeLists.txt 中有对 cfg.cmake 文件进行引入，所以当 cfg.cmake 文件中的配置做了修改，便会同步到 CMakeLists.txt 中；若是相同的配置，则直接覆盖，以 cfg.cmake 文件中的为准。 CMakeLists.txt # 引入 cfg.cmake include(${RES_DIR}/proj/cfg.CMake) 例如将编辑器主菜单 项目 -> 项目设置 -> 功能裁剪 中的 Spine 动画 去掉勾选： 则在再次构建时重新生成的 cfg.make 中就会将 USE_SPINE 设置为 OFF： 然后在编译时，CMake 便会根据配置（例如 CMakeLists.txt 以及 CMakeLists.txt 中引入的 cfg.make 等配置文件）生成 CMakeCache.txt 文件，该文件中包含了项目构建时 需要依赖的各种输入参数。 CMakeLists 常用编译指令 查找编译头文件 找到编译头文件，CMake 即可指定编译给定目标时要使用的包含目录或目标文件夹： target_include_directories( [SYSTEM] [BEFORE] [items1...] [ [items2...] ...]) 一般情况下，通过上述指令引用库路径便可作为外部依赖项引入到 CMake 中。例如： # 将 Classes 头文件库路径添加到 LIB_NAME 中 target_include_directories(${LIB_NAME} PRIVATE ${CMAKE_CURRENT_LIST_DIR}/../common/Classes ) 更多内容可参考 CMake 官方文档 target_include_directories。 生成 target（执行文件） 上述 查找编译头文件 指令中的 target 是通过 add_library、add_executable、add_custom_command 指令生成的执行文件。 通过 add_library 指令生成 add_library 指令将指定的源文件生成链接文件，然后添加到工程中。 add_library( [STATIC | SHARED | MODULE] [EXCLUDE_FROM_ALL] [source1] [source2 ...]) name：表示添加一个名为 的目标库，由命令中列出的源文件（source1、source2）构建而成，在项目中是全局唯一的。源文件若是在后续通过 target_sources() 指定，那么这里就可以忽略。 STATIC（静态库）、SHARED（动态库）、MODULE（模块库）：用于指定要创建的库的类型。STATIC 库是对象文件的档案，用于连接其他目标。共享库是动态链接的，并在运行时加载。MODULE 库是插件，不被链接到其他目标中，但可以在运行时使用类似 dlopen 的功能动态加载。 示例如下： add_library(${LIB_NAME} SHARED ${PROJ_SOURCES}) 更多内容详情请参考 CMake 官方文档 add_library。 通过 add_executable 指令生成 add_executable 指令通过使用指定的源文件来生成目标可执行文件。 add_executable( [WIN32] [MACOSX_BUNDLE] [EXCLUDE_FROM_ALL] [source1] [source2 ...]) name：可执行目标文件的名称，在一个 CMake 工程中，这个名称必须全局唯一。 WIN32：用于在 Windows 中创建一个以 WinMain 为入口的可执行目标文件（通常入口函数为 main），该文件是一个 GUI 应用程序，而不是 控制台应用程序。在使用 WIN32 时，可执行目标的 WIN32_EXECUTABLE 会被置为 ON。 MACOSX_BUNDLE：用于在 macOS 或者 iOS 中创建一个 GUI 可执行应用程序。在使用 MACOSX_BUNDLE 时，可执行目标的 MACOSX_BUNDLE 会被置为 ON。 EXCLUDE_FROM_ALL：是否构建指定的可执行目标文件。当使用该项时，可执行目标文件不会被构建。 [source1] [source2 ...]：构建可执行目标文件所需要的源文件。也可以通过 target_sources() 继续为可执行目标文件添加源文件，需要注意的是在调用 target_sources 之前，可执行目标文件必须已经通过 add_executable 或 add_library 定义了。 示例如下： add_executable(hello-world hello-world.cpp) 更多内容详情请参考 CMake 官方文档 add_executable。 通过 add_custom_command 指令生成 add_custom_command 指令用于添加自定义构建规则到生成的构建系统中，适用于以下两种情况： 添加自定义命令以生成输出文件 add_custom_command(OUTPUT output1 [output2 ...] COMMAND command1 [ARGS] [args1...] [COMMAND command2 [ARGS] [args2...] ...] [MAIN_DEPENDENCY depend] [DEPENDS [depends...]] [BYPRODUCTS [files...]] [IMPLICIT_DEPENDS depend1 [ depend2] ...] [WORKING_DIRECTORY dir] [COMMENT comment] [DEPFILE depfile] [JOB_POOL job_pool] [VERBATIM] [APPEND] [USES_TERMINAL] [COMMAND_EXPAND_LISTS]) 部分参数含义如下： OUTPUT：指定命令预期产生的输出文件。输出文件名称可以是 绝对路径 或者 相对路径（相对于当前的构建的源目录路径）。 COMMAND：指定在构建时执行的命令行。 示例如下： add_custom_command(OUTPUT COPY_RES COMMAND ${CMAKE_COMMAND} -E copy_if_different ${abs} $/${filename} ) 注意： 只有在相同的 CMakeLists.txt 中指定了所有依赖于其输出的目标时才有效。 不要同时在多个相互独立的目标文件中执行上述命令产生相同的文件，主要是为了防止冲突产生。 在某个目标（例如库或者可执行程序）的构建过程中添加额外执行的定制命令 add_custom_command(TARGET PRE_BUILD | PRE_LINK | POST_BUILD COMMAND command1 [ARGS] [args1...] [COMMAND command2 [ARGS] [args2...] ...] [BYPRODUCTS [files...]] [WORKING_DIRECTORY dir] [COMMENT comment] [VERBATIM] [USES_TERMINAL] [COMMAND_EXPAND_LISTS]) 部分参数含义如下： TARGET：指定命令运行的目标 COMMAND：指定在构建时执行的命令行。 若需要了解更多关于 add_custom_command 指令的内容，详情请参考 CMake 官方文档 add_custom_command。 链接库文件 target_link_libraries 中库文件的顺序符合 gcc 链接顺序的规则，即被依赖的库放在依赖它的库的后面。 target_link_libraries( [item1] [item2] [...] [[debug|optimized|general] ] ...) item 表示库文件没有后缀的名字。默认情况下，库依赖项是传递的。当这个目标链接到另一个目标时，链接到这个目标的库也会出现在另一个目标的连接线上。例如： target_link_libraries(${LIB_NAME} \"-Wl,--whole-archive\" cocos2d_jni \"-Wl,--no-whole-archive\" cocos2d ) 更多内容可参考 CMake 官方文档 target_link_libraries。 其他命令 打印调试日志消息 message(STATUS “my custom debug info”) 操作文件命令 file(COPY \"${COCOS_X_PATH}/cocos/bindings/manual/jsb_module_register.cpp\" DESTINATION ${CMAKE_CURRENT_LIST_DIR}/../common/Classes/) COPY 表示复制文件、目录以及符号链接到一个目标文件夹中。输入路径为相对于当前源码目录的路径。目标路径则是相对于当前的构建目录。 从文件或模块加载和运行 CMake 代码 include(${CMAKE_CURRENT_LIST_DIR}/../common/CMakeLists.txt) CMakeLists 使用示例 Android.mk 是 Android 源码编译系统的 Makefile，用于编译系统中 C++ 的动态库、静态库、可执行文件和 apk 等。接下来通过将 腾讯云多媒体引擎 SDK 中的一个 Android.mk 改写成 CMakeLists.txt 做一个简单的示例。 Android.mk 中的代码如下： LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) LOCAL_MODULE := Pre_GMESDK LOCAL_SRC_FILES := ./$(TARGET_ARCH_ABI)/libgmesdk.so include $(PREBUILT_SHARED_LIBRARY) include $(CLEAR_VARS) LOCAL_MODULE := Pre_TRAE LOCAL_SRC_FILES := ./$(TARGET_ARCH_ABI)/libtraeimp.so include $(PREBUILT_SHARED_LIBRARY) include $(CLEAR_VARS) LOCAL_MODULE := Pre_PTT LOCAL_SRC_FILES := ./$(TARGET_ARCH_ABI)/libsilk.so include $(PREBUILT_SHARED_LIBRARY) include $(CLEAR_VARS) LOCAL_MODULE := Pre_MP3 LOCAL_SRC_FILES := ./$(TARGET_ARCH_ABI)/libgmecodec.so include $(PREBUILT_SHARED_LIBRARY) 其中有一个 LOCAL_PATH 变量，表示源文件在开发树中的位置。构建系统提供的宏函数 my-dir 将返回当前目录（Android.mk 文件本身所在的目录）的路径： LOCAL_PATH := $(call my-dir) 对应在 CMakeLists.txt 则表示为： set(LOCAL_PATH ${CMAKE_CURRENT_SOURCE_DIR}/..) 在 Android.mk 中以下部分的代码： include $(CLEAR_VARS) LOCAL_MODULE := Pre_GMESDK LOCAL_SRC_FILES := ./$(TARGET_ARCH_ABI)/libgmesdk.so include $(PREBUILT_SHARED_LIBRARY) 对应在 CMakeLists.txt 中则表示为： add_library(Pre_GMESDK SHARED IMPORTED GLObal) set_target_properties(Pre_GMESDK PROPERTIES IMPORTED_LOCATION ./${ANDROID_ABI}/libgmesdk.so ) 结语 CMake 的指令和用法还有很多，欢迎大家去探寻和学习，本篇文档只是做了简单的示例，开发者可针对自身的实际情况，对自己的工作流进行定制。未来 Cocos Creator 也会将 CMake 更多的功能集成到编辑器的 构建发布 面板中，方便使用。 更多关于 CMake 语法和接口的详细内容，请参考 CMake 官方文档。 "},"advanced-topics/websocket-server.html":{"url":"advanced-topics/websocket-server.html","title":"WebSocket 服务器","keywords":"","body":"使用 WebSocket 服务器 开发者可以在游戏进程中启动一个 WebSocket 服务器，提供 RPC 接口。通过完善和调用这些 RPC 接口，开发者能够对游戏进程内部状态进行监控，增加对游戏进程状态的管理能力。 如何启用 WebSocket 服务器 默认是剔除的。若要启用，需要在构建原生平台后生成的发布包目录 build/[platform]/proj（例如 Android 平台默认为 build/android/proj）下的 cfg.cmake 文件中添加配置 set(USE_WEBSOCKET_SERVER ON)。 如何调用 WebSocket 服务器接口 可参考下方实例代码： // 在原生平台的 Release 模式下或者在 Web /微信小游戏等平台中，WebSocketServer 可能没有定义 if (typeof WebSocketServer == \"undefined\") { console.error(\"WebSocketServer is not enabled!\"); return; } let s = new WebSocketServer(); s.onconnection = function (conn) { conn.ondata = function (data) { conn.send(data, (err) => {}); } conn.onclose = function () { console.log(\"connection gone!\"); }; }; s.onclose = function () { console.log(\"server is closed!\"); } s.listen(8080, (err) => { if (!err); console.log(\"server booted!\"); }); API 接口定义如下： /** * 服务器对象 */ class WebSocketServer { /** * 关闭服务 */ close(cb?: WsCallback): void; /** * 监听并启动服务 */ listen(port: number, cb?: WsCallback): void; /** * 处理新的请求 */ set onconnection(cb: (client: WebSocketServerConnection) => void); /** * 设置服务器关闭回调 */ set onclose(cb: WsCallback); /** * 获取所有的连接对象 */ get connections(): WebSocketServerConnection[]; } /** * 服务器中客户端的连接对象 */ class WebSocketServerConnection { /** * 关闭连接 */ close(cb?: WsCallback): void; /** * 发送数据 */ send(data: string|ArrayBuffer, cb?: WsCallback): void; set ontext(cb: (data: string) => void); set onbinary(cb: (data: ArrayBuffer) => void); set ondata(cb: (data: string|ArrayBuffer) => void); set onconnect(cb: () => void;); set onclose(cb: WsCallback); set onerror(cb: WsCallback); get readyState(): number; } interface WsCallback { (err?: string): void; } 参考链接 接口设计参考了 nodejs-websocket。 "},"advanced-topics/jsb-auto-binding.html":{"url":"advanced-topics/jsb-auto-binding.html","title":"JSB 自动绑定","keywords":"","body":"使用 JSB 自动绑定 本文转载自 腾讯在线教育部技术博客 作者：张鑫（kevinxzhang） 尽管 Creator 提供了 jsb.reflection.callStaticMethod 方式支持从 ts 端直接调用 Native 端（Android/iOS/Mac）的接口，但是经过大量实践发现此接口在大量频繁调用情况下性能很低下，尤其是在 Android 端，比如调用 Native 端实现的打印 log 的接口，而且会容易引起一些 native crash，例如 local reference table overflow 等问题。纵观 Cocos 原生代码的实现，基本所有的接口方法的实现都是基于 JSB 的方式来实现，所以此文主要讲解下 JSB 的自动绑定逻辑，帮助大家能快速实现 callStaticMethod 到 JSB 的改造过程。 背景 对于用过 Cocos Creator（为了方便后文直接简称 CC）的人来说，jsb.reflection.callStaticMethod 这个方法肯定不陌生，其提供了我们从 ts 端调用 Native 端的能力，例如我们要调用 Native 实现的 log 打印和持久化的接口，就可以很方便的在 JavaScript 中按照如下的操作调用即可： if (sys.isNative && sys.os == sys.OS.IOS) { msg = this.buffer_string + '\\n[cclog][' + clock + '][' + tag + ']' + msg; jsb.reflection.callStaticMethod(\"ABCLogService\", \"log:module:level:\", msg, 'cclog', level); return; } else if (sys.isNative && sys.os == sys.OS.ANDROID) { msg = this.buffer_string + '\\n[cclog][' + clock + '][' + tag + ']' + msg; jsb.reflection.callStaticMethod(\"com/example/test/CommonUtils\", \"log\", \"(ILjava/lang/String;Ljava/lang/String;)V\", level, 'cclog', msg); return; } 尽管使用很简单，一行代码就能实现跨平台调用，稍微看下其实现就可以知道，在 C++ 层 Android 端是通过 jni 的方式实现的，IOS 端是通过运行时的方式动态调用，但是为了兼顾通用性和支持所有的方法，Android 端没有对 jni 相关对象做缓存机制，就会导致短时间大量调用时出现很严重的性能问题，之前我们遇到的比较多的情况就是在下载器中打印 log，某些应用场景短时间内触发大量的下载操作，就会出现 local reference table overflow 的 crash，甚至在低端机上导致界面卡顿无法加载出来的问题。 修复此问题就需要针对 log 调用进行 JSB 的改造，同时还要加上 jni 的相关缓存机制，优化性能。jSB 绑定说白了就是 C++ 和脚本层之间进行对象的转换，并转发脚本层函数调用到 C++ 层的过程。 JSB 绑定通常有 手动绑定 和 自动绑定 两种方式。手动绑定方式可以参考 使用 JSB 手动绑定。 手动绑定方式优点是灵活，可定制型强；缺点就是全部代码要自己书写，尤其是在 ts 类型跟 c++ 类型转换上，稍有不慎容易导致内存泄漏，某些指针或者对象没有释放。 自动绑定方式则会帮你省了很多麻烦，直接通过一个脚本一键生成相关的代码，后续如果有新增或者改动，也只需要重新执行一次脚本即可。所以自动绑定对于不需要进行强定制，需要快速完成JSB的情况来说就再适合不过了。下面就一步步说明下如何实现自动绑定 JSB。 环境配置和自动绑定展示 环境配置 自动绑定，说简单点，其实就只要执行一个 python 脚本即可自动生成对应的 .cpp、.h 文件。所以首先要保证电脑有 python 运行环境，这里以 Mac 上安装为例来讲解。 安装 python 3.0 版本，从 python 官网下载安装包： https://www.python.org/downloads/release/python-398/ 通过 pip3 安装 python 的一些依赖库： sudo pip3 install pyyaml==5.4.1 sudo pip3 install Cheetah3 安装 NDK，涉及到 c++ 肯定这个是必不可少的，建议安装 Android NDK r16b 版本，然后在 ~/.bash_profile 中设置 PYTHON_ROOT 和 NDK_ROOT 这两个环境变量，因为在后面执行的 python 文件里面就会直接用到这两个环境变量： export NDK_ROOT=/Users/kevin/android-ndk-r16b export PYTHON_BIN=python3 Windows 下直接参考上面需要安装的模块直接安装就好了，最后也要记得配置环境变量。 自动绑定展示 这里演示的是 cocos 引擎下面也即 cocos/bindings/auto 目录下的文件（如下图所示）是怎么自动生成的： 其实从这些文件名的开头也能看出，这些文件命名都是有某些特定规律的，那么这些文件是怎么生成的呢？首先打开终端，先 cd 到 tools/tojs 目录下，然后直接运行 ./genbindings.py： 大概运行一分钟左右后，会出现如下的提示，说明已经顺利生成完了： 经过上面的步骤后，cocos/bindings/auto 下的文件就全部自动生成出来了，是不是非常方便。 下面再以 ts 层通过 jsb 调用 Native 层的 log 方法打印日志为例，详细的告知下如何实现通过自动绑定工具，依据自己写的 c++ 代码，生成对应的自动绑定文件。 编写 c++ 层的实现 C++ 作为连接 ts 层和 Native 层的桥梁，既然要实现 jsb 调用，那第一步肯定是要先把 C++ 层的头文件和实现准备好，这里我们在 cocos/⁩ 创建一个 test 文件夹用于存放相关文件： 这里先准备 ABCJSBBridge.h，里面主要是申明了一个 abcLog 的函数，此函数就是供 ts 层调用打 log 的，另外由于打 log 方法肯定在 ts 层很多地方都会使用，所以这里采用了一个单例模式，提供了 getInstance() 来获取当前类的实例。 #pragma once #include namespace abc { class JSBBridge { public: void abcLog(const std::string& msg); /** * Returns a shared instance of the director. * @js _getInstance */ static JSBBridge* getInstance(); /** @private */ JSBBridge(); /** @private */ ~JSBBridge(); bool init(); }; } 下面是对应的实现 ABCJSBBridge.cpp： #include #include \"ABCJSBBridge.h\" namespace abc { // singleton stuff static JSBBridge *s_SharedJSBBridge = nullptr; JSBBridge::JSBBridge() { CC_LOG_ERROR(\"Construct JSBBridge %p\", this); init(); } JSBBridge::~JSBBridge() { CC_LOG_ERROR(\"Destruct JSBBridge %p\", this); s_SharedJSBBridge = nullptr; } JSBBridge* JSBBridge::getInstance() { if (!s_SharedJSBBridge) { CC_LOG_ERROR(\"getInstance JSBBridge \"); s_SharedJSBBridge = new (std::nothrow) JSBBridge(); CCASSERT(s_SharedJSBBridge, \"FATAL: Not enough memory for create JSBBridge\"); } return s_SharedJSBBridge; } bool JSBBridge::init(void) { CC_LOG_ERROR(\"init JSBBridge \"); return true; } void JSBBridge::abcLog(const std::string& msg) { CC_LOG_ERROR(\"%s\", msg.c_str()); } } JSB 配置脚本编写 我们在 tools/tojs 目录下找到 genbindings.py 脚本，复制并重命名为 genbindings_test.py，然后修改genbindings_test.py 模块配置，只保留 cocos2dx_test 模块。 接下来是在 tools/tojs 目录下添加自定义的配置文件 cocos2dx_test.ini，其实就跟 tools/tojs 下的其他 .ini 文件类似，主要让自动绑定工具知道哪些 API 要被绑定和以什么样的方式绑定，写法上直接参考 Cocos 已有的 ini 文件，这里展示下 cocos2dx_test.ini 的内容： [cocos2dx_test] # the prefix to be added to the generated functions. You might or might not use this in your own # templates prefix = cocos2dx_test # create a target namespace (in javascript, this would create some code like the equiv. to `ns = ns || {}`) # all classes will be embedded in that namespace target_namespace = abc macro_judgement = android_headers = android_flags = -target armv7-none-linux-androideabi -D_LIBCPP_DISABLE_VISIBILITY_ANNOTATIONS -DANDROID -D__ANDROID_API__=14 -gcc-toolchain %(gcc_toolchain_dir)s --sysroot=%(androidndkdir)s/platforms/android-14/arch-arm -idirafter %(androidndkdir)s/sources/android/support/include -idirafter %(androidndkdir)s/sysroot/usr/include -idirafter %(androidndkdir)s/sysroot/usr/include/arm-linux-androideabi -idirafter %(clangllvmdir)s/lib64/clang/5.0/include -I%(androidndkdir)s/sources/cxx-stl/llvm-libc++/include clang_headers = clang_flags = -nostdinc -x c++ -std=c++17 -fsigned-char -mfloat-abi=soft -U__SSE__ cocos_headers = -I%(cocosdir)s/cocos -I%(cocosdir)s/cocos/platform/android -I%(cocosdir)s/external/sources cocos_flags = -DANDROID -DCC_PLATFORM=3 -DCC_PLATFORM_MAC_IOS=1 -DCC_PLATFORM_MAC_OSX=4 -DCC_PLATFORM_WINDOWS=2 -DCC_PLATFORM_ANDROID=3 cxxgenerator_headers = # extra arguments for clang extra_arguments = %(android_headers)s %(clang_headers)s %(cxxgenerator_headers)s %(cocos_headers)s %(android_flags)s %(clang_flags)s %(cocos_flags)s %(extra_flags)s # what headers to parse headers = %(cocosdir)s/cocos/test/ABCJSBBridge.h # cpp_headers = network/js_network_manual.h # what classes to produce code for. You can use regular expressions here. When testing the regular # expression, it will be enclosed in \"^$\", like this: \"^Menu*$\". classes = JSBBridge # what should we skip? in the format ClassName::[function function] # ClassName is a regular expression, but will be used like this: \"^ClassName$\" functions are also # regular expressions, they will not be surrounded by \"^$\". If you want to skip a whole class, just # add a single \"*\" as functions. See bellow for several examples. A special class name is \"*\", which # will apply to all class names. This is a convenience wildcard to be able to skip similar named # functions from all classes. skip = JSBBridge::[init] rename_functions = rename_classes = # for all class names, should we remove something when registering in the target VM? remove_prefix = # classes for which there will be no \"parent\" lookup classes_have_no_parents = JSBBridge # base classes which will be skipped when their sub-classes found them. base_classes_to_skip = Clonable # classes that create no constructor # Set is special and we will use a hand-written constructor abstract_classes = JSBBridge 其实从里面的注释也讲的非常详细，这里说几个主要的属性及含义： 以上的配置完成后，就可以 cd 到 tools/tojs 目录下，运行 ./genbindings_test.py 自动生成绑定文件。然后就会看到在 cocos/bindings/auto 下面会多出了两个个绑定文件： 打开生成的 jsb_cocos2dx_test_auto.cpp： #include \"cocos/bindings/auto/jsb_cocos2dx_test_auto.h\" #include \"cocos/bindings/manual/jsb_conversions.h\" #include \"cocos/bindings/manual/jsb_global.h\" #include \"test/ABCJSBBridge.h\" #ifndef JSB_ALLOC #define JSB_ALLOC(kls, ...) new (std::nothrow) kls(__VA_ARGS__) #endif #ifndef JSB_FREE #define JSB_FREE(ptr) delete ptr #endif se::Object* __jsb_abc_JSBBridge_proto = nullptr; se::Class* __jsb_abc_JSBBridge_class = nullptr; static bool js_cocos2dx_test_JSBBridge_abcLog(se::State& s) // NOLINT(readability-identifier-naming) { auto* cobj = SE_THIS_OBJECT(s); SE_PRECONDITION2(cobj, false, \"js_cocos2dx_test_JSBBridge_abcLog : Invalid Native Object\"); const auto& args = s.args(); size_t argc = args.size(); CC_UNUSED bool ok = true; if (argc == 1) { HolderType arg0 = {}; ok &= sevalue_to_native(args[0], &arg0, s.thisObject()); SE_PRECONDITION2(ok, false, \"js_cocos2dx_test_JSBBridge_abcLog : Error processing arguments\"); cobj->abcLog(arg0.value()); return true; } SE_REPORT_ERROR(\"wrong number of arguments: %d, was expecting %d\", (int)argc, 1); return false; } SE_BIND_FUNC(js_cocos2dx_test_JSBBridge_abcLog) static bool js_cocos2dx_test_JSBBridge_getInstance(se::State& s) // NOLINT(readability-identifier-naming) { const auto& args = s.args(); size_t argc = args.size(); CC_UNUSED bool ok = true; if (argc == 0) { abc::JSBBridge* result = abc::JSBBridge::getInstance(); ok &= nativevalue_to_se(result, s.rval(), nullptr /*ctx*/); SE_PRECONDITION2(ok, false, \"js_cocos2dx_test_JSBBridge_getInstance : Error processing arguments\"); SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); return true; } SE_REPORT_ERROR(\"wrong number of arguments: %d, was expecting %d\", (int)argc, 0); return false; } SE_BIND_FUNC(js_cocos2dx_test_JSBBridge_getInstance) bool js_register_cocos2dx_test_JSBBridge(se::Object* obj) // NOLINT(readability-identifier-naming) { auto* cls = se::Class::create(\"JSBBridge\", obj, nullptr, nullptr); cls->defineFunction(\"abcLog\", _SE(js_cocos2dx_test_JSBBridge_abcLog)); cls->defineStaticFunction(\"getInstance\", _SE(js_cocos2dx_test_JSBBridge_getInstance)); cls->install(); JSBClassType::registerClass(cls); __jsb_abc_JSBBridge_proto = cls->getProto(); __jsb_abc_JSBBridge_class = cls; se::ScriptEngine::getInstance()->clearException(); return true; } bool register_all_cocos2dx_test(se::Object* obj) { // Get the ns se::Value nsVal; if (!obj->getProperty(\"abc\", &nsVal)) { se::HandleObject jsobj(se::Object::createPlainObject()); nsVal.setObject(jsobj); obj->setProperty(\"abc\", nsVal); } se::Object* ns = nsVal.toObject(); js_register_cocos2dx_test_JSBBridge(ns); return true; } 看到这里是不是感觉很熟悉，跟 Cocos 已有的那些 cpp 完全一样，甚至包括里面的注册函数和类的定义都给全部自动生成了。 Cocos 编译配置 尽管经过上面一步后我们已经生成出来了绑定文件，但是 ts 层还是没法直接使用，因为还需要把生成的绑定文件，配置到 CMakeLists.txt 文件中，从而跟其他 c++ 文件一起编译才行，这部分主要就是最后的 CMakeLists.txt 编译配置。 打开 CMakeLists.txt 文件，在其中加上最开始实现的 ABCJSBBridge.h 和 ABCJSBBridge.cpp，还有自动绑定生成的 jsb_cocos2dx_test_auto.h 和 jsb_cocos2dx_test_auto.cpp 文件： 打开 cocos/bindings/manual/jsb_module_register.cpp，添加 cocos2dx_test 模块的注册代码： 经过上面这些配置后，最终就可以在 ts 层直接像下面这样来进行调用： import { _decorator, Component, Node } from 'cc'; const { ccclass, property } = _decorator; @ccclass('Test') export class Test extends Component { start () { // @ts-ignore abc.JSBBridge.getInstance().abcLog(\"JSB 绑定测试成功\") } } 自动绑定的限制条件 自动绑定依赖于 Bindings Generator 工具，Cocos 官方还在 GitHub 上单独把这部分拎出来了：https://github.com/cocos-creator/bindings-generator。Bindings Generator 工具它可以将 C++ 类的公共方法和公共属性绑定到脚本层。自动绑定工具尽管非常强大，但是还是会有一些限制： 只能够针对类生成绑定，不可以绑定结构体，独立函数等。 不能够生成 Delegate 类型的 API，因为脚本中的对象是无法继承 C++ 中的 Delegate 类并重写其中的 Delegate 函数的。 子类中重写了父类的 API 的同时，又重载了这个 API。 部分 API 实现内容并没有完全体现在其 API 定义中。 在运行时由 C++ 主动调用的 API。 总结 总的来说，自动绑定 JSB 只需要要求开发者编写相关的实现 C++ 实现类，一个配置文件，然后执行一条命令就能完整整个的绑定过程。如果没有什么特殊定制，相对于手动绑定来说，效率上还是提高了不少。实际工作做可以依据具体情况先用自动绑定功能，然后再去手动修改生成的绑定文件，达到事倍功半的效果。 "},"asset/model/image-location-resolution.html":{"url":"asset/model/image-location-resolution.html","title":"Cocos Creator 图像位置解析算法","keywords":"","body":"Cocos Creator 图像位置解析算法 Cocos Creator 图像位置解析算法中给定的参数及参数说明如下： 参数 说明 url 期望的 URL startDir 起始搜索目录 DEPTH 搜索深度，固定为 2 SEARCH_DIR_NAMES 贴图文件夹名称数组，默认为：textures、materials SEARCH_EXT_NAMES 需要搜索的扩展名数组，固定为：.jpg、.jpeg、.png、.tga、.webp Cocos Creator 图像位置解析算法由以下过程给出： 如果 url 对应的文件存在，则返回 url 令 expectedExtName 为 url 的扩展名 令 expectedBaseName 为 url 去扩展后的文件名 令 searchExtNames 为 [expectedExtName, ...SEARCH_EXT_NAMES] 去重之后的数组 令 currentDir 为 startDir，进行 DEPTH 次循环： 如果 currentDir 处于项目 assets 目录外，则退出循环 如果 currentDir 目录中没有任何一个子目录的名称匹配 SEARCH_DIR_NAMES，则执行下次循环 令 dir 为 currentDir 目录中名称匹配 SEARCH_DIR_NAMES 的子目录 在 dir 中搜索是否有文件基础名称匹配 expectedBaseName 且扩展名匹配 searchExtNames的，如果有，则返回其路径 将 currentDir 置为其上层目录 返回搜索失败 "},"asset/script.html":{"url":"asset/script.html","title":"脚本资源","keywords":"","body":"脚本资源 在 Cocos Creator 中，脚本也是资源的一部分。 关于脚本的详细介绍，可参考：脚本指南 关于脚本资源的创建和使用方法，详情可见：脚本创建 "},"concepts/scene/layer.html":{"url":"concepts/scene/layer.html","title":"层级","keywords":"","body":"层级 节点的 Layer 属性是一个无符号 32 位的整数，最多支持 32 个不同类型的 Layer，可在编辑器上方菜单栏的 项目 -> 项目设置 -> Layers 中设置。其中开发者可自定义第 0 ~ 19 个 Layer，剩下后面的 12 个 Layers 则是引擎内置的。 相机的 Visibility 属性跟节点的 Layer 属性，都是用来控制其可见性的。但只有当节点设置的 Layer 属性包含在相机的 Visibility 中时，节点才可以被相机看见。相机的 Visibility 属性采用 | 和 & 这种位操作符来判断节点的 Layer 是否应该被观察到，且支持同时选择多个 Layer。具体内容可参考 Camera — Visibility 属性。 引擎内置的层级 属性 说明 值 NONE 设置全都不可见 0 IGNORE_RAYCAST 设置忽略射线检测 1 GIZMOS 设置配置信息可见 1 EDITOR 设置编辑器可见 1 UI_3D 设置 3D UI 节点可见 1 SCENE_GIZMO 设置场景配置节点可见 1 UI_2D 设置 2D UI 节点可见 1 PROFILER 设置分析工具节点可见 1 DEFAULT 设置默认节点可见 1 ALL 设置所有节点可见 0xffffffff 用户自定义层级 "},"concepts/scene/node.html":{"url":"concepts/scene/node.html","title":"Node","keywords":"","body":"Node Nodes are the basic building blocks of a scene. Nodes are organized in a tree-like relationship. Each Node can have multiple child nodes and correspond to a parent node at the same time. Nodes have the following characteristics: Nodes contain a set of basic information (displacement, rotation, scaling), and Nodes are organized together through a set of relative transformation relationships. The previous transform information of a Node is relative to it's parent node. The update order between Nodes follows the tree hierarchy order. The update of child nodes depends on the parent node, and the world transformation of child nodes is the combination of their local transformation and the world transform of their parent node. The parent/child relationship is very important. Components can be added to Nodes to associate multiple components with Nodes. In short, Nodes are the basic means of organizing the structure of any game. We can classify multiple elements through Nodes, and perform hierarchical operations on Nodes, or perform batch operations on a group of Nodes, such as: transform, delete, or hiding and showing them as needed, etc. "},"concepts/scene/scene.html":{"url":"concepts/scene/scene.html","title":"场景结构","keywords":"","body":"场景结构 Cocos Creator 在 Creator 的 ECS 实体组件系统框架上增加了3D场景结构，3D 场景通过 RenderScene 表示，ECS 结构中相应的 Component 引用了 RenderScene 中维护的模型（Model）、相机（Camera）、灯光（Light）等元素，它们通过 Node 关联在一起，RenderScene 中更新元素的各种 Transform，也是通过 Node 来操作。 注意区别 ECS 结构中的 Scene 与 3D 场景结构中的 RenderScene，ECS 中的 Scene 作为 Node 的逻辑组织结构，而 RenderScene 是作为场景渲染元素的组织结构，ECS Scene 中包含了 RenderScene 成员变量，两者一一对应。 ECS 与 3D 场景结构的关系，如下图所示： 整个 3D 场景结构是被封装在 Component 之下的，通过 Node 建立起组织关系，这样对于 ECS 的上层用户来说，是完全透明的，用户层面对于 3D 场景结构对象是无感知的。 "},"editor/preview/preview-guid.html":{"url":"editor/preview/preview-guid.html","title":"预览流程简介与常见错误处理","keywords":"","body":"预览流程简介与常见错误处理 本章节主要介绍浏览器预览的流程。 流程简介 浏览器预览本质上是编辑器开启了一个 express 服务器，在点击预览时打开用户的默认浏览器去访问预览 URL。预览模板里写了一些加载引擎和初始化场景的简单逻辑，而关于用户资源加载主要还是依赖于 settings.json 的生成，因为 settings.json 里面记载了当前项目的资源、脚本以及项目设置信息。预览的 settings.json 是调用构建插件的接口生成的，因此如果 settings.json 没有正常生成，便可以打开 开发者 -> 构建调试工具 查看。 常见错误处理 在遇到预览无法正常显示时，请先打开开发者工具的 NetWork 查看此时是否有资源或者脚本加载失败。 settings.json 加载失败 在寻找这个问题的原因之前，请先确保在预览前编辑器内没有报错信息。 settings.json 加载失败说明 settings.json 没能正常生成，这时候可以打开 开发者 —> 构建调试工具 查看是否有报错信息。正常情况下，如果生成失败基本会有对应的报错提示。比较常见的是脚本错误，因为在生成 settings 时会先加载一遍项目脚本，如果项目脚本内存在不合法的书写，那么在加载过程中便会抛出异常导致 settings.json 生成失败。具体报错的脚本信息可以参考报错信息内的提示，通常在此处的报错内容，有效信息都是资源的 UUID，可以复制对应的 UUID 到 资源管理器 中搜索定位该脚本。 关于 settings.json 具体的生成流程，可以参考 构建流程简介。预览的 settings.json 生成规则基本和只勾选了调试模式的生成规则一样，区别在于预览只梳理资源信息，并不会进行资源的打包生成。 资源加载 404 请将报 404 错误的资源的 UUID 到编辑器的 资源管理器 中搜索对应资源。 "},"editor/scene/camera-gizmo.html":{"url":"editor/scene/camera-gizmo.html","title":"摄像机 Gizmo","keywords":"","body":"摄像机 Gizmo 摄像机 Gizmo 用于显示摄像机的裁剪范围，摄像机相关的信息可以查看 摄像机介绍。 透视像机（Perspective） 透视摄像机 Gizmo 显示了由远近裁剪面和 FOV 构成的四棱台图形。可以使用方块控制点来编辑像机的远、近平面距离，FOV。 正交像机（Ortho） 正交摄像机 Gizmo 显示了由远近裁剪面、正交高度，所构成的长方体图形。可以使用方块控制点来编辑像机的远、近平面距离，正交高度。 "},"editor/scene/collider-gizmo.html":{"url":"editor/scene/collider-gizmo.html","title":"碰撞器 Gizmo","keywords":"","body":"碰撞器 Gizmo 有关 Cocos Creator 的碰撞器信息可以查看 物理介绍 盒碰撞器（Box Collider） 盒碰撞器 Gizmo 显示了盒子的长宽高，同时可以使用方块控制点来编辑长宽高。 球碰撞器（Sphere Collider) 球碰撞器 Gizmo 显示了球的大小，同时可以使用方块控制点来编辑球的半径。 "},"editor/scene/particle-system-gizmo.html":{"url":"editor/scene/particle-system-gizmo.html","title":"粒子系统 Gizmo","keywords":"","body":"粒子系统 Gizmo 粒子系统的 Gizmo 主要用于可视化粒子系统的发射器 ShapeModule。 盒子（Box） 盒子 Gizmo 显示了盒子的长宽高，同时可以使用方块控制点来编辑长宽高。 球（Sphere） 球 Gizmo 显示了球的大小，同时可以使用方块控制点来编辑球的半径。 半球（Hemisphere） 半球 Gizmo 显示了半球的大小，同时可以使用方块控制点来编辑半球的半径。 圆（Circle） 圆 Gizmo 显示了圆的大小，同时可以使用方块控制点来编辑圆的半径。 圆锥（Cone） 圆锥 Gizmo 显示了圆锥的形状，同时可以使用方块控制点来编辑圆锥的半径、角度、高度。 "},"render-pipeline/post-process.html":{"url":"render-pipeline/post-process.html","title":"后期处理","keywords":"","body":"后期处理 要新建一个后期处理需要新建一个 RenderFlow 脚本，然后将其 type 设为 POSTPROCESS。制作流程与其它 RenderFlow 相同，但 RenderPipeline 不会自动执行后期处理，需要在 Camera 中设置 flows 属性来指定执行哪些后期处理。 "},"render-pipeline/user-pipeline.html":{"url":"render-pipeline/user-pipeline.html","title":"自定义渲染管线","keywords":"","body":"自定义渲染管线 要创建一个自定义的渲染管线，首先要在 资源管理器 面板中新建一个 RenderPipeline 资源，再创建一个 RenderPipeline 脚本，然后在 Pipeline 资源中选择对应的 RenderPipeline 脚本，即可编辑对应的属性。 RenderFlow 和 RenderStage 使用同样的方式进行创建和编辑。在创建出来的 Pipeline 脚本中，可以像其它用户脚本一样添加属性并使其可以在 属性检查器 面板中编辑，但需要注意的是不能拖放场景中的实体，因为 RenderPipeline 并不和某个具体的场景绑定。 RenderPipeline 中的属性和方法 flows：RenderPipeline 中包含的 RenderFlow。 renderTextures：在 RenderPipeline 启动时可创建的 RenderTexture。 name：RenderTexture 的名字，创建后可通过 RenderPipeline 的 getRenderTexture 函数获取。 type：RenderTexture 的类型。 viewType：RenderTexture 对应的 TextureView 类型。 usage：RenderTexture 的绑定类型，用于确定是 color 还是 depth_stencil。 formate：RenderTexture 的通道格式。 width：RenderTexture 的宽度，-1 表示窗口宽度。 height：RenderTexture 高度，-1 表示窗口高度。 framebuffers：在 RenderPipeline 启动时可创建的 FrameBuffer。 name：FrameBuffer 的名字，创建后可通过 RenderPipeline 的 getFrameBuffer 函数获取。 renderPass：RenderPass。RenderPipeline 中配置的 RenderPass 的 ID。 colorViews：与 ColorAttachment 绑定的 TextureView。指定 RenderPipeline 中配置的 RenderTexture。 depthStencilView：与 DepthStencilAttachment 绑定的 TextureView。指定 RenderPipeline 中配置的 RenderTexture。 renderPasses：在 RenderPipeline 启动时可创建的 RenderPass。 index：RenderPass 的 ID，可通过 RenderPipeline 的 getRenderPass 函数获取。 colorAttachments：ColorAttachment 描述，绘制 FrameBuffer 时对 ColorAttachment 的操作。 depthStencilAttachment：DepthStencilAttachment 描述，绘制 FrameBuffer 时对 DepthStencilAttachment 的操作。 getTextureView (name: string)，getRenderTexture (name: string)：用于获取在 renderTextures 配置的 RenderTexture。 getFrameBuffer (name: string)：用于获取在 framebuffers 配置的 FrameBuffer。 getRenderPass (stage: number)：用于获取在 renderPasses 配置的 RenderPass。 initialize (info: IRenderPipelineInfo)：用于通过脚本创建一个 RenderPipeline 时的初始化函数，RenderPipeline 必须初始化后才能使用。 activate (root: Root)：用于通过资源加载一个 RenderPipeline 时的初始化函数，RenderPipeline 必须初始化后才能使用。 render (view: RenderView)：渲染场景的逻辑。 updateUBOs (view: RenderView)：更新全局 UniformBuffer。 sceneCulling (view: RenderView)：场景剔除，剔除后可渲染物体保存在 _renderObjects 中。 RenderFlow 中的属性和方法 name：RenderFlow 的名字。 priority：RenderFlow 在 RenderPipeline 中的执行顺序。 type：RenderFlow 的类型。包括以下三种： SCENE：用于绘制场景，该类型对于每个 camera 都会执行； POSTPROCESS：后期处理，该类型对每个 camera 都要单独指定； UI：用于绘制 UI。 stages：RenderFlow 包含的 RenderStage。 RenderStage 中的属性和方法 name：RenderStage 的名字。 priority：RenderStage 在 RenderFlow 中的执行顺序。 frameBuffer：RenderStage 要绘制到的 FrameBuffer，应设置为 RenderPipeline 中配置的 FrameBuffer，或设置为 window，表示使用默认的 FrameBuffer。 renderQueues：渲染列队，用于控制物体渲染顺序。 isTransparent：标记渲染列队是否为半透明； sortMode：包括以下两种：FRONT_TO_BACK：从前向后排序；BACK_TO_FRONT：从后向前排序。 stages：指定渲染列队渲染材质中的哪些 pass，应指定为 pass 中的 phase。 sortRenderQueue()：对渲染列队排序； executeCommandBuffer (view: RenderView)：执行渲染指令。 "},"scripting/deprecated.html":{"url":"scripting/deprecated.html","title":"废弃 API","keywords":"","body":"废弃 API 框架说明 为了更友好和便利的维护废弃 API，将通过三个函数来实现： markAsWarning 对给予对象上的属性中嵌入一个警告，给予对象需要存在该属性。 removeProperty 重新定义给予对象上移除的属性，并嵌入一个报错，给予对象应不存在该属性。 replaceProperty 重新定义给予对象上移除的属性，并嵌入一个警告和调用新的属性，参数不兼容的需要进行适配，给予对象应不存在该属性。 函数签名 interface IRemoveItem { /** 废弃属性的名称 */ name: string; /** 警告的次数 */ logTimes?: number; /** 额外建议 */ suggest?: string; } interface IMarkItem { /** 废弃属性的名称 */ name: string; /** 警告的次数 */ logTimes?: number; /** 额外建议 */ suggest?: string; } interface IReplacement { /** 废弃属性的名称 */ name: string; /** 警告的次数 */ logTimes?: number; /** 替换属性的名称 */ newName?: string; /** 废弃属性的所属对象 */ target?: object; /** 废弃属性的所属对象的名称 */ targetName?: string; /** 自定义替换属性（函数） */ customFunction?: Function; /** 自定义替换属性的 setter */ customSetter?: (v: any) => void; /** 自定义替换属性的 getter */ customGetter?: () => any; } export let removeProperty: (owner: object, ownerName: string, properties: IRemoveItem[]) => void; export let markAsWarning: (owner: object, ownerName: string, properties: IMarkItem[]) => void; export let replaceProperty: (owner: object, ownerName: string, properties: IReplacement[]) => void; /** 此函数用于设置全局默认的信息输出次数 */ export function setDefaultLogTimes (times: number): void; 使用规范 按照模块划分，每个模块维护一份废弃文件。为了便于维护，命名统一为 deprecated.ts，并且放在相应模块的目录下，并需要在相应的模块的index.ts文件中import该文件，例如import './deprecated'。 注：cocos\\utils目录下的deprecated.ts文件为声明和实现文件。 使用示例 // 对于替换参数不兼容的 API，通过合适的自定义功能进行适配 replaceProperty(Animation.prototype, 'Animation.prototype', [ { name: 'removeClip', newName: 'removeState', customFunction: function (...args: any) { const arg0 = args[0] as AnimationClip; return Animation.prototype.removeState.call(this, arg0.name); } } ]); replaceProperty(vmath, 'vmath', [ { name: 'vec2', newName: 'Vec2', target: math, targetName: 'math', 'logTimes': 1 }, { name: 'EPSILON', target: math, targetName: 'math', 'logTimes': 2 } ]); removeProperty(vmath, 'vmath', [ { 'name': 'random', 'suggest': 'use Math.random.' } ]); markAsWarning(math, 'math', [ { 'name': 'toRadian' } ]); 使用注意 操作目标都是对象，如果想要修改类的成员函数，请传入target.prototype。 replaceProperty不传入newName或newTarget，表示和name或target一致。 如果要控制次数，最好在使用之前调用setDefaultLogTimes，因为别的模块可能会把默认次数改了。 "},"scripting/log.html":{"url":"scripting/log.html","title":"在引擎内添加 Log 信息","keywords":"","body":"在引擎内添加 Log 信息 本文档主要说明如何按照正确的规范在引擎内部代码中添加新的 Log 信息（包含 log、warning、error）。 Log 信息机制和背景 目前 Cocos Creator 中的 Log 信息是以一个错误信息表形式独立于引擎存储的，具体存储在 engine 目录下的 EngineErrorMap.md 中。而在引擎代码中，不允许直接以字符串形式写日志、警告、错误等信息，必须以下面三个 API 来书写： import { logID, warnID, errorID } from 'core/platform/debug'; logID(id, ...params); warnID(id, ...params); errorID(id, ...params); 这样做的主要目的是减少字符串在引擎源码中所占据的包体。 EngineErrorMap 的编写规范 EngineErrorMap 按照一百位来做大模块划分，总共四位，从 0000 到 9900，也就是说支持最多 100 个大模块。十位数是用来划分子模块的，或者也可以直接以连续的形式排列，这个由模块负责人决定。 由于历史原因，目前没有按照严格的优先级顺序来做排序，新建的模块可以简单得往后顺延。未来我们会做更好的排序管理和整理。 具体错误信息的编写规范如下： ### 4 number ID Message in english. 比如： ### 8300 Should only one camera exists, please check your project. 信息中支持使用 %s、%d、%f 这样的参数接收符，运行输出 LOG 时会按照参数顺序依次拼接到信息中。 EngineErrorMap 的维护 EngineErrorMap 修改后，如果希望代码中的调用生效，需要在 engine 目录下执行： > gulp build-debug-infos EngineErrorMap.md 的修改也要跟随引擎的其他修改提交到 git。 "},"scripting/modules/config.html":{"url":"scripting/modules/config.html","title":"获取 npm 包","keywords":"","body":"获取 npm 包 安装 Node.js npm 包管理工具 npm 附带在 Node.js 发行版中。安装 Node.js 之后即可使用。 通过以下命令确认 npm 的安装已成功： > npm -v # 可能的输出： # 6.14.9 安装 npm 包 在项目根目录中执行以下命令： > npm install --save protobufjs 会将 npm 包 protobufjs 安装到 /node_modules 目录中，并将对此包的依赖关系写入到文件 package.json 中。 package.json 文件是 npm 的清单文件，需要纳入版本控制。 Cocos Creator 推荐将自动生成的 package-lock.json 也纳入版本控制，以确保多个开发者之间安装相同版本的包。 /node_modules 目录一般不纳入版本控制。 当 package.json 记录了依赖之后，后续可直接执行以下命令重新安装或在其它环境中安装： > npm install 拓展：使用 npm 镜像 npm 默认从 官方 npmjs 源 读取和下载包。有些国家或地区可能因为网络问题导致安装失败或安装速度过慢，推荐通过切换镜像的方式来解决。 首先，全局安装 npm 包 nrm： > npm install -g nrm -g 表示全局，会将 npm 包直接安装到当前计算机中，只要执行一次后续就不需要再次执行。 查看有效的 npm 镜像： > npx nrm ls # 可能的输出： # * npm -------- https://registry.npmjs.org/ # yarn ------- https://registry.yarnpkg.com/ # cnpm ------- http://r.cnpmjs.org/ # taobao ----- https://registry.npm.taobao.org/ # nj --------- https://registry.nodejitsu.com/ # npmMirror -- https://skimdb.npmjs.com/registry/ # edunpm ----- http://registry.enpmjs.org/ 可根据当前地区选择合适的镜像。中国大陆用户使用 taobao 镜像是不错的选择。执行以下命令来切换镜像： > npx nrm use taobao # 或任何合适的镜像 该命令也是全局的。也可选择仅切换当前项目的镜像，见 nrm 选项。 镜像名 npm 是官方源的名称，因此，可通过以下命令切换回官方源： > npx nrm use npm "},"scripting/reference/coding-standards.html":{"url":"scripting/reference/coding-standards.html","title":"推荐编码规范","keywords":"","body":"推荐编码规范 下面是 Cocos Creator 开发团队使用的编码规范，收录在手册里以供游戏开发者和工具开发者参考。 命名规范 当我们为变量，函数和实例命名时, 使用 camelCase 命名法。 // bad const FOOBar = {}; const foo_bar = {}; function FOOBar () {} // good const fooBar = {}; function fooBar () {} 当变量、函数和实例命名涉及到缩写时，缩写在开头全部小写，在后续单词中，则全部大写。 // bad const Id = 0; const iD = 0; function requireId () {} // good const id = 0; const uuid = ''; function requireID () {} class AssetUUID {} 当我们为类或者模块命名时，使用 PascalCase 命名法。 // bad const foobar = cc.Class({ foo: 'foo', bar: 'bar', }); const foobar = require('foo-bar'); // good const FooBar = cc.Class({ foo: 'foo', bar: 'bar', }); const FooBar = require('foo-bar'); 推荐使用全大写加下划线来命名“常量”。 // bad const PRIVATE_VARIABLE = 'should not be unnecessarily uppercased within a file'; // bad var THING_TO_BE_CHANGED = 'should obviously not be uppercased'; // bad let REASSIGNABLE_VARIABLE = 'do not use let with uppercase variables'; // --- // allowed but does not supply semantic value export const apiKey = 'SOMEKEY'; // better in most cases export const API_KEY = 'SOMEKEY'; // --- // bad - unnecessarily uppercases key while adding no semantic value export const MAPPING = { KEY: 'value' }; // good export const Type = { SIMPLE: 'value' }; 使用前置下划线 _ 当我们为私有属性命名 // bad this.__firstName__ = 'foobar'; this.firstName_ = 'foobar'; // good this._firstName = 'foobar'; 文件名我们采用 dash 命名法 // bad fooBar.js FooBar.js // good foo-bar.js 语法规范 当类的属性声明没有初始化式的时候，应当声明 declare，否则可能面临性能问题。详情请参考 Issue // bad class A { public a: number; constructor (a : number) { // 相当于此处还有一句 this.a = void 0; // 注意可能面临性能问题！ this.a = a; } } // good class A { public a: number = 0; // Ok. constructor (a : number) { // 相当于此处还有一句 this.a = 0; // 但不会引起大的性能问题 this.a = a; } } // best class A { public declare a: number; public b: undefined | object; // OK: b 未在构造函数中二次赋值 public declare c: object | null; constructor (a: number, c: object) { this.a = a; this.c = c; } } 使用 Object.create(null) 创建一个字典 // bad const map = new Object(); // bad const map = {}; // good const map = Object.create(null); 使用 [] 创建一个数组 // bad const array = new Array(); // good const array = []; 尽可能在 TypeScript 代码中使用单引号 '' 来定义 string // bad const str = \"Hello World\"; // good const str = 'Hello World'; 多行 string 定义时, 尽可能使用 + 定义 // bad const errorMessage = 'This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.'; // bad const errorMessage = 'This is a super long error that was thrown because \\ of Batman. When you stop to think about how Batman had anything to do \\ with this, you would get nowhere \\ fast.'; // good const errorMessage = 'This is a super long error that was thrown because ' + 'of Batman. When you stop to think about how Batman had anything to do ' + 'with this, you would get nowhere fast.'; 使用 === 和 !== 而不是 == 和 != 书写规范 根据个人习惯, 和原代码作者格式, 选择 4 个空格或者 2 个空格作为缩进 // bad function () { ∙const name; } // very bad function () { ∙∙∙∙const name; } // good function () { ∙∙const name; } // good function () { ∙∙∙∙const name; } 行尾不要留有空格，文件底部请留一个空行 // bad function () {∙ ∙∙∙∙const name;∙ } /* EOF */ // good function () { ∙∙∙∙const name; } /* EOF */ 语句结尾请加 ; // bad proto.foo = function () { } // good proto.foo = function () { }; // bad function foo () { return 'test' } // very bad // returns `undefined` instead of the value on the next line, // always happens when `return` is on a line by itself because of Automatic Semicolon Insertion! function foo () { return 'test' } // good function foo () { return 'test'; } // bad function foo () { }; // good，这里不是语句结尾 function foo () { } 尽可能将 { 和表达式放在同一行 // bad if ( isFoobar ) { } // good if ( isFoobar ) { } // bad function foobar () { } // good function foobar () { } // bad const obj = { foo: 'foo', bar: 'bar', } // good const obj = { foo: 'foo', bar: 'bar', } 在 { 前请空一格 // bad if (isJedi){ fight(); } else{ escape(); } // good if (isJedi) { fight(); } else { escape(); } // bad dog.set('attr',{ age: '1 year', breed: 'Bernese Mountain Dog', }); // good dog.set('attr', { age: '1 year', breed: 'Bernese Mountain Dog', }); 在逻辑状态表达式 ( if, else, while, switch) 后请空一格 // bad if(isJedi) { fight (); } else{ escape(); } // good if (isJedi) { fight(); } else { escape(); } 二元、三元运算符的左右请空一格 // bad const x=y+5; const left = rotated? y: x; // good const x = y + 5; const left = rotated ? y : x; // bad for (let i=0; i 一些函数的声明方式 // bad const test = function () { console.log('test'); }; // good function test () { console.log('test'); } // bad function test () { console.log('test'); }; // good function test () { console.log('test'); } // bad function divisibleFunction () { return DEBUG ? 'foo' : 'bar'; } // best const divisibleFunction = DEBUG ? function () { return 'foo'; } : function () { return 'bar'; }; // bad function test(){ } // good function test () { } // bad const obj = { foo: function () { } }; // good const obj = { foo () { } }; // bad array.map(x=>x + 1); array.map(x => { return x + 1; }); // good array.map(x => x + 1); 在 Block 定义之间请空一行 // bad if (foo) { return bar; } return baz; // good if (foo) { return bar; } return baz; // bad const obj = { x: 0, y: 0, foo () { }, bar () { }, }; return obj; // good const obj = { x: 0, y: 0, foo () { }, bar () { }, }; return obj; 不要使用前置逗号定义 // bad const story = [ once , upon , aTime ]; // good const story = [ once, upon, aTime, ]; // bad const hero = { firstName: 'Ada' , lastName: 'Lovelace' , birthYear: 1815 , superPower: 'computers' }; // good const hero = { firstName: 'Ada', lastName: 'Lovelace', birthYear: 1815, superPower: 'computers', }; 单行注释请在斜杠后面加一个空格 //bad // good 多行注释写法 /* * good */ 需要导出到 API 文档的多行注释写法 /** * good */ 除了多语言 API 注释以外，代码中不允许写中文注释 // bad // 中文注释不利于非中文开发者阅读代码 // good // Please write all in file comments in English 推荐阅读 Airbnb ts Style Guide "},"ui-system/components/editor/graphics/arc.html":{"url":"ui-system/components/editor/graphics/arc.html","title":"arc","keywords":"","body":"arc arc() 方法创建弧/曲线（用于创建圆或部分圆）。 提示：如需通过 arc() 来创建圆，请把起始角设置为 0，结束角设置为 2*Math.PI。 参数 描述 x 中心控制点的坐标 x 坐标。 y 中心控制点的坐标 y 坐标。 r 圆弧弧度。 startAngle 开始弧度，从正 x 轴顺时针方向测量。 endAngle 结束弧度，从正 x 轴顺时针方向测量。 counterclockwise 确定绘图方向：当设置为 False 时为 顺时针（默认）当设置为 true 时为 逆时针 实例 const ctx = node.getComponent(Graphics); ctx.arc(100,75,50,0,1.5*Math.PI); ctx.stroke(); 返回 Graphics 组件参考 "},"ui-system/components/editor/graphics/bezierCurveTo.html":{"url":"ui-system/components/editor/graphics/bezierCurveTo.html","title":"bezierCurveTo","keywords":"","body":"bezierCurveTo bezierCurveTo() 方法通过使用表示三次贝塞尔曲线的指定控制点，向当前路径添加一个点。 注意：三次贝塞尔曲线需要三个点。前两个点是用于三次贝塞尔计算中的控制点，第三个点是曲线的结束点。曲线的开始点是当前路径中最后一个点。 参数 描述 cp1x 第一个贝塞尔控制点的 x 坐标 cp1y 第一个贝塞尔控制点的 y 坐标 cp2x 第二个贝塞尔控制点的 x 坐标 cp2y 第二个贝塞尔控制点的 y 坐标 x 结束点的 x 坐标 y 结束点的 y 坐标 实例 const ctx = node.getComponent(Graphics); ctx.moveTo(20,20); ctx.bezierCurveTo(20,100,200,100,200,20); ctx.stroke(); 返回 Graphics 组件参考 "},"ui-system/components/editor/graphics/circle.html":{"url":"ui-system/components/editor/graphics/circle.html","title":"circle","keywords":"","body":"circle circle() 方法创建圆形。 参数 描述 cx 圆的中心的 x 坐标。 cy 圆的中心的 y 坐标。 r 圆的半径。 实例 const ctx = node.getComponent(Graphics); ctx.circle(200,200, 200); ctx.stroke(); 返回 Graphics 组件参考 "},"ui-system/components/editor/graphics/clear.html":{"url":"ui-system/components/editor/graphics/clear.html","title":"clear","keywords":"","body":"clear clear() 清空所有路径。 实例 update: function (dt) { const ctx = node.getComponent(Graphics); ctx.clear(); ctx.circle(200,200, 200); ctx.stroke(); } 返回 Graphics 组件参考 "},"ui-system/components/editor/graphics/close.html":{"url":"ui-system/components/editor/graphics/close.html","title":"close","keywords":"","body":"close close() 方法创建从当前点到开始点的路径。 实例 const ctx = node.getComponent(Graphics); ctx.moveTo(20,20); ctx.lineTo(20,100); ctx.lineTo(70,100); ctx.close(); ctx.stroke(); 返回 Graphics 组件参考 "},"ui-system/components/editor/graphics/ellipse.html":{"url":"ui-system/components/editor/graphics/ellipse.html","title":"ellipse","keywords":"","body":"ellipse ellipse() 方法创建椭圆。 参数 描述 cx 圆的中心的 x 坐标。 cy 圆的中心的 y 坐标。 rx 圆的 x 半径。 ry 圆的 y 半径。 实例 const ctx = node.getComponent(Graphics); ctx.ellipse(200,100, 200,100); ctx.stroke(); 返回 Graphics 组件参考 "},"ui-system/components/editor/graphics/fill.html":{"url":"ui-system/components/editor/graphics/fill.html","title":"fill","keywords":"","body":"fill fill() 方法填充当前的图像（路径）。默认颜色是白色 注释：如果路径未关闭，那么 fill() 方法会从路径结束点到开始点之间添加一条线，以关闭该路径，然后填充该路径。 实例 const ctx = node.getComponent(Graphics); ctx.rect(20,20,150,100); ctx.fillColor = Color.GREEN; ctx.fill(); 返回 Graphics 组件参考 "},"ui-system/components/editor/graphics/fillColor.html":{"url":"ui-system/components/editor/graphics/fillColor.html","title":"fillColor","keywords":"","body":"fillColor fillColor 属性设置或返回用于填充的颜色。 实例 const ctx = node.getComponent(Graphics); ctx.fillColor = new Color().fromHEX('#0000ff'); ctx.rect(20,20,250,200); ctx.stroke(); 返回 Graphics 组件参考 "},"ui-system/components/editor/graphics/lineCap.html":{"url":"ui-system/components/editor/graphics/lineCap.html","title":"lineCap","keywords":"","body":"lineCap lineCap 属性设置或返回线条末端线帽的样式。 参数 描述 Graphics.LineCap.BUTT 默认。向线条的每个末端添加平直的边缘。 Graphics.LineCap.ROUND 向线条的每个末端添加圆形线帽。 Graphics.LineCap.SQUARE 向线条的每个末端添加正方形线帽。 实例 const ctx = node.getComponent(Graphics); ctx.lineCap = Graphics.LineCap.ROUND; ctx.lineWidth = 10; ctx.moveTo(100, 100); ctx.lineTo(300, 100); ctx.stroke(); 返回 Graphics 组件参考 "},"ui-system/components/editor/graphics/lineJoin.html":{"url":"ui-system/components/editor/graphics/lineJoin.html","title":"lineJoin","keywords":"","body":"lineJoin lineJoin 属性设置或返回线条末端线帽的样式。 参数 描述 Graphics.LineJoin.BEVEL 创建斜角。 Graphics.LineJoin.ROUND 创建圆角。 Graphics.LineJoin.MITER 默认。创建尖角。 实例 const ctx = node.getComponent(Graphics); ctx.lineJoin = Graphics.LineJoin.ROUND; ctx.moveTo(20,20); ctx.lineTo(100,50); ctx.lineTo(20,100); ctx.stroke(); 返回 Graphics 组件参考 "},"ui-system/components/editor/graphics/lineTo.html":{"url":"ui-system/components/editor/graphics/lineTo.html","title":"lineTo","keywords":"","body":"lineTo lineTo() 方法添加一个新点，然后创建从该点到画布中最后指定点的线条。 参数 描述 x 路径的目标位置的 x 坐标 y 路径的目标位置的 y 坐标 实例 const ctx = node.getComponent(Graphics); ctx.moveTo(20,100); ctx.lineTo(20,20); ctx.lineTo(70,20); ctx.stroke(); 返回 Graphics 组件参考 "},"ui-system/components/editor/graphics/lineWidth.html":{"url":"ui-system/components/editor/graphics/lineWidth.html","title":"lineWidth","keywords":"","body":"lineWidth lineWidth() 方法添加一个新点，然后创建从该点到画布中最后指定点的线条。 参数 描述 number 当前线条的宽度，以像素计。 实例 const ctx = node.getComponent(Graphics); ctx.lineWidth = 20; ctx.rect(20,20,80,100); ctx.stroke(); 返回 Graphics 组件参考 "},"ui-system/components/editor/graphics/miterLimit.html":{"url":"ui-system/components/editor/graphics/miterLimit.html","title":"miterLimit","keywords":"","body":"miterLimit miterLimit 属性设置或返回最大斜接长度。斜接长度指的是在两条线交汇处内角和外角之间的距离。 注意：只有当 lineJoin 属性为 miter 时，miterLimit 才有效。 边角的角度越小，斜接长度就会越大。为了避免斜接长度过长，我们可以使用 miterLimit 属性。如果斜接长度超过 miterLimit 的值，边角会以 lineJoin 的 bevel 类型来显示 参数 描述 number 正数。规定最大斜接长度。如果斜接长度超过 miterLimit 的值，边角会以 lineJoin 的 bevel 类型来显示。 实例 const ctx = node.getComponent(Graphics); ctx.miterLimit = 10; ctx.moveTo(20,20); ctx.lineTo(100,50); ctx.lineTo(20,100); ctx.stroke(); 返回 Graphics 组件参考 "},"ui-system/components/editor/graphics/moveTo.html":{"url":"ui-system/components/editor/graphics/moveTo.html","title":"moveTo","keywords":"","body":"moveTo moveTo 表示一条路径的起点。 参数 描述 x 路径的目标位置的 x 坐标 y 路径的目标位置的 y 坐标 实例 const ctx = node.getComponent(Graphics); ctx.moveTo(0,0); ctx.lineTo(300,150); ctx.stroke(); 返回 Graphics 组件参考 "},"ui-system/components/editor/graphics/quadraticCurveTo.html":{"url":"ui-system/components/editor/graphics/quadraticCurveTo.html","title":"quadraticCurveTo","keywords":"","body":"quadraticCurveTo quadraticCurveTo() 方法通过使用表示二次贝塞尔曲线的指定控制点，向当前路径添加一个点。 提示：二次贝塞尔曲线需要两个点。第一个点是用于二次贝塞尔计算中的控制点，第二个点是曲线的结束点。曲线的开始点是当前路径中最后一个点 参数 描述 cpx 贝塞尔控制点的 x 坐标 cpy 贝塞尔控制点的 y 坐标 x 结束点的 x 坐标 y 结束点的 y 坐标 实例 const ctx = node.getComponent(Graphics); ctx.moveTo(20,20); ctx.quadraticCurveTo(20,100,200,20); ctx.stroke(); 返回 Graphics 组件参考 "},"ui-system/components/editor/graphics/rect.html":{"url":"ui-system/components/editor/graphics/rect.html","title":"rect","keywords":"","body":"rect rect() 方法创建矩形。 参数 描述 x 矩形左下点的 x 坐标。 y 矩形左下点的中心的 y 坐标。 width 矩形的宽度。 height 矩形的高度。 实例 const ctx = node.getComponent(Graphics); ctx.rect(20,20,150,100); ctx.stroke(); const ctx = node.getComponent(Graphics); // 红色矩形 ctx.lineWidth = 6; ctx.strokeColor = Color.RED; ctx.rect(5,5,290,140); ctx.stroke(); // 绿色矩形 ctx.lineWidth=4; ctx.strokeColor = Color.GREEN; ctx.rect(30,30,50,50); ctx.stroke(); // 蓝色矩形 ctx.lineWidth = 10; ctx.strokeColor = Color.BLUE; ctx.rect(50,50,150,80); ctx.stroke(); 返回 Graphics 组件参考 "},"ui-system/components/editor/graphics/stroke.html":{"url":"ui-system/components/editor/graphics/stroke.html","title":"stroke","keywords":"","body":"stroke stroke() 方法会实际地绘制出通过 moveTo() 和 lineTo() 等路径方法定义的路径。默认颜色是黑色。 实例 const ctx = node.getComponent(Graphics); ctx.moveTo(20, 100); ctx.lineTo(20, 20); ctx.lineTo(70, 20); ctx.stroke(); 返回 Graphics 组件参考 "},"ui-system/components/editor/graphics/strokeColor.html":{"url":"ui-system/components/editor/graphics/strokeColor.html","title":"strokeColor","keywords":"","body":"strokeColor strokeColor 属性设置或返回用于笔触的颜色。 实例 const ctx = node.getComponent(Graphics); ctx.lineWidth = 2; ctx.strokeColor = hexToColor('#0000ff'); ctx.rect(20,20,250,200); ctx.stroke(); 返回 Graphics 组件参考 "},"asset/texture-cube.html":{"url":"asset/texture-cube.html","title":"立方体贴图资源","keywords":"","body":"立方体贴图 TextureCube 为立方体纹理，常用于设置场景的 天空盒。立方体贴图可以通过设置全景图 ImageAsset 为 TextureCube 类型获得，也可以在 Creator 中制作生成。 设置为立方体贴图 在将 ImageAsset 导入 到 Creator 后，即可在 属性检查器 面板将其设置为 texture cube 类型，设置完成后请点击右上角的绿色打钩按钮，以保存修改。 设置完成后在 资源管理器 面板可以看到原先的图像资源下方生成了一个 textureCube 子资源，以及组成 TextureCube 的六张 texture： 制作立方体贴图 在 Creator 中通过制作 CubeMap 获得的 TextureCube 如下图： 关于 TextureCube 具体的使用，以及制作 CubeMap 的方式，请参考 天空盒 — 设置 CubeMap。 "},"asset/json.html":{"url":"asset/json.html","title":"JSON 资源","keywords":"","body":"JSON 资源 Creator 支持使用 Json 文件，通过 资源导入 的方式将其导入到编辑器，所有的 JSON 文件都会导入为 cc.JsonAsset 格式的资源。 使用方式 开发者可通过 编辑器挂载 和 代码中动态加载 两种方式获取 Json 数据。 通过编辑器 首先在 资源管理器 中新建一个 TypeScript，脚本内容示例如下： import { _decorator, Component, JsonAsset } from 'cc'; const { ccclass, property } = _decorator; @ccclass('ItemTemplate') export class ItemTemplate extends Component { // 声明属性 ‘itemGiftJson‘ 的类型为 JsonAsset @property(JsonAsset) itemGiftJson: JsonAsset = null!; start () { // 获取到 Json 数据 const jsonData: object = this.itemGiftJson.json!; } } 保存脚本内容后回到编辑器，将脚本挂载到相应的节点上，然后将 资源管理器 中的 Json 资源拖拽到脚本组件相应的属性框中。例如下图： 通过代码动态加载 开发者也可以直接通过代码 动态加载 来获取 Json 数据，代码示例如下： import { _decorator, Component, JsonAsset, resources, error } from 'cc'; const { ccclass, property } = _decorator; @ccclass('ItemTemplate') export class ItemTemplate extends Component { start () { resources.load('gameGiftJson', (err: any, res: JsonAsset) => { if (err) { error(err.message || err); return; } // 获取到 Json 数据 const jsonData: object = res.json!; }) } } "},"asset/text.html":{"url":"asset/text.html","title":"文本资源","keywords":"","body":"文本资源 Creator 支持使用文本文件，常见的文本格式如：.txt、.plist、.xml、.json、.yaml、.ini、.csv、.md。通过 资源导入 的方式将其导入到编辑器，所有的文本文件都会导入为 cc.TextAsset 格式的资源。 使用方式 开发者可通过 编辑器挂载 和 代码中动态加载 两种方式获取文本数据。 通过编辑器 首先在 资源管理器 中新建一个 TypeScript，脚本内容示例如下： import { _decorator, Component, TextAsset } from 'cc'; const { ccclass, property } = _decorator; @ccclass('ItemTemplate') export class ItemTemplate extends Component { // 声明属性 ‘itemGiftText‘ 的类型为 TextAsset @property(TextAsset) itemGiftText: TextAsset = null!; start () { const data: string = this.itemGiftText.text!; } } 保存脚本内容后回到编辑器，将脚本挂载到相应的节点上，然后将 资源管理器 中的文本资源拖拽到脚本组件相应的属性框中。例如下图： 通过代码动态加载 开发者也可以直接通过代码 动态加载 来获取文本数据，代码示例如下： import { _decorator, Component, resources, error, TextAsset } from 'cc'; const { ccclass, property } = _decorator; @ccclass('ItemTemplate') export class ItemTemplate extends Component { start () { resources.load('itemGiftText', (err: any, res: TextAsset) => { if (err) { error(err.message || err); return; } // 获取到文本数据 const textData = res.text; }) } } "},"module-map/mesh/skinnedMeshRenderer.html":{"url":"module-map/mesh/skinnedMeshRenderer.html","title":"SkinnedMeshRenderer 组件","keywords":"","body":"蒙皮网格渲染器组件（SkinnedMeshRenderer） 蒙皮网格渲染器组件（SkinnedMeshRenderer）主要用于渲染蒙皮模型网格。 导入模型资源 后，若模型网格中带有蒙皮信息，在使用模型时，SkinnedMeshRenderer 组件便会自动添加到模型节点上。 属性 属性 功能 Materials 网格资源允许使用多个材质资源，所有材质资源都存在 materials 数组中。如果网格资源中有多个子网格，那么 Mesh Renderer 会从 materials 数组中获取对应的材质来渲染此子网格。 LightmapSettings 用于烘焙 Lightmap，详情请参考 光照贴图。 ShadowCastingMode 指定当前模型是否会投射阴影，需要先在场景中 开启阴影。 ReceiveShadow 指定当前模型是否会接收并显示其它物体产生的阴影效果，需要先在场景中 开启阴影。该属性仅在阴影类型为 ShadowMap 时生效。 Mesh 指定渲染所用的网格资源，网格渲染器组件中 网格资源 部分的内容。 Skeleton 当前模型的骨骼数据，一般直接来自导入的 glTF 或 FBX 模型文件 SkinningRoot 骨骼根节点的引用，对应控制该模型的动画组件所在节点 蒙皮网格渲染器组件相关接口请参考 SkinnedMeshRenderer API。 蒙皮网格渲染器组件（SkinnedMeshRenderer）与普通的网格渲染组件（MeshRenderer）的区别在于： MeshRenderer 组件渲染的是静态模型，由 3D 模型数据组成 SkinnedMeshRenderer 组件不但渲染模型还会渲染骨骼，因此除了 3D 模型数据外，还包括骨骼数据以及顶点权重等数据。但如果 SkinnedMeshRenderer 上没有挂载任何骨骼数据，那么它和普通的 MeshRenderer 组件没有区别。 "},"module-map/mesh/skinnedMeshBatchRenderer.html":{"url":"module-map/mesh/skinnedMeshBatchRenderer.html","title":"SkinnedMeshBatchRenderer 组件","keywords":"","body":"批量蒙皮网格渲染器组件（SkinnedMeshBatchRenderer） 批量蒙皮网格渲染器组件（SkinnedMeshBatchRenderer）用于将同一个骨骼动画组件控制的所有子蒙皮模型网格合并渲染。 属性 功能 Operation 对属性的任何修改不会立即生效，需要点 Cook 按钮重新计算才能应用。 Materials 合批后使用的“母材质”需要使用自己定制的合批版 effect。 LightmapSettings 用于烘焙 Lightmap，详情请参考 光照贴图。 ShadowCastingMode 指定当前模型是否会投射阴影，需要先在场景中 开启阴影。 ReceiveShadow 指定当前模型是否会接收并显示其它物体产生的阴影效果，需要先在场景中 开启阴影。该属性仅在阴影类型为 ShadowMap 时生效。 SkinningRoot 骨骼蒙皮的根节点，一般为 SkeletalAnimation 组件所在节点。 AtlasSize 合图生成的最终图集的边长。 BatchableTextureNames 材质中真正参与合图的贴图属性，不参与的属性统一使用第一个 unit 的贴图。 Units 合批前的子蒙皮模型数据，是主要的数据来源。 Mesh 当前子模型的模型数据，一般直接来自 glTF 或 FBX 模型文件。 Skeleton 当前模型的骨骼数据，一般直接来自 glTF 或 FBX 模型文件。 Materials 当前子模型使用的“子材质”，使用的是非合批版的普通 effect，不同子模型使用的 effect 应保持一致。 Offset 当前子模型合图时的偏移，以图集左上角为原点，范围为 [0, 1]。比如图中数据代表子贴图与图集的左上角是重合的。 Size 当前子模型合图时所占的尺寸，范围为 [0, 1]。比如图中数据代表子贴图占整个图集的 1/2。 CopyFrom 可以通过拖入 SkinningModelComponent 自动复制目标属性（除了 offset 和 size），方便操作。 更多合批相关的内容，详情请参考文档 骨骼动画 — BatchedSkinnedMeshRenderer 组件。 批量蒙皮网格渲染器组件的相关接口，请参考 SkinnedMeshBatchRenderer API。 "},"submit-pr/submit-pr.html":{"url":"submit-pr/submit-pr.html","title":"如何向 Cocos 提交代码","keywords":"","body":"如何向 Cocos 提交代码 Cocos Creator 是一个开源引擎，连同范例、文档都是开源的。 在你开发游戏的过程中，当发现了引擎、文档或者范例不够完善的地方，如果仅仅是向官方团队提出建议，官方团队可能会因为人力资源的紧张而无法及时跟进。在此我们欢迎所有用户主动向我们提交 PR，帮助 Cocos 越做越好。引擎有 Bug？提 PR！范例难看？提 PR！API 注释不清晰？提 PR！文档有错别字？提 PR！想要把你的宝贵修改贡献给游戏社区？提 PR！以下几个是目前官方比较常用的开源仓库，这些仓库都可以提交 PR。 TypeScript 引擎：GitHub | Gitee engine-native 引擎：GitHub | Gitee 下面让我们来看一下，如何从零开始在 GitHub 上向 Cocos 提交代码。 注册一个 GitHub 账号 打开 GitHub 网站 注册账号。若之前已经有注册过，那直接登录就可以了。 环境配置 安装 Git 首先先确认电脑是否已经安装 Git，命令行输入 git，安装过则会输出以下内容： 未安装过则 下载 Git 并安装。安装过程中的所有选项保留默认就可以了，一直点 next，直到安装完成。 安装 Git 客户端 —— GitKraken GitKraken 是比较常用的 Git 客户端工具。如果不使用 GitKraken 的话，Git 操作全部要通过命令行操作完成，比较麻烦。下面以 Windows 版本为例进行演示。 首先需要下载 GitKraken 并解压缩，进行安装。 安装完成后界面如下图所示： Fork 项目 以手册文档的代码仓库 creator-docs（GitHub | Gitee）为例。进入手册文档仓库页面，点击右上角的 Fork 按钮，如下图所示： Fork 完成后，会自动跳转到你的 GitHub 仓库页面，可以看到已经生成了 docs-3d 项目副本，如下图所示： 将远程仓库克隆到本地仓库 1、首先需要到你的远程仓库复制 远程仓库项目地址，如下图所示： 2、切换到 GitKraken 后点击上方的 Clone a repo 按钮，跳转到 Clone 页面，粘贴刚才复制的 远程仓库项目地址，然后填入相关配置。如果想让本地的文件夹名称和项目名称一样，那么在本地存储路径后添加 /docs-3d。配置完成后点击 Clone。 克隆完成后就会在本地自动创建 docs-3d 文件夹并且在 GitKraken 上自动打开项目。 上传本地修改到远程仓库 1、检出需要的分支。在左侧的 REMOTE 目录下有一个 origin 仓库，这是你自己的远程仓库。例如要修改的分支是 next 分支，则点击 origin 后双击 next 分支。如下图所示： 注意：根据不同的版本，还需要切换不同的分支，例如： vX.Y 分支：对应 X.Y 版本所用分支 develop 分支：开发分支 2、打开本地 docs-3d 项目进行修改，修改完成后查看仓库详情，如下图所示： 3、提交暂存区文件到本地仓库。将你要上传的修改文件提交到本地暂存区，然后在下方备注提交内容注释。完成之后点击 Commit，将暂存区文件提交到本地仓库。完成后点击 Push。步骤如下图所示： 4、将本地仓库的修改推送到自己的远程仓库 origin。 5、完成之后，到 GitHub 自己的 docs-3d 远程仓库查看（可以从 右上方的头像 -> Your profile -> Repositories -> docs-3d 进入你的远程仓库），可以看到已经有本次的提交信息了。然后点击 New pull request。 6、点击 New pull request 后会跳转到官方仓库的 Open a pull request。标题会自动填入刚才提交的信息，也可自行修改。下方的填写信息区域需要对提交内容进行适当的补充。特别是针对引擎本身的修改，请将问题描述、改动内容、涉及版本、相关平台等信息补充完整。如果有相关 Issue，或者论坛地址也可以贴上来。最下方的是本次提交的 PR 的改动详情。填写完成后点击 Create pull request。 7、创建完成后在官方仓库 docs-3d 的 pull requests 页面中可以看到创建了一个新的 PR。官方人员会收到提醒并将 PR 指派给相关人员进行 review 和合并。到此 PR 创建完成，若官方审核通过，就会把这个 PR 的修改合并到官方仓库中了。如果上方的Open图标变为Merged图标，则表示修改已合并到官网。若官方觉得有需要，也会在该 PR 上展开进一步讨论。请留意 GitHub 相关消息或关注 PR 所在页面，以免错过讨论。如果你需要修改 PR 提交的内容，请重复 上传本地修改到远程仓库 中的 2、3、4 步骤。 添加官方仓库 如果距离上次克隆仓库已经挺长时间，那么请在提交 PR 前先从官方仓库获取最新的修改以防和其他人的修改发生冲突。 1、添加官方仓库。点击 GitKraken 左边列表的 REMOTE +，如下图所示： 2、在 GitKraken 的 docs-3d 本地仓库的左侧，可以看到有 origin 和 cocos-creator3D 两个远程仓库，分别是自己的远程仓库和官方仓库。可以看到 远程 -> cocos-creator3D 下已经有了官方仓库的各个分支，如下图所示： 3、从官方仓库拉取最新更新。切换到要拉取的分支，然后点击左上方的 Pull。如下图所示： 注意：在更新官方版本前，如果你完全不熟悉 Git 的操作，建议先确保没有在本地的 Git 仓库中进行任何文件的改动。如果有的话，建议先手动还原，然后等更新完毕后再手动把改动添加回来。 如何反馈文档有关的问题 针对文档本身的问题，建议通过 GitHub issue 进行反馈，下面我们简单演示一下。在提交问题之前请先确认： 文档版本和 Creator 版本是否一致 操作步骤是否正确 是否是文档本身的问题，例如代码错误或者根据文档步骤执行出现异常等。 若以上问题都是确定的，那么，有以下两种提交方式： 1、可点击 Creator 官方文档右下方的 提交反馈 按钮，进入提交 issue 界面。 填写完成后点击 Submit new issue 提交 issue，就完成了。 2、或者也可以进入官方仓库 creator-docs（GitHub | Gitee），选择 Issue -> New issue 进入提交 issue 界面，填写内容并提交。 本次提交 pr 和提交 issue 的教程到这里就结束了，若有不理解或者有误的地方请根据上述步骤向我们反馈。 有些人可能会问，为什么要这么麻烦的提交问题。其实，正确的提交问题可以节省很多的沟通成本，而且有些问题可能在初步排查的时候就可以解决了，或者会发现只是由于自己粗心大意导致的。而官方节省下来的人力就可以更好的去服务于 Creator，让 Creator 能更好地为游戏开发者服务。 "},"advanced-topics/jsb-manual-binding.html":{"url":"advanced-topics/jsb-manual-binding.html","title":"JSB 手动绑定","keywords":"","body":"使用 JSB 手动绑定 本文转载自 腾讯在线教育部技术博客 作者：晋中望（xepherjin） 背景 一直以来，ABCmouse 项目中的整体 JS/Native 通信调用结构都是基于 callStaticMethod evalString 的方式。通过 callStaticMethod 方法我们可以通过反射机制直接在 JavaScript 中调用 Java/Objective-C 的静态方法。而通过 evalString 方式，则可以执行 JS 代码，这样便可以进行双端通信。 新版 ABCmouse 的应用架构：基于 callStaticMethod 与 evalString 进行通信 虽然基于这个方式上层封装接口后，新增业务逻辑会比较方便。但是过度依赖 evalString，往往也会带来一些隐患。举个 Android 侧的例子： CocosJavascriptJavaBridge.evalString(\"window.sample.testEval('\" + param + \"',JSON.stringify(\" + jsonObj + \"))\"); 对于常见的参数结构，这样运行是没有问题的，然而基于实际场景的种种情况，我们会发现针对 引号 的控制格外重要。如代码所示，为了保证 JS 代码能够被正确执行，我们在拼接字符串时必须明确 ' 与 \" 的使用，稍有不慎就会出现 evalString 失败的情况。在 Cocos 的官方论坛上，从大量的反馈中我们也能了解这里的确是一个十分容易踩坑的地方。而另一方面，对于我们项目本身而言，过度依赖 evalString 所产生的种种不确定因素也往往很难掌控，我们又不能一味地通过 try/catch 去解决。所幸的是，经过全局业务排查，目前项目中在绝大多数因此，在查阅官方文档后，我们决定绕过 evalString，直接基于 JSB 绑定的方式进行通信。 这里以下载器的接入为例。在我们的项目中，下载器是在 Android 与 iOS 侧分别各自实现。在改造之前的版本中，下载器的调用与回调基于 callStaticMethod evalString 的方式。 每次调用下载都需要这样执行： if(sys.isNative && sys.os == sys.OS.IOS) { jsb.reflection.callStaticMethod('ABCFileDownloader', 'downloadFileWithUrl:cookie:savePath:', url, cookies, savePath); } else if(sys.isNative && sys.os == sys.OS.ANDROID) { jsb.reflection.callStaticMethod(\"com/tencent/abcmouse/downloader/ABCFileDownloader\", \"downloadFileWithUrl\", \"(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V\", url, cookies, savePath); } 下载成功抑或是失败都需要通过拼接出类似如下的语句执行 JS： StringBuilder sb = new StringBuilder(JS_STRING_ON_DOWNLOAD_FINISH + \"(\"); sb.append(\"'\" + success + \"',\"); sb.append(\"'\" + url + \"',\"); sb.append(\"'\" + savePath + \"',\"); sb.append(\"'\" + msg + \"',\"); sb.append(\"'\" +code + \"')\"); CocosJavascriptJavaBridge.evalString(sb.toString()); 无论是调用抑或是回调都拼接繁琐又容易出错，全部数据不得不转化为字符串 （emmmm也不美观），而且还要考虑到 evalString 的执行效率问题。如果只是仅有的少数业务场景在使用尚勉强接受，但是当业务日趋复杂庞大，如果都要这样写，同时又没有详细的文档去规范约束，其后期维护成本可想而知。 而当使用 JSB 改造后，我们调用只需如下寥寥几行代码且无需区分平台，更不必担心上述拼接隐患，相比之下逻辑要清晰许多： jsb.fileDownloader.requestDownload(url, savePath, cookies, options, (success, url, savePath, msg, code) => { // do whatever you want }); 那么接下来就以一个最简单的下载器的绑定流程为例，我来带大家学习下 JSB 手动绑定的大致流程。 （虽然 Cocos Creator 很人性化提供了自动绑定的配置文件，可以通过一些配置直接生成目标文件，减少了很多工作量。但是亲手来完成一次手动绑定的流程会帮助更为全面地了解整个绑定的实现流程，有助于加深理解。另一方面，当存在特殊需要自动绑定无法满足时，手动绑定也往往会更为灵活） 前置 在开始之前，我们需要需要知道有关 ScriptEngine 抽象层、相关 API 等相关知识，这部分内容如果已从 Cocos Creator 文档了解可跳过，直接进行 实践 部分。 抽象层 首先先来看一下上图 Cocos 官方提供的一张抽象层架构，在 1.7 版本中，抽象层被设计为一个与引擎没有关系的独立模块，对 JS 引擎的管理从 ScriptingCore 被移动到了 se::ScriptEngine 类中，ScriptingCore 被保留下来是希望通过它把引擎的一些事件传递给封装层，充当适配器的角色。在这个抽象层提供了对 JavaScriptCore、SpiderMonkey、V8、ChakraCore 等多种可选的 JS 执行引擎的封装。JSB 的大部分工作其实就是设定 JS 相关操作的 C++ 回调，在回调函数中关联 C++ 对象。它其实主要包含如下两种类型： 注册 JS 函数（包含全局函数，类构造函数、类析构函数、类成员函数，类静态成员函数），绑定一个 C++ 回调 注册 JS 对象的属性读写访问器，分别绑定读与写的 C++ 回调 考虑到不同多种 JS 引擎的关键方法的定义各不相同，Cocos 团队使用 宏 来抹平这种回调函数定义与参数类型的差异，这里就不展开，详细可阅读文末 Cocos Creator 的相关文档。 值得一提的是，ScriptEngine 这层设计之初 Cocos 团队就将其定义为一个独立模块，完全不依赖 Cocos 引擎。 我们开发者完全可以把 cocos/bindings/jswrapper 下的所有抽象层源码移植到其他项目中直接使用。 SE 类型 C++ 抽象层所有的类型都在 se 命名空间下，其为 ScriptEngine 的缩写。 se::ScriptEngine 它是 JS 引擎的管理员，掌管 JS 引擎初始化、销毁、重启、Native 模块注册、加载脚本、强制垃圾回收、JS 异常清理、是否启用调试器。它是一个单例，可通过 se::ScriptEngine::getInstance() 得到对应的实例。 se::Value 可以被理解为 JS 变量在 C++ 层的引用。JS 变量有 object、number、string、boolean、null、undefined 六种类型，因此 se::Value 使用 union 包含 object、number、string、boolean 4 种有值类型，无值类型: null、undefined 可由私有变量 _type 直接表示。 如果 se::Value 中保存基础数据类型，比如 number、string、boolean，其内部是直接存储一份值副本。object 的存储比较特殊，是通过 se::Object* 对 JS 对象的弱引用。 se::Object 继承于 se::RefCounter 引用计数管理类，它保存了对 JS 对象的弱引用。我们在绑定回调中如果需要用到当前对象对应的 se::Object，只需要通过 s.thisObject() 即可获取。其中 s 为 se::State 类型。 se::Class 用于暴露 C++ 类到 JS 中，它会在 JS 中创建一个对应名称的构造函数。Class 类型创建后，不需要手动释放内存，它会被封装层自动处理。se::Class 提供了一些 API 用于定义 Class 的创建、静态/动态成员函数、属性读写等等，后面在实践时用到会做介绍。完整内容可查阅 Cocos Creator 文档。 se::State 它是绑定回调中的一个环境，我们通过 se::State 可以取得当前的 C++ 指针、se::Object 对象指针、参数列表、返回值引用。 宏 前面有提到，抽象层使用宏来抹平不同 JS 引擎关键函数定义与参数类型的不同，不管底层是使用什么引擎，开发者统一使用一种函数的定义。 例如，抽象层所有的 JS 到 C++ 的回调函数的定义为： bool foo(se::State& s) { ... ... } SE_BIND_FUNC(foo) // 此处以回调函数的定义为例 我们在编写完回调函数后，需要记住使用 SE_BIND_XXX 系列的宏对回调函数进行包装。目前全部的 SE_BIND_XXX 宏如下所示： SE_BIND_PROP_GET：包装一个 JS 对象属性读取的回调函数 SE_BIND_PROP_SET：包装一个 JS 对象属性写入的回调函数 SE_BIND_FUNC：包装一个 JS 函数，可用于全局函数、类成员函数、类静态函数 SE_DECLARE_FUNC：声明一个 JS 函数，一般在 .h 头文件中使用 SE_BIND_CTOR：包装一个 JS 构造函数 SE_BIND_SUB_CLS_CTOR：包装一个 JS 子类的构造函数，此子类可以继承 SE_BIND_FINALIZE_FUNC：包装一个 JS 对象被 GC 回收后的回调函数 SE_DECLARE_FINALIZE_FUNC：声明一个 JS 对象被 GC 回收后的回调函数 _SE：包装回调函数的名称，转义为每个 JS 引擎能够识别的回调函数的定义，注意，第一个字符为下划线，类似 Windows 下用的 _T(\"xxx\") 来包装 Unicode 或者 MultiBytes 字符串 在我们的简化版例子中，只需要用到 SE_DECLARE_FUNC、SE_BIND_FUNC 即可。 类型转换辅助函数 类型转换辅助函数位于 cocos/bindings/manual/jsb_conversions.h/.cpp 中，包含了多种 se::Value 与 C++ 类型相互转化的方法。 bool std_string_to_seval(const std::string& v, se::Value* ret); bool seval_to_std_string(const se::Value& v, std::string* ret); bool boolean_to_seval(bool v, se::Value* ret); bool seval_to_boolean(const se::Value& v, bool* ret); ... ... 实践 在开始之前，我们需要明确一下流程。JSB 绑定简单来讲就是在 C++ 层实现一些类库，然后经过一些特定处理可以在 JS 端进行对应方法调用的过程。因为采用 JS 为主要业务编写语言，使得我们在做一些 Native 的功能时会比较受限，例如文件、网络等等相关操作。 以 Cocos Creator 文档中 spine.SkeletonRenderer 为例，在 JSB 中 如果使用 new 操作符来调用 spine.SkeletonRenderer 的构造函数，实际上在 C++ 层会调用 js_spine_SkeletonRenderer_constructor 函数。在这个 C++ 函数中，会为这个精灵对象分配内存，并把它添加到自动回收池，然后调用 JS 层的 _ctor 函数来完成初始化。在 _ctor 函数中会根据参数类型和数量调用不同的 init 函数，这些 init 函数也是 C++ 函数的绑定： #define SE_BIND_CTOR(funcName, cls, finalizeCb) \\ void funcName##Registry(const v8::FunctionCallbackInfo& _v8args) \\ { \\ v8::Isolate* _isolate = _v8args.GetIsolate(); \\ v8::HandleScope _hs(_isolate); \\ bool ret = true; \\ se::ValueArray args; \\ se::internal::jsToSeArgs(_v8args, &args); \\ se::Object* thisObject = se::Object::_createJSObject(cls, _v8args.This()); \\ thisObject->_setFinalizeCallback(_SE(finalizeCb)); \\ se::State state(thisObject, args); \\ ret = funcName(state); \\ if (!ret) { \\ SE_LOGE(\"[ERROR] Failed to invoke %s, location: %s:%d\\n\", #funcName, __FILE__, __LINE__); \\ } \\ se::Value _property; \\ bool _found = false; \\ _found = thisObject->getProperty(\"_ctor\", &_property); \\ if (_found) _property.toObject()->call(args, thisObject); \\ } 三层的方法对应关系如下： Javascript JSB Cocos Creator jsb.SkeletonRenderer.initWithSkeleton js_spine_SkeletonRenderer_initWithSkeleton spine::SkeletonRenderer::initWithSkeleton jsb.SkeletonRenderer.initWithUUID js_spine_SkeletonRenderer_initWithUUID spine::SkeletonRenderer::initWithUUID 这个调用过程的时序如下： 调用时序图（引自 Cocos Creator 文档） 和上面的过程类似。首先，我们需要确定接口和字段，我们随便拟定一个最简单的下载器 FileDownloader，它所具备的是 download(url, path, callback) 接口，而在 callback 中我们需要拿到的则是 code，msg。并且为了方便使用，我们将它挂载在 jsb 对象下，这样我们便可以使用如下代码进行简单地调用: jsb.fileDownloader.download(url, path, (msg, code) => { // do whatever you want }); 确定接口后，我们可以开始着手码 C++ 部分了。首先来一发 FileDownloader.h，作为公共头文件供 Android/iOS 使用。接着 Android/iOS 分别实现各自的具体下载实现即可（此处略过），reqCtx 则用于存储回调对应关系： class FileDownloader { public: typedef std::function ResultCallback; static FileDownloader* getInstance(); static void destroyInstance(); void download(const std::string& url, const std::string& savePath, const ResultCallback& callback); void onDownloadResult(const std::string msg, const int code); ... ... protected: static FileDownloader* s_sharedFileDownloader; std::unordered_map reqCtx; }; 接下来我们进行最关键的绑定部分。 因为下载器就功能上分类属于 network 模块，我们可以选择将我们的 FileDownloader 的绑定实现在 Cocos 源码中现有的 jsb_cocos_network_auto 中。在 jsb_cocos_network_auto.h 中声明 JS 函数： SE_DECLARE_FUNC(js_network_FileDownloader_download); // 声明成员函数，下载调用 SE_DECLARE_FUNC(js_network_FileDownloader_getInstance); // 声明静态函数，获取单例 随后在 jsb_cocos_network_auto.cpp 中来注册 FileDownloader 和新声明的这两个函数到 JS 虚拟机中。首先先写好对应的两个方法实现留空，等注册逻辑完成后再来补全： static bool js_network_FileDownloader_download(se::State &s) { // 方法名与声明时一致 // TODO } SE_BIND_FUNC(js_network_FileDownloader_download); // 包装该方法 static bool js_network_FileDownloader_getInstance(se::State& s) { // 方法名与声明时一致 // TODO } SE_BIND_FUNC(js_network_FileDownloader_getInstance); // 包装该方法 现在我们开始编写注册逻辑，新增一个注册方法用于收归 FileDownloader 的全部注册逻辑： bool js_register_network_FileDownloader(se::Object* obj) { auto cls = se::Class::create(\"FileDownloader\", obj, nullptr, nullptr); cls->defineFunction(\"download\", _SE(js_network_FileDownloader_download)); cls->defineStaticFunction(\"getInstance\", _SE(js_network_FileDownloader_getInstance)); cls->install(); JSBClassType::registerClass(cls); se::ScriptEngine::getInstance()->clearException(); return true; } 我们来看看这个方法里做了些什么重要的事情： 调用 se::Class::create(className, obj, parentProto, ctor) 方法，创建了一个名为 FileDownloader 的 Class，注册成功后，在 JS 层中可以通过 let xxx = new FileDownloader();的方式创建实例。 调用 defineFunction(name, func) 方法，定义了一个成员函数 download，并将其实现绑定到包装后的 js_network_FileDownloader_download 上。 调用 defineStaticFunction(name, func) 方法，定义了一个静态成员函数 getInstance，并将其实现绑定到包装后的 js_network_FileDownloader_getInstance 上。 调用 install() 方法，将自己注册到 JS 虚拟机中。 调用 JSBClassType::registerClass 方法，将生成的 Class 与 C++ 层的类对应起来（内部通过 std::unordered_map 实现）。 通过以上这几步，我们完成了关键的注册部分，当然不要忘记在 network 模块的注册入口添加 js_register_network_FileDownloader 的调用： bool register_all_cocos_network(se::Object* obj) { // Get the ns se::Value nsVal; if (!obj->getProperty(\"jsb\", &nsVal)) { se::HandleObject jsobj(se::Object::createPlainObject()); nsVal.setObject(jsobj); obj->setProperty(\"jsb\", nsVal); } se::Object* ns = nsVal.toObject(); ... ... // 将前面生成的 Class 注册 设置为 jsb 的一个属性，这样我们便能通过 // let downloader = new jsb.FileDownloader(); // 获取实例 js_register_network_FileDownloader(ns); return true; } 完成这一步，我们的 Class 已经成功绑定，现在回来继续完善刚才留空的方法。 首先是 getInstance()： static bool js_network_FileDownloader_getInstance(se::State& s) { const auto& args = s.args(); size_t argc = args.size(); CC_UNUSED bool ok = true; if (argc == 0) { FileDownloader* result = FileDownloader::getInstance(); // C++ 单例 ok &= native_ptr_to_seval((FileDownloader*)result, &s.rval()); SE_PRECONDITION2(ok, false, \"js_network_FileDownloader_getInstance : Error processing arguments\"); return true; } SE_REPORT_ERROR(\"wrong number of arguments: %d, was expecting %d\", (int)argc, 0); return false; } 前面提到，我们可以通过 se::State 获取到 C++ 指针、se::Object 对象指针、参数列表、返回值引用。梳理逻辑如下： args() 获取 JS 带过来的全部参数（se::Value 的 vector）； 参数个数判断，因为这里的 getInstance() 并不需要额外参数，因此参数为 0； native_ptr_to_seval() 用于在绑定层根据一个 C++ 对象指针获取一个 se::Value，并赋返回值给 rval() 至 JS 层； 到这里，getInstance() 的绑定层逻辑已全部完成，我们已经可以通过 let downloader = jsb.FileDownloader.getInstance() 获取实例了。 接着是 download()： static bool js_network_FileDownloader_download(se::State &s) { FileDownloader *cobj = (FileDownloader *) s.nativeThisObject(); SE_PRECONDITION2(cobj, false, \"js_network_FileDownloader_download : Invalid Native Object\"); const auto &args = s.args(); size_t argc = args.size(); CC_UNUSED bool ok = true; if (argc == 3) { std::string url; std::string path; ok &= seval_to_std_string(args[0], &url); // 转化为std::string url ok &= seval_to_std_string(args[1], &path); // 转化为std::string path std::function callback; do { if (args[2].isObject() && args[2].toObject()->isFunction()) { se::Value jsThis(s.thisObject()); // 获取 JS 回调 se::Value jsFunc(args[2]); // 如果目标类是一个单例则不能用 se::Object::attachObject 去关联 // 必须使用 se::Object::root，无需关心 unroot，unroot 的操作会随着 lambda 的销毁触发 jsFunc 的析构，在 se::Object 的析构函数中进行 unroot 操作。 // 如果使用 s.thisObject->attachObject(jsFunc.toObject);会导致对应的 func 和 target 永远无法被释放，引发内存泄露。 jsFunc.toObject()->root(); auto lambda = [=](const std::string& msg, const int code) -> void { se::ScriptEngine::getInstance()->clearException(); se::AutoHandleScope hs; CC_UNUSED bool ok = true; se::ValueArray args; args.resize(2); ok &= std_string_to_seval(msg, &args[0]); ok &= int32_to_seval(code, &args[1]); se::Value rval; se::Object* thisObj = jsThis.isObject() ? jsThis.toObject() : nullptr; se::Object* funcObj = jsFunc.toObject(); // 执行 JS 方法回调 bool succeed = funcObj->call(args, thisObj, &rval); if (!succeed) { se::ScriptEngine::getInstance()->clearException(); } }; callback = lambda; } else { callback = nullptr; } } while(false); SE_PRECONDITION2(ok, false, \"js_network_FileDownloader_download : Error processing arguments\"); cobj->download(url, path, callback); return true; } SE_REPORT_ERROR(\"wrong number of arguments: %d, was expecting %d\", (int) argc, 3); return false; } 通过 seval_to_std_string 方法获取转化 C++ 后的 url、path 参数和原始 jsFunc。 手动构造回调 function，将 msg 和 code 转化为 se::Value。 通过 funcObj->call 执行 JS 方法进行回调。 最后，考虑到内存释放的风险，我们还需要在 Application.cpp 中的 close() 方法中进行相关回收： network::FileDownloader::destroyInstance(); ================================================ 以上就是全部的绑定流程，在分别编译到 Android/iOS 环境后，我们就能够通过 jsb.fileDownloader.download() 进行下载调用了。 （PS：一定切记在使用前进行 JSB 的宏判断，因为非 JSB 环境下是无法使用的） 总结 我们现在来总结一下手动绑定改造的详细流程。一般而言，常用的 JSB 的改造流程大致如下： 确定方法接口与 JS/Native 公共字段 声明头文件，并分别实现 Android JNI 与 OC 具体业务代码 编写抽象层代码，将必要的类与对应方法注册到 JS 虚拟机中 将绑定的类挂载在 JS 中的指定对象（类似命名空间）中 "}}